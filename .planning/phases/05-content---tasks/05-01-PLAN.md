---
phase: 05-content---tasks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/content/content.h
  - src/mcpp/content/content.cpp
  - src/mcpp/client/sampling.h
  - include/mcpp/public_headers.h
autonomous: true

must_haves:
  truths:
    - "Developer can use ImageContent for image data with base64 encoding and MIME type"
    - "Developer can use AudioContent for audio data with base64 encoding and MIME type"
    - "Developer can use ResourceLink to reference resources by URI"
    - "Developer can use EmbeddedResource to embed resource content directly"
    - "Developer can attach Annotations (audience, priority, lastModified) to any content type"
    - "ContentBlock variant includes all content types (text, image, audio, resource, embedded)"
    - "Content serialization/deserialization works via content_to_json/content_from_json"
  artifacts:
    - path: "src/mcpp/content/content.h"
      provides: "Rich content type definitions (ImageContent, AudioContent, ResourceLink, EmbeddedResource, Annotations)"
      contains: "struct ImageContent", "struct AudioContent", "struct ResourceLink", "struct EmbeddedResource", "struct Annotations"
    - path: "src/mcpp/content/content.cpp"
      provides: "Content serialization/deserialization implementation"
      exports: ["content_to_json", "content_from_json"]
    - path: "src/mcpp/client/sampling.h"
      provides: "Extended ContentBlock variant with all content types"
      contains: "using ContentBlock"
  key_links:
    - from: "src/mcpp/content/content.h"
      to: "nlohmann/json"
      via: "public header include"
      pattern: "#include <nlohmann/json.hpp>"
    - from: "src/mcpp/client/sampling.h"
      to: "src/mcpp/content/content.h"
      via: "include for shared content types"
      pattern: "#include \"mcpp/content/content.h\""
---

<objective>
Create rich content type support for MCP 2025-11-25 spec compliance with ImageContent, AudioContent, ResourceLink, EmbeddedResource, and Annotations metadata.

Purpose: Multi-modal LLM support requires images, audio, and resource references in content blocks. Annotations enable content routing and filtering by audience and priority.

Output: New content.h header in mcpp::content namespace with all content types, JSON conversion functions, and extended ContentBlock variant in sampling.h.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-content---tasks/05-RESEARCH.md

# Existing patterns
@src/mcpp/client/sampling.h (lines 43-86) — Current ContentBlock with TextContent, ToolUseContent, ToolResultContent
@src/mcpp/server/tool_registry.h (lines 77-126) — ToolAnnotations pattern for metadata
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content.h with rich content types</name>
  <files>src/mcpp/content/content.h</files>
  <action>
Create new header file src/mcpp/content/content.h with:

1. Annotations struct (lines 1-50):
   - std::optional<std::vector<std::string>> audience (Role array: user, assistant, system)
   - std::optional<double> priority (0-1, lower = higher priority)
   - std::optional<std::string> lastModified (ISO 8601 timestamp string)
   - Default constructor
   - Optional: Constructor with values for convenience

2. ImageContent struct (lines 52-65):
   - std::string type = "image"
   - std::string data (base64-encoded image bytes)
   - std::string mimeType (e.g., "image/png", "image/jpeg", "image/gif", "image/webp")
   - std::optional<Annotations> annotations

3. AudioContent struct (lines 67-80):
   - std::string type = "audio"
   - std::string data (base64-encoded audio bytes)
   - std::string mimeType (e.g., "audio/mp3", "audio/wav", "audio/ogg")
   - std::optional<Annotations> annotations

4. ResourceLink struct (lines 82-93):
   - std::string type = "resource"
   - std::string uri (URI referencing the resource)
   - std::optional<Annotations> annotations

5. EmbeddedResource struct (lines 95-108):
   - std::string type = "embedded"
   - ResourceContent resource (reuse from resource_registry.h: uri, optional mime_type, is_text flag, text/blob fields)
   - std::optional<Annotations> annotations

6. Forward declare ResourceContent before EmbeddedResource (include forward reference or minimal definition)

7. Use mcpp::content namespace

8. Follow existing header style from sampling.h (license header, include guards, doxygen comments)

NOTE: Base64 encoding/decoding is CALLER's responsibility - the data field stores pre-encoded base64 strings.
  </action>
  <verify>grep -E "struct (ImageContent|AudioContent|ResourceLink|EmbeddedResource|Annotations)" src/mcpp/content/content.h</verify>
  <done>All five content types defined with correct fields per MCP 2025-11-25 schema</done>
</task>

<task type="auto">
  <name>Task 2: Implement JSON conversion functions in content.cpp</name>
  <files>src/mcpp/content/content.cpp</files>
  <action>
Create new implementation file src/mcpp/content/content.cpp with:

1. Include content.h and nlohmann/json.hpp

2. annotations_to_json(const Annotations& a) function:
   - Returns nlohmann::json object
   - Include audience if present (array of strings)
   - Include priority if present (double)
   - Include lastModified if present (string)

3. annotations_from_json(const nlohmann::json& j) function:
   - Returns std::optional<Annotations>
   - Parse audience if present (must be array of strings)
   - Parse priority if present (must be number 0-1)
   - Parse lastModified if present (must be string)
   - Return nullopt if required fields missing or invalid

4. content_to_json(const ContentBlock& content) function:
   - Use std::visit pattern like in sampling.h (lines 386-407)
   - Handle all five content types: TextContent, ImageContent, AudioContent, ResourceLink, EmbeddedResource
   - Each content type outputs: type field, type-specific fields, optional annotations
   - For EmbeddedResource: include uri, mime_type, and text OR blob based on is_text flag

5. content_from_json(const nlohmann::json& j) function:
   - Check for "type" field (string required)
   - Parse based on type value: "text", "image", "audio", "resource", "embedded"
   - For each type: validate required fields, parse optional fields
   - Return std::optional<ContentBlock> (nullopt if parsing fails)
   - Include annotations parsing for each type if present

6. Wrap in namespace mcpp::content

Follow existing implementation patterns from sampling.h content conversion functions.
  </action>
  <verify>grep -E "(content_to_json|content_from_json|annotations_to_json)" src/mcpp/content/content.cpp | wc -l</verify>
  <done>All conversion functions implemented with proper std::visit and optional handling</done>
</task>

<task type="auto">
  <name>Task 3: Extend ContentBlock in sampling.h and update public headers</name>
  <files>src/mcpp/client/sampling.h</files>
  <action>
Modify src/mcpp/client/sampling.h:

1. Add include for new content.h after nlohmann/json.hpp:
   #include "mcpp/content/content.h"

2. Update ContentBlock variant (around line 86):
   - Current: using ContentBlock = std::variant<TextContent, ToolUseContent, ToolResultContent>;
   - New: using ContentBlock = std::variant<TextContent, ImageContent, AudioContent, ResourceLink, EmbeddedResource, ToolUseContent, ToolResultContent>;
   - NOTE: Tool-related types (ToolUseContent, ToolResultContent) remain for sampling client use

3. Update content_to_json function (lines 386-407) to handle new types:
   - Add cases for ImageContent (data, mimeType fields)
   - Add cases for AudioContent (data, mimeType fields)
   - Add cases for ResourceLink (uri field)
   - Add cases for EmbeddedResource (resource with uri, mime_type, text/blob)

4. Update content_from_json function (lines 414-458) to handle new types:
   - Add "image" type parsing (data, mimeType required, annotations optional)
   - Add "audio" type parsing (data, mimeType required, annotations optional)
   - Add "resource" type parsing (uri required, annotations optional)
   - Add "embedded" type parsing (resource with uri, mime_type, text/blob)

5. Update include/mcpp/public_headers.h to add content/content.h to MCPP_PUBLIC_HEADERS list

Build verification: The library should compile without errors after these changes.
  </action>
  <verify>grep -E "ImageContent|AudioContent|ResourceLink|EmbeddedResource" src/mcpp/client/sampling.h && grep "content/content.h" include/mcpp/public_headers.h</verify>
  <done>ContentBlock variant includes all five content types; public headers updated for export</done>
</task>

</tasks>

<verification>
After plan completion:

1. Content types compile correctly: Build library with `cmake --build build`
2. All content types are properly exported in public headers
3. ContentBlock variant order preserves backward compatibility (text first, then new types, then tool types)
4. JSON conversion handles all five content types with annotations
5. Tool-related content types (ToolUseContent, ToolResultContent) still work for sampling
</verification>

<success_criteria>
1. New src/mcpp/content/content.h defines all five content types with annotations
2. src/mcpp/content/content.cpp implements serialization/deserialization
3. sampling.h ContentBlock variant includes ImageContent, AudioContent, ResourceLink, EmbeddedResource
4. content_to_json/content_from_json handle all types
5. Library compiles without errors
6. Public headers list includes content/content.h
</success_criteria>

<output>
After completion, create `.planning/phases/05-content---tasks/05-01-SUMMARY.md`
</output>

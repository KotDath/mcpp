---
phase: 05-content---tasks
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/content/pagination.h
  - src/mcpp/server/tool_registry.h
  - src/mcpp/server/tool_registry.cpp
  - src/mcpp/server/resource_registry.h
  - src/mcpp/server/resource_registry.cpp
  - src/mcpp/server/prompt_registry.h
  - src/mcpp/server/prompt_registry.cpp
autonomous: true

must_haves:
  truths:
    - "Developer can paginate list results with cursor-based pagination"
    - "Developer can get nextCursor for continuation when more results exist"
    - "Developer can check has_more() to determine if more pages exist"
    - "Tools list supports pagination via list_tools_paginated(cursor)"
    - "Resources list supports pagination via list_resources_paginated(cursor)"
    - "Prompts list supports pagination via list_prompts_paginated(cursor)"
    - "Original non-paginated list methods still work for backward compatibility"
  artifacts:
    - path: "src/mcpp/content/pagination.h"
      provides: "PaginatedResult template with nextCursor and has_more()"
      contains: "template.*struct PaginatedResult", "bool has_more"
    - path: "src/mcpp/server/tool_registry.h"
      provides: "Paginated tool listing method"
      contains: "list_tools_paginated"
    - path: "src/mcpp/server/resource_registry.h"
      provides: "Paginated resource listing method"
      contains: "list_resources_paginated"
    - path: "src/mcpp/server/prompt_registry.h"
      provides: "Paginated prompt listing method"
      contains: "list_prompts_paginated"
  key_links:
    - from: "src/mcpp/content/pagination.h"
      to: "src/mcpp/server/tool_registry.h"
      via: "include"
      pattern: "#include \"mcpp/content/pagination.h\""
    - from: "src/mcpp/content/pagination.h"
      to: "src/mcpp/server/resource_registry.h"
      via: "include"
      pattern: "#include \"mcpp/content/pagination.h\""
    - from: "src/mcpp/content/pagination.h"
      to: "src/mcpp/server/prompt_registry.h"
      via: "include"
      pattern: "#include \"mcpp/content/pagination.h\""
---

<objective>
Implement cursor-based pagination for all registry list operations (tools, resources, prompts) following MCP 2025-11-25 spec.

Purpose: Large registries need pagination to avoid overwhelming responses. Opaque cursor-based pagination allows servers to control page size and encoding.

Output: PaginatedResult template, paginated list methods in all three registries, backward-compatible non-paginated methods.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-content---tasks/05-RESEARCH.md

# Existing registry patterns
@src/mcpp/server/tool_registry.h (lines 238) — list_tools() method signature
@src/mcpp/server/resource_registry.h (lines 294) — list_resources() method signature
@src/mcpp/server/prompt_registry.h (lines 172) — list_prompts() method signature
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pagination.h with PaginatedResult template</name>
  <files>src/mcpp/content/pagination.h</files>
  <action>
Create new header file src/mcpp/content/pagination.h with:

1. Include guards and license header matching project style

2. Includes:
   - #include <vector>
   - #include <optional>
   - #include <string>
   - #include <cstdint>

3. PaginatedResult<T> template struct (lines 30-55):
   ```cpp
   namespace mcpp::content {

   template<typename T>
   struct PaginatedResult {
       /// Items in this page
       std::vector<T> items;

       /// Opaque cursor for next page (present if more results exist)
       std::optional<std::string> nextCursor;

       /// Optional total count across all pages
       std::optional<uint64_t> total;

       /// Check if more pages exist
       bool has_more() const noexcept { return nextCursor.has_value(); }

       /// Default constructor
       PaginatedResult() = default;

       /// Constructor with items only (no more pages)
       PaginatedResult(std::vector<T> items) : items(std::move(items)) {}

       /// Full constructor
       PaginatedResult(std::vector<T> items,
                      std::optional<std::string> cursor,
                      std::optional<uint64_t> total = std::nullopt)
           : items(std::move(items)),
             nextCursor(std::move(cursor)),
             total(std::move(total)) {}
   };

   } // namespace mcpp::content
   ```

4. Inline implementation in header (header-only template)

5. Add to include/mcpp/public_headers.h in MCPP_PUBLIC_HEADERS list
  </action>
  <verify>grep -E "PaginatedResult|has_more" src/mcpp/content/pagination.h</verify>
  <done>PaginatedResult template defined with items, nextCursor, total, and has_more() method</done>
</task>

<task type="auto">
  <name>Task 2: Add pagination to ToolRegistry</name>
  <files>src/mcpp/server/tool_registry.h src/mcpp/server/tool_registry.cpp</files>
  <action>
Modify tool_registry.h:

1. Add include after existing includes:
   #include "mcpp/content/pagination.h"

2. Add new public method declaration after list_tools() (around line 240):
   ```cpp
   /**
    * @brief List all registered tools with pagination
    *
    * Returns paginated results with cursor-based navigation.
    * The cursor is an opaque token; clients should not interpret its contents.
    *
    * @param cursor Optional cursor from previous page for continuation
    * @return PaginatedResult containing tool metadata and optional next cursor
    */
   PaginatedResult<nlohmann::json> list_tools_paginated(
       const std::optional<std::string>& cursor = std::nullopt
   ) const;
   ```

Modify tool_registry.cpp:

3. Implement list_tools_paginated():
   ```cpp
   PaginatedResult<nlohmann::json> ToolRegistry::list_tools_paginated(
       const std::optional<std::string>& cursor
   ) const {
       constexpr size_t PAGE_SIZE = 50;  // Server-determined page size

       // Decode cursor (offset-based encoding)
       size_t start_index = 0;
       if (cursor.has_value()) {
           try {
               start_index = std::stoull(*cursor);
           } catch (...) {
               // Invalid cursor - start from beginning
               start_index = 0;
           }
       }

       PaginatedResult<nlohmann::json> result;
       size_t count = 0;

       // Iterate through tools (unordered_map iteration order is stable within single run)
       for (const auto& [name, registration] : tools_) {
           if (count++ < start_index) continue;
           if (result.items.size() >= PAGE_SIZE) {
               // More results exist
               result.nextCursor = std::to_string(start_index + PAGE_SIZE);
               break;
           }
           result.items.push_back(tool_to_json(registration));
       }

       result.total = tools_.size();
       return result;
   }
   ```

4. The existing list_tools() method remains unchanged for backward compatibility

Note: tool_to_json is the existing pattern for converting ToolRegistration to JSON (needs to be implemented if not already present).
  </action>
  <verify>grep -E "list_tools_paginated" src/mcpp/server/tool_registry.h src/mcpp/server/tool_registry.cpp</verify>
  <done>ToolRegistry has list_tools_paginated method with offset-based cursor encoding</done>
</task>

<task type="auto">
  <name>Task 3: Add pagination to ResourceRegistry</name>
  <files>src/mcpp/server/resource_registry.h src/mcpp/server/resource_registry.cpp</files>
  <action>
Modify resource_registry.h:

1. Add include after existing includes:
   #include "mcpp/content/pagination.h"

2. Add new public method declaration after list_resources() (around line 295):
   ```cpp
   /**
    * @brief List all registered resources with pagination
    *
    * Returns paginated results for both regular and template resources.
    * The cursor is an opaque token; clients should not interpret its contents.
    *
    * @param cursor Optional cursor from previous page for continuation
    * @return PaginatedResult containing resource metadata and optional next cursor
    */
   PaginatedResult<nlohmann::json> list_resources_paginated(
       const std::optional<std::string>& cursor = std::nullopt
   ) const;
   ```

Modify resource_registry.cpp:

3. Implement list_resources_paginated():
   - Similar pattern to ToolRegistry
   - Combine both resources_ and template_resources_ into a single paginated result
   - Use PAGE_SIZE = 50
   - Offset-based cursor encoding
   - Return resource JSON objects with "template" field for template resources

4. Helper method to build JSON from ResourceRegistration (if not already exists)

5. The existing list_resources() method remains unchanged for backward compatibility
  </action>
  <verify>grep -E "list_resources_paginated" src/mcpp/server/resource_registry.h src/mcpp/server/resource_registry.cpp</verify>
  <done>ResourceRegistry has list_resources_paginated method handling both regular and template resources</done>
</task>

<task type="auto">
  <name>Task 4: Add pagination to PromptRegistry</name>
  <files>src/mcpp/server/prompt_registry.h src/mcpp/server/prompt_registry.cpp</files>
  <action>
Modify prompt_registry.h:

1. Add include after existing includes:
   #include "mcpp/content/pagination.h"

2. Add new public method declaration after list_prompts() (around line 173):
   ```cpp
   /**
    * @brief List all registered prompts with pagination
    *
    * Returns paginated results with cursor-based navigation.
    * The cursor is an opaque token; clients should not interpret its contents.
    *
    * @param cursor Optional cursor from previous page for continuation
    * @return PaginatedResult containing prompt metadata and optional next cursor
    */
   PaginatedResult<nlohmann::json> list_prompts_paginated(
       const std::optional<std::string>& cursor = std::nullopt
   ) const;
   ```

Modify prompt_registry.cpp:

3. Implement list_prompts_paginated():
   - Similar pattern to ToolRegistry
   - Use PAGE_SIZE = 50
   - Offset-based cursor encoding
   - Return prompt JSON objects with name, optional description, arguments

4. The existing list_prompts() method remains unchanged for backward compatibility
  </action>
  <verify>grep -E "list_prompts_paginated" src/mcpp/server/prompt_registry.h src/mcpp/server/prompt_registry.cpp</verify>
  <done>PromptRegistry has list_prompts_paginated method with offset-based cursor encoding</done>
</task>

</tasks>

<verification>
After plan completion:

1. All three registries have both list_*() and list_*_paginated() methods
2. Original non-paginated methods still work (backward compatibility)
3. Paginated methods return PaginatedResult with items and optional nextCursor
4. Cursor encoding is offset-based (simple string representation of integer)
5. PAGE_SIZE is consistently 50 across all registries
6. Library compiles without errors
</verification>

<success_criteria>
1. pagination.h defines PaginatedResult template
2. ToolRegistry::list_tools_paginated() exists and works
3. ResourceRegistry::list_resources_paginated() exists and works
4. PromptRegistry::list_prompts_paginated() exists and works
5. Original list_*() methods unchanged for backward compatibility
6. All methods compile and link correctly
</success_criteria>

<output>
After completion, create `.planning/phases/05-content---tasks/05-02-SUMMARY.md`
</output>

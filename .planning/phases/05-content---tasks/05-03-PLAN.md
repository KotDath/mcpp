---
phase: 05-content---tasks
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/server/tool_registry.h
  - src/mcpp/server/tool_registry.cpp
  - src/mcpp/server/resource_registry.h
  - src/mcpp/server/resource_registry.cpp
  - src/mcpp/server/prompt_registry.h
  - src/mcpp/server/prompt_registry.cpp
  - src/mcpp/server/mcp_server.h
  - src/mcpp/server/mcp_server.cpp
autonomous: true

must_haves:
  truths:
    - "Registry sends list_changed notification when items are added/removed"
    - "Developer can set callback for sending notifications via set_notify_callback()"
    - "Registry calls notify callback after register_* operations"
    - "Registry provides notify_changed() method for manual notification"
    - "McpServer routes list_changed notifications to transport"
    - "Notifications only sent when client capability is enabled"
  artifacts:
    - path: "src/mcpp/server/tool_registry.h"
      provides: "List changed notification support for tools"
      contains: "set_notify_callback", "notify_changed", "NotifyCallback"
    - path: "src/mcpp/server/resource_registry.h"
      provides: "List changed notification support for resources"
      contains: "set_notify_callback", "notify_changed", "NotifyCallback"
    - path: "src/mcpp/server/prompt_registry.h"
      provides: "List changed notification support for prompts"
      contains: "set_notify_callback", "notify_changed", "NotifyCallback"
    - path: "src/mcpp/server/mcp_server.h"
      provides: "Client capabilities storage and notification handler methods"
      contains: "client_capabilities_", "setup_registry_callbacks", "send_list_changed_notification"
    - path: "src/mcpp/server/mcp_server.cpp"
      provides: "Notification routing implementation with capability checks"
      contains: "setup_registry_callbacks", "tools\\.listChanged|resources\\.listChanged|prompts\\.listChanged"
  key_links:
    - from: "src/mcpp/server/tool_registry.h"
      to: "src/mcpp/client/roots.h"
      via: "pattern following"
      pattern: "using NotifyCallback.*std::function<void"
    - from: "src/mcpp/server/mcp_server.h"
      to: "registries"
      via: "set_notify_callback calls in setup_registry_callbacks"
      pattern: "set_notify_callback"
    - from: "src/mcpp/server/mcp_server.cpp"
      to: "transport_"
      via: "send_notification in notification callbacks"
      pattern: "send_list_changed_notification"
---

<objective>
Implement list_changed notifications for tools, resources, and prompts registries following the RootsManager callback pattern, with McpServer routing notifications to transport only when client capabilities indicate support.

Purpose: Clients need to know when registry contents change to refresh caches and UI. Mutual opt-in via capability negotiation and callbacks ensures notifications are only sent when supported.

Output: All three registries support notification callbacks, McpServer stores client capabilities, sets up registry callbacks, and sends notifications only when client capability is enabled.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-content---tasks/05-RESEARCH.md

# Pattern to follow
@src/mcpp/client/roots.h (lines 129-202) — RootsManager with NotifyCallback pattern
@src/mcpp/protocol/capabilities.h (lines 77-98) — ToolCapability, ResourceCapability, PromptCapability with listChanged
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add notification support to ToolRegistry</name>
  <files>src/mcpp/server/tool_registry.h src/mcpp/server/tool_registry.cpp</files>
  <action>
Modify tool_registry.h:

1. Add public typedef after ToolHandler (around line 82):
   ```cpp
   /**
    * @brief Callback type for list_changed notifications
    *
    * Invoked when the registry contents change (tools added/removed).
    */
   using NotifyCallback = std::function<void()>;
   ```

2. Add public methods after call_tool() (around line 257):
   ```cpp
   /**
    * @brief Set the callback for sending list_changed notifications
    *
    * The callback will be invoked when notify_changed() is called.
    * Typically used to send notifications/tools/list_changed to clients.
    *
    * @param cb Callback function (empty function to clear)
    */
   void set_notify_callback(NotifyCallback cb);

   /**
    * @brief Send tools/list_changed notification
    *
    * If a notify callback is registered, invokes it to send the notification.
    * Call this after registering/unregistering tools to notify clients.
    */
   void notify_changed();
   ```

3. Add private member after tools_ (line 287):
   ```cpp
   /// Callback for sending list_changed notifications
   NotifyCallback notify_cb_;
   ```

Modify tool_registry.cpp:

4. Implement set_notify_callback():
   ```cpp
   void ToolRegistry::set_notify_callback(NotifyCallback cb) {
       notify_cb_ = std::move(cb);
   }
   ```

5. Implement notify_changed():
   ```cpp
   void ToolRegistry::notify_changed() {
       if (notify_cb_) {
           notify_cb_();
       }
   }
   ```

6. Update register_tool() implementations to call notify_changed():
   - After successful registration in both overloaded methods
   - Add: notify_changed(); after return true lines (before return)
   - Use separate variable to track success, call notify_changed() before returning

Example pattern:
   ```cpp
   bool result = tools_.emplace(...).second;
   if (result) {
       notify_changed();
   }
   return result;
   ```
  </action>
  <verify>grep -E "(set_notify_callback|notify_changed|notify_cb_)" src/mcpp/server/tool_registry.h src/mcpp/server/tool_registry.cpp</verify>
  <done>ToolRegistry has notification support with callback pattern and automatic notification on register</done>
</task>

<task type="auto">
  <name>Task 2: Add notification support to ResourceRegistry</name>
  <files>src/mcpp/server/resource_registry.h src/mcpp/server/resource_registry.cpp</files>
  <action>
Modify resource_registry.h:

1. Add public typedef after TemplateResourceHandler (around line 150):
   ```cpp
   /**
    * @brief Callback type for list_changed notifications
    *
    * Invoked when the registry contents change (resources added/removed).
    */
   using NotifyCallback = std::function<void()>;
   ```

2. Add public methods after get_completion() (around line 425):
   ```cpp
   /**
    * @brief Set the callback for sending list_changed notifications
    *
    * The callback will be invoked when notify_changed() is called.
    * Typically used to send notifications/resources/list_changed to clients.
    *
    * @param cb Callback function (empty function to clear)
    */
   void set_notify_callback(NotifyCallback cb);

   /**
    * @brief Send resources/list_changed notification
    *
    * If a notify callback is registered, invokes it to send the notification.
    * Call this after registering/unregistering resources to notify clients.
    */
   void notify_changed();
   ```

3. Add private member after completion_handlers_ (line 451):
   ```cpp
   /// Callback for sending list_changed notifications
   NotifyCallback notify_cb_;
   ```

Modify resource_registry.cpp:

4. Implement set_notify_callback() and notify_changed() following same pattern as ToolRegistry

5. Update register_resource() and register_template() to call notify_changed() after successful registration

6. Note: ResourceRegistry already has a different notify mechanism for resource updates (notify_updated for subscriptions) - keep that separate
  </action>
  <verify>grep -E "(set_notify_callback|notify_changed|notify_cb_)" src/mcpp/server/resource_registry.h src/mcpp/server/resource_registry.cpp</verify>
  <done>ResourceRegistry has notification support, separate from existing subscription notification</done>
</task>

<task type="auto">
  <name>Task 3: Add notification support to PromptRegistry</name>
  <files>src/mcpp/server/prompt_registry.h src/mcpp/server/prompt_registry.cpp</files>
  <action>
Modify prompt_registry.h:

1. Add public typedef after CompletionHandler (around line 74):
   ```cpp
   /**
    * @brief Callback type for list_changed notifications
    *
    * Invoked when the registry contents change (prompts added/removed).
    */
   using NotifyCallback = std::function<void()>;
   ```

2. Add public methods after get_completion() (around line 230):
   ```cpp
   /**
    * @brief Set the callback for sending list_changed notifications
    *
    * The callback will be invoked when notify_changed() is called.
    * Typically used to send notifications/prompts/list_changed to clients.
    *
    * @param cb Callback function (empty function to clear)
    */
   void set_notify_callback(NotifyCallback cb);

   /**
    * @brief Send prompts/list_changed notification
    *
    * If a notify callback is registered, invokes it to send the notification.
    * Call this after registering/unregistering prompts to notify clients.
    */
   void notify_changed();
   ```

3. Add private member after completion_handlers_ (line 236):
   ```cpp
   /// Callback for sending list_changed notifications
   NotifyCallback notify_cb_;
   ```

Modify prompt_registry.cpp:

4. Implement set_notify_callback() and notify_changed() following same pattern as ToolRegistry

5. Update register_prompt() to call notify_changed() after successful registration
  </action>
  <verify>grep -E "(set_notify_callback|notify_changed|notify_cb_)" src/mcpp/server/prompt_registry.h src/mcpp/server/prompt_registry.cpp</verify>
  <done>PromptRegistry has notification support with callback pattern</done>
</task>

<task type="auto">
  <name>Task 4: Add client capabilities storage and callback setup to McpServer</name>
  <files>src/mcpp/server/mcp_server.h src/mcpp/server/mcp_server.cpp</files>
  <action>
Modify mcp_server.h:

1. Add include for protocol capabilities after existing includes (around line 33):
   ```cpp
   #include "mcpp/protocol/capabilities.h"
   ```

2. Add private member after transport_ (around line 305):
   ```cpp
   /// Client capabilities from initialize (for feature detection)
   std::optional<protocol::ClientCapabilities> client_capabilities_;
   ```

3. Add private helper method declaration after extract_progress_token() (around line 300):
   ```cpp
   /**
    * @brief Set up registry notification callbacks
    *
    * Wires up list_changed notifications from each registry to transport.
    * Callbacks check client capabilities before sending notifications.
    */
   void setup_registry_callbacks();
   ```

4. Add private helper method for sending notifications (after setup_registry_callbacks):
   ```cpp
   /**
    * @brief Send list_changed notification for a given registry type
    *
    * Sends the notification if transport is available and client capability is enabled.
    *
    * @param method Notification method (e.g., "notifications/tools/list_changed")
    */
   void send_list_changed_notification(const std::string& method);
   ```

Modify mcp_server.cpp:

5. Update handle_initialize() to store client capabilities:
   - Extract capabilities from params["capabilities"]
   - Parse into protocol::ClientCapabilities struct
   - Store in client_capabilities_ member
   - After storing, call setup_registry_callbacks()

6. Implement setup_registry_callbacks():
   ```cpp
   void McpServer::setup_registry_callbacks() {
       // Set up tools list_changed callback
       tools_.set_notify_callback([this]() {
           if (client_capabilities_ &&
               client_capabilities_->experimental &&
               client_capabilities_->experimental.value().contains("tools")) {
               auto tools_cap = client_capabilities_->experimental.value()["tools"];
               if (tools_cap.contains("listChanged") && tools_cap["listChanged"].get<bool>()) {
                   send_list_changed_notification("notifications/tools/list_changed");
               }
           }
       });

       // Set up resources list_changed callback
       resources_.set_notify_callback([this]() {
           if (client_capabilities_ &&
               client_capabilities_->experimental &&
               client_capabilities_->experimental.value().contains("resources")) {
               auto res_cap = client_capabilities_->experimental.value()["resources"];
               if (res_cap.contains("listChanged") && res_cap["listChanged"].get<bool>()) {
                   send_list_changed_notification("notifications/resources/list_changed");
               }
           }
       });

       // Set up prompts list_changed callback
       prompts_.set_notify_callback([this]() {
           if (client_capabilities_ &&
               client_capabilities_->experimental &&
               client_capabilities_->experimental.value().contains("prompts")) {
               auto prompts_cap = client_capabilities_->experimental.value()["prompts"];
               if (prompts_cap.contains("listChanged") && prompts_cap["listChanged"].get<bool>()) {
                   send_list_changed_notification("notifications/prompts/list_changed");
               }
           }
       });
   }
   ```

7. Implement send_list_changed_notification():
   ```cpp
   void McpServer::send_list_changed_notification(const std::string& method) {
       if (!transport_.has_value()) {
           return;  // No transport - cannot send notification
       }

       nlohmann::json notification = {
           {"jsonrpc", "2.0"},
           {"method", method},
           {"params", nlohmann::json::object()}
       };

       (*transport_)->send_notification(notification);
   }
   ```

Note: The capability check pattern follows the MCP spec where listChanged is nested under experimental for each registry type.
  </action>
  <verify>grep -E "(client_capabilities_|setup_registry_callbacks|send_list_changed_notification)" src/mcpp/server/mcp_server.h src/mcpp/server/mcp_server.cpp</verify>
  <done>McpServer stores client capabilities and sets up registry callbacks with capability checks</done>
</task>

</tasks>

<verification>
After plan completion:

1. All three registries have NotifyCallback typedef
2. All three registries have set_notify_callback() and notify_changed() methods
3. Each registry calls notify_changed() after successful registration
4. notify_changed() only invokes callback if one is set (no-op otherwise)
5. Pattern matches RootsManager implementation for consistency
6. McpServer stores client_capabilities_ member
7. McpServer calls setup_registry_callbacks() during initialize
8. Registry callbacks check client capabilities before sending notifications
9. send_list_changed_notification() only sends when transport is available
10. Notifications use correct method names (notifications/tools/list_changed, etc.)
</verification>

<success_criteria>
1. ToolRegistry notification support implemented
2. ResourceRegistry notification support implemented
3. PromptRegistry notification support implemented
4. All registries follow the same callback pattern
5. Automatic notification on successful registration
6. McpServer stores and uses client capabilities for notification gating
7. McpServer wires registry callbacks to transport
8. Notifications only sent when client capability is enabled
9. Library compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-content---tasks/05-03-SUMMARY.md`
</output>

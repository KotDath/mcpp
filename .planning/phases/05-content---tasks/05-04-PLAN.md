---
phase: 05-content---tasks
plan: 04
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/mcpp/server/task_manager.h
  - src/mcpp/server/task_manager.cpp
  - src/mcpp/protocol/capabilities.h
  - src/mcpp/server/mcp_server.h
  - src/mcpp/server/mcp_server.cpp
  - include/mcpp/public_headers.h
autonomous: true

must_haves:
  truths:
    - "Developer can create tasks with unique IDs and optional TTL"
    - "Developer can update task status (working, input_required, completed, failed, cancelled)"
    - "Developer can set/get task results for completed tasks"
    - "Developer can list tasks with pagination support"
    - "TaskManager cleans up expired tasks via cleanup_expired()"
    - "McpServer routes tasks/send, tasks/get, tasks/cancel, tasks/result requests"
    - "Server advertises tasks experimental capability"
    - "Tasks state transitions are validated (terminal states cannot transition)"
  artifacts:
    - path: "src/mcpp/server/task_manager.h"
      provides: "Task lifecycle management with polling and TTL"
      contains: "class TaskManager", "enum class TaskStatus", "struct Task"
    - path: "src/mcpp/protocol/capabilities.h"
      provides: "TasksCapability for experimental tasks API"
      contains: "struct TasksCapability"
    - path: "src/mcpp/server/mcp_server.h"
      provides: "Task request routing"
      contains: "handle_tasks_send", "handle_tasks_get", "handle_tasks_cancel", "handle_tasks_result"
  key_links:
    - from: "src/mcpp/server/mcp_server.h"
      to: "src/mcpp/server/task_manager.h"
      via: "member variable"
      pattern: "TaskManager task_manager_"
    - from: "src/mcpp/server/mcp_server.cpp"
      to: "task_manager_"
      via: "method calls"
      pattern: "task_manager_\\.(create_task|get_task|cancel_task)"
---

<objective>
Implement experimental task lifecycle management with TaskManager for long-running operations following MCP 2025-11-25 tasks spec.

Purpose: Tools and resources may need long-running execution. Tasks API provides polling-based result retrieval with status updates and TTL management.

Output: TaskManager class with CRUD operations, task status enum, JSON-RPC handlers in McpServer, TasksCapability in protocol types.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-content---tasks/05-RESEARCH.md

# Existing patterns
@src/mcpp/server/tool_registry.h — Registry pattern with unordered_map storage
@src/mcpp/server/request_context.h — Progress token and context pattern
@src/mcpp/protocol/capabilities.h — Capability pattern for experimental features
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create task_manager.h with Task types and TaskManager class</name>
  <files>src/mcpp/server/task_manager.h</files>
  <action>
Create new header file src/mcpp/server/task_manager.h with:

1. Include guards and license header matching project style

2. Includes:
   - #include <chrono>
   - #include <functional>
   - #include <mutex>
   - #include <optional>
   - #include <string>
   - #include <unordered_map>
   - #include <vector>
   - #include <nlohmann/json.hpp>

3. TaskStatus enum (lines 35-45):
   ```cpp
   enum class TaskStatus {
       Working,        ///< Task is currently executing
       InputRequired,  ///< Task needs user input to proceed
       Completed,      ///< Task completed successfully
       Failed,         ///< Task failed
       Cancelled       ///< Task was cancelled
   };
   ```

4. Task struct (lines 47-70):
   ```cpp
   struct Task {
       std::string task_id;                          ///< Unique task identifier
       TaskStatus status;                            ///< Current status
       std::optional<std::string> status_message;    ///< Optional human-readable status
       std::string created_at;                       ///< ISO 8601 creation timestamp
       std::string last_updated_at;                  ///< ISO 8601 last update timestamp
       std::optional<uint64_t> ttl_ms;               ///< TTL in milliseconds (null = unlimited)
       std::optional<uint64_t> poll_interval_ms;     ///< Suggested poll interval for clients

       /// Constructor with current timestamp
       Task(std::string id, TaskStatus s, std::optional<uint64_t> ttl = std::nullopt);
   };
   ```

5. TaskManager class (lines 72-180):
   ```cpp
   class TaskManager {
   public:
       TaskManager() = default;
       ~TaskManager() = default;

       // Non-copyable, non-movable
       TaskManager(const TaskManager&) = delete;
       TaskManager& operator=(const TaskManager&) = delete;
       TaskManager(TaskManager&&) = delete;
       TaskManager& operator=(TaskManager&&) = delete;

       /**
        * @brief Create a new task
        *
        * Generates a unique task ID and creates a task in "working" status.
        *
        * @param ttl_ms Optional TTL in milliseconds (0 = unlimited)
        * @param poll_interval_ms Optional suggested poll interval
        * @return New task ID
        */
       std::string create_task(
           std::optional<uint64_t> ttl_ms = std::nullopt,
           std::optional<uint64_t> poll_interval_ms = std::nullopt
       );

       /**
        * @brief Get task metadata by ID
        *
        * @param task_id Task identifier
        * @return Task metadata, or nullopt if not found
        */
       std::optional<Task> get_task(const std::string& task_id) const;

       /**
        * @brief Update task status
        *
        * Validates state transitions. Terminal states (Completed, Failed, Cancelled)
        * cannot transition to other states.
        *
        * @param task_id Task identifier
        * @param status New status
        * @param message Optional status message
        * @return true if update succeeded, false if invalid transition or task not found
        */
       bool update_status(
           const std::string& task_id,
           TaskStatus status,
           const std::optional<std::string>& message = std::nullopt
       );

       /**
        * @brief Set the result for a completed task
        *
        * @param task_id Task identifier
        * @param result Task result as JSON
        * @return true if set successfully, false if task not found
        */
       bool set_result(const std::string& task_id, const nlohmann::json& result);

       /**
        * @brief Get the result for a completed task
        *
        * @param task_id Task identifier
        * @return Task result, or nullopt if not found or no result set
        */
       std::optional<nlohmann::json> get_result(const std::string& task_id) const;

       /**
        * @brief Cancel a task
        *
        * Transitions task to Cancelled status if not already terminal.
        *
        * @param task_id Task identifier
        * @return true if cancelled, false if not found or already terminal
        */
       bool cancel_task(const std::string& task_id);

       /**
        * @brief Delete a task
        *
        * Removes task from storage. Use for cleanup.
        *
        * @param task_id Task identifier
        * @return true if deleted, false if not found
        */
       bool delete_task(const std::string& task_id);

       /**
        * @brief List tasks with pagination
        *
        * @param cursor Optional pagination cursor
        * @return Paginated result of tasks
        */
       template<typename T>
       struct PaginatedResult {
           std::vector<T> items;
           std::optional<std::string> nextCursor;
           bool has_more() const noexcept { return nextCursor.has_value(); }
       };

       PaginatedResult<Task> list_tasks(
           const std::optional<std::string>& cursor = std::nullopt
       ) const;

       /**
        * @brief Clean up expired tasks
        *
        * Removes tasks whose TTL has expired. Should be called periodically.
        *
        * @return Number of tasks cleaned up
        */
       size_t cleanup_expired();

   private:
       /// Generate a unique task ID (UUID-like format)
       std::string generate_task_id() const;

       /// Get current ISO 8601 timestamp
       static std::string get_timestamp();

       /// Check if task has expired based on TTL
       bool is_expired(const Task& task) const;

       /// Tasks storage
       std::unordered_map<std::string, Task> tasks_;

       /// Task results storage
       std::unordered_map<std::string, nlohmann::json> results_;

       /// Mutex for thread-safe access
       mutable std::mutex mutex_;
   };
   ```

6. Helper function to convert TaskStatus to string:
   ```cpp
   inline const char* to_string(TaskStatus status) {
       switch (status) {
           case TaskStatus::Working: return "working";
           case TaskStatus::InputRequired: return "input_required";
           case TaskStatus::Completed: return "completed";
           case TaskStatus::Failed: return "failed";
           case TaskStatus::Cancelled: return "cancelled";
       }
       return "unknown";
   }
   ```

7. Include pagination.h header or define PaginatedResult inline (to avoid circular dependency, define inline in this header)

8. Wrap in namespace mcpp::server
  </action>
  <verify>grep -E "(TaskStatus|TaskManager|create_task|update_status|set_result)" src/mcpp/server/task_manager.h</verify>
  <done>task_manager.h defines TaskStatus enum, Task struct, and TaskManager class with all CRUD operations</done>
</task>

<task type="auto">
  <name>Task 2: Implement TaskManager in task_manager.cpp</name>
  <files>src/mcpp/server/task_manager.cpp</files>
  <action>
Create new implementation file src/mcpp/server/task_manager.cpp with:

1. Include task_manager.h and necessary headers:
   - #include <random>
   - #include <sstream>
   - #include <iomanip>
   - #include <chrono>
   - #include <algorithm>

2. Task constructor implementation:
   ```cpp
   Task::Task(std::string id, TaskStatus s, std::optional<uint64_t> ttl)
       : task_id(std::move(id)),
         status(s),
         created_at(TaskManager::get_timestamp()),
         last_updated_at(TaskManager::get_timestamp()),
         ttl_ms(ttl) {}
   ```

3. get_timestamp() static method:
   ```cpp
   std::string TaskManager::get_timestamp() {
       auto now = std::chrono::system_clock::now();
       auto time_t = std::chrono::system_clock::to_time_t(now);
       std::stringstream ss;
       ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%SZ");
       return ss.str();
   }
   ```

4. generate_task_id() method:
   ```cpp
   std::string TaskManager::generate_task_id() const {
       // Simple UUID-like format using random_device
       std::random_device rd;
       std::mt19937 gen(rd());
       std::uniform_int_distribution<> dis(0, 15);

       std::stringstream ss;
       ss << std::hex;
       for (int i = 0; i < 8; ++i) ss << dis(gen);
       ss << '-';
       for (int i = 0; i < 4; ++i) ss << dis(gen);
       ss << "-4";  // Version 4
       for (int i = 0; i < 3; ++i) ss << dis(gen);
       ss << '-';
       ss << std::uniform_int_distribution<>(8, 11)(gen);  // Variant
       for (int i = 0; i < 3; ++i) ss << dis(gen);
       ss << '-';
       for (int i = 0; i < 12; ++i) ss << dis(gen);

       return ss.str();
   }
   ```

5. create_task() implementation:
   - Generate unique ID
   - Create Task with Working status
   - Store in tasks_ map
   - Return task_id
   - Use lock_guard for mutex protection

6. get_task() implementation:
   - Lock mutex
   - Find task in map
   - Return copy or nullopt

7. update_status() implementation with state transition validation:
   ```cpp
   bool TaskManager::update_status(const std::string& id, TaskStatus new_status,
                                   const std::optional<std::string>& message) {
       std::lock_guard<std::mutex> lock(mutex_);
       auto it = tasks_.find(id);
       if (it == tasks_.end()) return false;

       Task& task = it->second;

       // Validate state transitions
       switch (task.status) {
           case TaskStatus::Working:
               // Can transition to any state
               break;
           case TaskStatus::InputRequired:
               // Can transition to any state
               break;
           case TaskStatus::Completed:
           case TaskStatus::Failed:
           case TaskStatus::Cancelled:
               // Terminal states - no transitions allowed
               return false;
       }

       task.status = new_status;
       task.last_updated_at = get_timestamp();
       if (message.has_value()) {
           task.status_message = message;
       }
       return true;
   }
   ```

8. set_result(), get_result() implementations:
   - set_result stores in results_ map
   - get_result looks up in results_ map
   - Both use mutex protection

9. cancel_task() implementation:
   - Calls update_status with Cancelled
   - Returns true if successful

10. delete_task() implementation:
   - Erases from both tasks_ and results_ maps
   - Returns true if found and erased

11. list_tasks() implementation:
   - Iterate through tasks_ map
   - Apply pagination (PAGE_SIZE = 50)
   - Return PaginatedResult

12. cleanup_expired() implementation:
   - Check each task's TTL
   - Use created_at timestamp + ttl_ms to calculate expiry
   - Remove expired tasks from both maps
   - Return count of removed tasks

13. is_expired() helper:
   - Compare current time with created_at + ttl_ms
   - If ttl_ms is nullopt, never expires
  </action>
  <verify>grep -E "(create_task|update_status|set_result|get_result|cancel_task|delete_task|list_tasks|cleanup_expired)" src/mcpp/server/task_manager.cpp | wc -l</verify>
  <done>All TaskManager methods implemented with proper mutex protection and state transition validation</done>
</task>

<task type="auto">
  <name>Task 3: Add TasksCapability and integrate TaskManager into McpServer</name>
  <files>src/mcpp/protocol/capabilities.h src/mcpp/server/mcp_server.h src/mcpp/server/mcp_server.cpp</files>
  <action>
Modify capabilities.h:

1. Forward declare TasksCapability (line 24):
   ```cpp
   struct TasksCapability;
   ```

2. Add TasksCapability to ServerCapabilities struct (after ToolCapability, around line 70):
   ```cpp
   std::optional<TasksCapability> tasks;
   ```

3. Define TasksCapability struct (after LoggingCapability, around line 144):
   ```cpp
   /**
    * Tasks capability - experimental task lifecycle management
    *
    * Corresponds to "TasksCapability" in MCP 2025-11-25 schema (experimental).
    * Indicates server supports the tasks API for long-running operations.
    */
   struct TasksCapability {
       // No fields defined in current spec - presence indicates support
   };
   ```

Modify mcp_server.h:

4. Add include after existing registry includes:
   ```cpp
   #include "mcpp/server/task_manager.h"
   ```

5. Add private handler declarations (after handle_resources_complete, around line 290):
   ```cpp
   /**
    * @brief Handle tasks/send request
    *
    * Creates a new task and returns task metadata.
    *
    * @param params Request parameters
    * @return CreateTaskResult with task metadata
    */
   nlohmann::json handle_tasks_send(const nlohmann::json& params);

   /**
    * @brief Handle tasks/get request
    *
    * Returns task status and metadata.
    *
    * @param params Request parameters containing id
    * @return Task metadata
    */
   nlohmann::json handle_tasks_get(const nlohmann::json& params);

   /**
    * @brief Handle tasks/cancel request
    *
    * Cancels a running task.
    *
    * @param params Request parameters containing id
    * @return Cancelled task metadata
    */
   nlohmann::json handle_tasks_cancel(const nlohmann::json& params);

   /**
    * @brief Handle tasks/result request
    *
    * Returns the result of a completed task.
    *
    * @param params Request parameters containing id
    * @return Task result
    */
   nlohmann::json handle_tasks_result(const nlohmann::json& params);

   /**
    * @brief Handle tasks/list request
    *
    * Lists all tasks with pagination.
    *
    * @param params Request parameters with optional cursor
    * @return Paginated list of tasks
    */
   nlohmann::json handle_tasks_list(const nlohmann::json& params);
   ```

6. Add private member after prompts_ (line 314):
   ```cpp
   /// Task manager for experimental tasks API
   TaskManager task_manager_;
   ```

7. Update handle_request() comment to include tasks methods

Modify mcp_server.cpp:

8. Add routing for tasks methods in handle_request():
   ```cpp
   if (method == "tasks/send") return handle_tasks_send(params);
   if (method == "tasks/get") return handle_tasks_get(params);
   if (method == "tasks/cancel") return handle_tasks_cancel(params);
   if (method == "tasks/result") return handle_tasks_result(params);
   if (method == "tasks/list") return handle_tasks_list(params);
   ```

9. Implement handle_tasks_send():
   - Extract optional ttl from params
   - Create task via task_manager_.create_task()
   - Return JSON with task metadata matching MCP CreateTaskResult format

10. Implement handle_tasks_get():
   - Extract id from params
   - Get task via task_manager_.get_task()
   - Return task metadata or error if not found

11. Implement handle_tasks_cancel():
   - Extract id from params
   - Cancel via task_manager_.cancel_task()
   - Return cancelled task metadata or error

12. Implement handle_tasks_result():
   - Extract id from params
   - Get result via task_manager_.get_result()
   - Return result or error if not found/complete

13. Implement handle_tasks_list():
   - Extract optional cursor from params
   - List tasks via task_manager_.list_tasks()
   - Return paginated result

14. Update handle_initialize() to include tasks capability:
   - Add "tasks": {} to experimental capabilities or as top-level capability

15. Add task_manager.h to include/mcpp/public_headers.h

Build verification: The library should compile without errors.
  </action>
  <verify>grep -E "(TasksCapability|handle_tasks_|task_manager_)" src/mcpp/protocol/capabilities.h src/mcpp/server/mcp_server.h src/mcpp/server/mcp_server.cpp</verify>
  <done>TasksCapability defined, all task handlers implemented in McpServer, task_manager_ member added</done>
</task>

</tasks>

<verification>
After plan completion:

1. TaskManager class compiles with all required methods
2. Task state transitions are validated (terminal states cannot change)
3. Task IDs are unique and UUID-like format
4. TTL tracking works with cleanup_expired()
5. McpServer routes all tasks/* requests to TaskManager
6. TasksCapability is advertised in initialize response
7. Thread-safe access via mutex protection
8. Library compiles without errors
</verification>

<success_criteria>
1. task_manager.h defines TaskStatus enum, Task struct, TaskManager class
2. task_manager.cpp implements all CRUD operations with state validation
3. capabilities.h defines TasksCapability
4. mcp_server.h has task_manager_ member and handler declarations
5. mcp_server.cpp implements all task handlers and routes requests
6. public_headers.h includes task_manager.h
7. Library compiles and links successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-content---tasks/05-04-SUMMARY.md`
</output>

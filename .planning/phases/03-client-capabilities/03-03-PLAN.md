---
phase: 03-client-capabilities
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/client/sampling.h
  - src/mcpp/client/sampling.cpp
  - src/mcpp/protocol/capabilities.h
  - src/mcpp/client.h
  - src/mcpp/client.cpp
autonomous: true

must_haves:
  truths:
    - "CreateMessageRequest captures all sampling parameters from server"
    - "CreateMessageResult contains model response with role and content"
    - "SamplingClient invokes user handler for sampling/createMessage requests"
    - "User-provided SamplingHandler can make actual LLM API calls"
    - "sampling/createMessage request handler registered on McpClient"
    - "ClientCapabilities.sampling can be advertised during initialize"
    - "Basic sampling works without tool use (tool use is next plan)"
  artifacts:
    - path: "src/mcpp/client/sampling.h"
      provides: "Sampling types (CreateMessageRequest, CreateMessageResult, SamplingHandler, SamplingClient)"
      min_lines: 120
    - path: "src/mcpp/client/sampling.cpp"
      provides: "SamplingClient implementation"
      min_lines: 80
    - path: "src/mcpp/protocol/capabilities.h"
      provides: "ClientCapabilities.sampling field"
      contains: "SamplingCapability"
  key_links:
    - from: "src/mcpp/client.cpp"
      to: "mcpp::client::SamplingClient"
      via: "Register sampling/createMessage handler"
      pattern: "sampling/createMessage"
    - from: "src/mcpp/client.h"
      to: "mcpp::client::SamplingClient"
      via: "Public accessor for setting sampling handler"
      pattern: "set_sampling_handler"
---

<objective>
Implement basic sampling support for MCP clients to handle LLM completion requests from servers.

Purpose: Enable MCP servers to request LLM text generation through the client's LLM provider. The server sends sampling/createMessage requests with messages and parameters; the client forwards to an LLM API and returns the result. This is CLNT-02 (basic sampling) - tool use comes in 03-04.

Output: CreateMessageRequest/Result types, SamplingHandler callback type, SamplingClient class to manage sampling requests, and integration with McpClient's request handler system.

Context: CLNT-02 requirement (Sampling createMessage). Sampling allows servers to generate text using client's LLM access. This plan implements basic sampling without tool use. Tool use (agentic loops) is 03-04 and depends on this foundation.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-client-capabilities/03-RESEARCH.md

@src/mcpp/client.h
@src/mcpp/protocol/capabilities.h
@src/mcpp/core/json_rpc.h
</context>

<tasks>

<task type="auto">
  <name>Create sampling protocol types</name>
  <files>src/mcpp/client/sampling.h</files>
  <action>
    Create src/mcpp/client/sampling.h with:

    1. Include guards: MCPP_CLIENT_SAMPLING_H
    2. Includes: <vector>, <string>, <optional>, <functional>, <variant>, <nlohmann/json.hpp>

    3. ContentBlock variant for sampling message content:
       - Using std::variant for different content types
       - Types: TextContent (std::string), ImageContent, AudioContent, etc.
       - For MVP: TextContent with std::string text field

       Simplify for MVP:
       ```cpp
       struct TextContent {
           std::string type = "text";
           std::string text;
       };
       using ContentBlock = std::variant<TextContent>;
       ```

    4. SamplingMessage struct:
       - std::string role - "user" or "assistant"
       - ContentBlock content

    5. ModelPreferences struct:
       - std::optional<double> cost_priority
       - std::optional<double> speed_priority
       - std::optional<double> intelligence_priority

    6. CreateMessageRequest struct:
       - std::vector<SamplingMessage> messages
       - std::optional<ModelPreferences> model_preferences
       - std::optional<std::string> system_prompt
       - std::optional<std::string> include_context - "none", "thisServer", "allServers"
       - std::optional<double> temperature
       - int64_t max_tokens
       - std::optional<std::vector<std::string>> stop_sequences
       - std::optional<nlohmann::json> metadata

       Note: tools and tool_choice are for 03-04 (tool use)

       Methods:
       - static std::optional<CreateMessageRequest> from_json(const nlohmann::json& j)

    7. CreateMessageResult struct:
       - std::string role - "assistant"
       - ContentBlock content
       - std::string model
       - std::optional<std::string> stop_reason - "endTurn", "stopSequence", "maxTokens"

       Methods:
       - nlohmann::json to_json() const

    8. SamplingHandler callback:
       - using SamplingHandler = std::function<CreateMessageResult(const CreateMessageRequest&)>;

    9. SamplingClient class:
       - Public:
         * void set_sampling_handler(SamplingHandler handler)
         * nlohmann::json handle_create_message(const nlohmann::json& params)
       - Private:
         * SamplingHandler sampling_handler_

    All in mcpp::client namespace. MIT license header.
  </action>
  <verify>grep -c "struct CreateMessageRequest" src/mcpp/client/sampling.h returns 1</verify>
  <done>sampling.h defines CreateMessageRequest, CreateMessageResult, SamplingHandler, and SamplingClient</done>
</task>

<task type="auto">
  <name>Implement sampling client</name>
  <files>src/mcpp/client/sampling.cpp</files>
  <action>
    Create src/mcpp/client/sampling.cpp with:

    1. Include "mcpp/client/sampling.h"
    2. MIT license header

    3. CreateMessageRequest::from_json:
       - Parse messages array
       - Each message: role (required), content (required)
       - Parse optional fields: model_preferences, system_prompt, include_context, temperature, max_tokens (required), stop_sequences, metadata
       - Return nullopt if required fields missing or max_tokens < 1

    4. CreateMessageResult::to_json:
       - Build JSON object:
         {{"role", role}, {"content", content_as_json}, {"model", model}}
       - Include stop_reason if present

    5. SamplingClient::set_sampling_handler:
       - Store std::move(handler) in sampling_handler_

    6. SamplingClient::handle_create_message:
       - Parse request using CreateMessageRequest::from_json(params)
       - If parsing fails, return error JSON: {{"code", -32700}, {"message", "Failed to parse createMessage request"}}
       - If no handler set, return error: {{"code", -32601}, {"message", "No sampling handler registered"}}
       - Call handler: auto result = sampling_handler_(request)
       - Return result.to_json()

    All in mcpp::client namespace.
  </action>
  <verify>grep -c "SamplingClient::" src/mcpp/client/sampling.cpp returns 3</verify>
  <done>sampling.cpp implements request parsing, result serialization, and handler invocation</done>
</task>

<task type="auto">
  <name>Add sampling capability to protocol types</name>
  <files>src/mcpp/protocol/capabilities.h</files>
  <action>
    Update src/mcpp/protocol/capabilities.h:

    1. Confirm SamplingCapability struct exists:
       - Currently empty (no fields in spec)
       - Add if missing: struct SamplingCapability {}; (should already exist)

    2. Confirm ClientCapabilities has sampling field:
       - std::optional<SamplingCapability> sampling (should already exist)

    3. For CLNT-03 (tool use), add to SamplingCapability:
       - std::optional<bool> tools; - indicates client supports tool use in sampling

    These should already be present from Phase 1. If not, add them.
  </action>
  <verify>grep "std::optional<SamplingCapability> sampling" src/mcpp/protocol/capabilities.h returns the field</verify>
  <done>ClientCapabilities includes optional sampling field; SamplingCapability has tools flag</done>
</task>

<task type="auto">
  <name>Integrate sampling with McpClient</name>
  <files>src/mcpp/client.h src/mcpp/client.cpp</files>
  <action>
    Update McpClient to integrate SamplingClient:

    1. Add include "mcpp/client/sampling.h" to client.h

    2. Add public method:
       - void set_sampling_handler(client::SamplingHandler handler)

    3. Add private member: client::SamplingClient sampling_client_

    4. Implement set_sampling_handler in client.cpp:
       - Forward to sampling_client_.set_sampling_handler(std::move(handler))

    5. Register sampling/createMessage request handler (in constructor):
       - Use set_request_handler("sampling/createMessage", ...)
       - Lambda captures this and calls sampling_client_.handle_create_message(params)

       The handler:
       ```cpp
       set_request_handler("sampling/createMessage",
           [this](std::string_view, const JsonValue& params) -> JsonValue {
               return sampling_client_.handle_create_message(params);
           });
       ```

    This enables the server to send sampling/createMessage requests and receive LLM completions through the client's registered handler.
  </action>
  <verify>grep "sampling_client_" src/mcpp/client.h returns the member declaration</verify>
  <done>McpClient integrates SamplingClient with sampling/createMessage handler and set_sampling_handler public method</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Sampling types exist**: grep confirms CreateMessageRequest, CreateMessageResult defined
2. **Request parsing**: CreateMessageRequest::from_json parses messages and max_tokens
3. **Handler type**: SamplingHandler is function<CreateMessageResult(const CreateMessageRequest&)>
4. **SamplingClient**: Has set_sampling_handler and handle_create_message methods
5. **Protocol capability**: ClientCapabilities.sampling exists with tools field
6. **Client integration**: McpClient has sampling_client_ and set_sampling_handler method
7. **Request handler**: sampling/createMessage handler registered, calls SamplingClient

Manual verification (if needed):
- Create SamplingClient, set handler, call handle_create_message with valid JSON - handler is invoked
- Parse request with missing max_tokens - returns error
- Access sampling_client_ from McpClient, can set handler
</verification>

<success_criteria>
1. CreateMessageRequest with messages, model_preferences, max_tokens
2. CreateMessageResult with role, content, model, stop_reason
3. SamplingHandler callback type defined
4. SamplingClient with set_sampling_handler and handle_create_message
5. sampling/createMessage request handler registered on McpClient
6. Client can set sampling handler via McpClient::set_sampling_handler
</success_criteria>

<output>
After completion, create `.planning/phases/03-client-capabilities/03-03-SUMMARY.md` with:
- Frontmatter: phase, plan, wave, affects: ["03-client-capabilities", "04-client-capabilities"], subsystem: "client", tech-stack-added: [], patterns-established: ["handler-based request processing"], key-files: ["sampling.h", "sampling.cpp"]
- Summary of sampling implementation
- CreateMessageRequest/Result structure
- Integration with McpClient
- Any deviations from plan
- Next: Sampling with tool use (03-04)
</output>

---
phase: 03-client-capabilities
plan: 06
type: execute
wave: 3
depends_on: [03-01, 03-02, 03-03, 03-04, 03-05]
files_modified:
  - src/mcpp/client/future_wrapper.h
  - src/mcpp/client/future_wrapper.cpp
  - src/mcpp/client_blocking.h
autonomous: true

must_haves:
  truths:
    - "FutureBuilder creates promise/future pairs for async operations"
    - "FutureBuilder::wrap converts callback API to std::future"
    - "McpClientBlocking provides blocking API wrappers on top of McpClient"
    - "initialize() blocking method returns InitializeResult"
    - "list_roots() blocking method returns ListRootsResult"
    - "create_message() blocking method returns CreateMessageResult"
    - "User can call .get() on returned futures to block for results"
    - "Timeout support prevents infinite blocking"
  artifacts:
    - path: "src/mcpp/client/future_wrapper.h"
      provides: "FutureBuilder template for wrapping callback-based async with std::future"
      min_lines: 60
    - path: "src/mcpp/client/future_wrapper.cpp"
      provides: "FutureBuilder implementation"
      min_lines: 40
    - path: "src/mcpp/client_blocking.h"
      provides: "McpClientBlocking class with ergonomic blocking API"
      min_lines: 150
  key_links:
    - from: "src/mcpp/client_blocking.h"
      to: "mcpp::McpClient"
      via: "Holds reference for callback wrapping"
      pattern: "McpClientBlocking"
    - from: "src/mcpp/client_blocking.h"
      to: "mcpp::client::FutureBuilder"
      via: "Uses FutureBuilder for all blocking methods"
      pattern: "FutureBuilder"
---

<objective>
Implement std::future wrapper API for ergonomic blocking calls on top of callback-based async core.

Purpose: Provide synchronous/blocking API for users who prefer simple call/wait over callback-based async. The callback API remains the foundation (required for streaming and non-blocking I/O), but futures enable straightforward synchronous code. This is ASYNC-04 (std::future wrappers).

Output: FutureBuilder template for promise/future creation, McpClientBlocking class with blocking methods for common operations (initialize, list_roots, create_message), and timeout support to prevent infinite blocking.

Context: ASYNC-04 requirement (std::future wrappers). Depends on all other Phase 3 plans (needs cancellation, roots, sampling, elicitation to exist). The pattern: create shared_ptr<promise>, capture in lambda, return future.get() blocks until complete.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-client-capabilities/03-RESEARCH.md

@src/mcpp/client.h
@src/mcpp/client/future_wrapper.h
@src/mcpp/client/roots.h
@src/mcpp/client/sampling.h
</context>

<tasks>

<task type="auto">
  <name>Create FutureBuilder template</name>
  <files>src/mcpp/client/future_wrapper.h</files>
  <action>
    Create src/mcpp/client/future_wrapper.h with:

    1. Include guards: MCPP_CLIENT_FUTURE_WRAPPER_H
    2. Includes: <future>, <memory>, <functional>, <exception>, <nlohmann/json.hpp>
    3. Include "mcpp/core/error.h" for JsonRpcError

    4. FutureBuilder template class:
       ```cpp
       namespace mcpp::client {

       template<typename T>
       class FutureBuilder {
       public:
           // Promise/Future pair type
           using PromisePtr = std::shared_ptr<std::promise<T>>;
           using Future = std::future<T>;

           // Create a promise/future pair
           static std::pair<PromisePtr, Future> create() {
               auto promise = std::make_shared<std::promise<T>>();
               auto future = promise->get_future();
               return {std::move(promise), std::move(future)};
           }

           // Wrap a callback-based async function, returning a future
           template<typename AsyncFn>
           static Future wrap(AsyncFn&& async_fn) {
               auto [promise, future] = create();

               // Call async function with callbacks that set the promise
               try {
                   async_fn(
                       [promise](const T& result) {
                           try {
                               promise->set_value(result);
                           } catch (...) {
                               // Promise already satisfied or other error
                           }
                       },
                       [promise](const JsonRpcError& error) {
                           try {
                               promise->set_exception(std::make_exception_ptr(
                                   std::runtime_error(error.message)
                               ));
                           } catch (...) {
                               // Promise already satisfied
                           }
                       }
                   );
               } catch (...) {
                   promise->set_exception(std::current_exception());
               }

               return future;
           }

           // Wait for future with timeout
           static T with_timeout(Future&& future, std::chrono::milliseconds timeout) {
               auto status = future.wait_for(timeout);
               if (status == std::future_status::timeout) {
                   throw std::runtime_error("Request timeout");
               }
               return future.get();
           }
       };

       } // namespace mcpp::client
       ```

    The shared_ptr<promise> pattern ensures the promise lives until the lambda is called, even if the FutureBuilder goes out of scope.
  </action>
  <verify>grep -c "class FutureBuilder" src/mcpp/client/future_wrapper.h returns 1</verify>
  <done>future_wrapper.h defines FutureBuilder template with promise/future creation and callback wrapping</done>
</task>

<task type="auto">
  <name>Create FutureBuilder implementation</name>
  <files>src/mcpp/client/future_wrapper.cpp</files>
  <action>
    Create src/mcpp/client/future_wrapper.cpp with:

    1. Include "mcpp/client/future_wrapper.h"
    2. MIT license header

    Since FutureBuilder is a template class defined entirely in the header, this file may be minimal or only contain explicit instantiations for common types:

    ```cpp
    #include "mcpp/client/future_wrapper.h"

    namespace mcpp::client {

    // Explicit instantiations for common types
    template class FutureBuilder<nlohmann::json>;
    template class FutureBuilder<protocol::InitializeResult>;

    // Add more as needed based on actual usage

    } // namespace mcpp::client
    ```

    This is optional - the header-only implementation works. Explicit instantiation can reduce compile times for commonly used types.
  </action>
  <verify>grep "FutureBuilder" src/mcpp/client/future_wrapper.cpp returns 1 or more</verify>
  <done>future_wrapper.cpp provides explicit instantiations for common types (optional optimization)</done>
</task>

<task type="auto">
  <name>Create McpClientBlocking class</name>
  <files>src/mcpp/client_blocking.h</files>
  <action>
    Create src/mcpp/client_blocking.h with:

    1. Include guards: MCPP_CLIENT_BLOCKING_H
    2. Includes: <future>, <chrono>, <mcpp/client.h>, <mcpp/client/future_wrapper.h>, <mcpp/client/roots.h>, <mcpp/client/sampling.h>, <mcpp/protocol/initialize.h>

    3. McpClientBlocking class:
       ```cpp
       namespace mcpp {

       class McpClientBlocking {
       public:
           explicit McpClientBlocking(McpClient& client);

           // Blocking initialize
           protocol::InitializeResult initialize(
               const protocol::InitializeRequestParams& params
           );

           // Blocking roots/list
           client::ListRootsResult list_roots();

           // Blocking sampling/createMessage
           client::CreateMessageResult create_message(
               const client::CreateMessageRequest& request
           );

           // Generic blocking request (for any method)
           nlohmann::json send_request(
               std::string_view method,
               const nlohmann::json& params = nullptr
           );

           // Timeout support
           template<typename T>
           T with_timeout(std::future<T> future, std::chrono::milliseconds timeout) {
               return client::FutureBuilder<T>::with_timeout(std::move(future), timeout);
           }

       private:
           McpClient& client_;
           std::chrono::milliseconds default_timeout_;
       };

       } // namespace mcpp
       ```

    4. Implement methods in header (or separate .cpp if preferred):
       ```cpp
       McpClientBlocking::McpClientBlocking(McpClient& client)
           : client_(client), default_timeout_(30000) {}

       protocol::InitializeResult McpClientBlocking::initialize(
       const protocol::InitializeRequestParams& params) {
           return client::FutureBuilder<protocol::InitializeResult>::wrap(
               [&](auto on_success, auto on_error) {
                   client_.initialize(params, on_success, on_error);
               }
           ).get();
       }

       client::ListRootsResult McpClientBlocking::list_roots() {
           // Need to parse the JSON result to ListRootsResult
           auto json_result = client::FutureBuilder<nlohmann::json>::wrap(
               [&](auto on_success, auto on_error) {
                   client_.send_request("roots/list", nullptr, on_success, on_error);
               }
           ).get();

           client::ListRootsResult result;
           // Parse json_result["roots"] into result.roots...
           return result;
       }

       // Similar for create_message and generic send_request
       ```

    The key pattern: wrap callback API, return future, call .get() to block.
  </action>
  <verify>grep -c "class McpClientBlocking" src/mcpp/client_blocking.h returns 1</verify>
  <done>client_blocking.h defines McpClientBlocking with blocking methods for initialize, list_roots, create_message, and generic send_request</done>
</task>

<task type="auto">
  <name>Add timeout and error handling</name>
  <files>src/mcpp/client_blocking.h</files>
  <action>
    Enhance McpClientBlocking with timeout and error handling:

    1. Add timeout variants of blocking methods:
       ```cpp
       protocol::InitializeResult initialize(
           const protocol::InitializeRequestParams& params,
           std::chrono::milliseconds timeout
       );

       client::ListRootsResult list_roots(std::chrono::milliseconds timeout);
       client::CreateMessageResult create_message(
           const client::CreateMessageRequest& request,
           std::chrono::milliseconds timeout
       );
       ```

    2. Implement timeout variants:
       ```cpp
       protocol::InitializeResult McpClientBlocking::initialize(
           const protocol::InitializeRequestParams& params,
           std::chrono::milliseconds timeout) {
           auto future = client::FutureBuilder<protocol::InitializeResult>::wrap(
               [&](auto on_success, auto on_error) {
                   client_.initialize(params, on_success, on_error);
               }
           );
           return with_timeout(std::move(future), timeout);
       }
       ```

    3. Add error handling wrapper:
       ```cpp
       class McpClientBlockingError : public std::runtime_error {
       public:
           McpClientBlockingError(const std::string& msg, int code = 0)
               : std::runtime_error(msg), code_(code) {}
           int code() const { return code_; }
       private:
           int code_;
       };
       ```

    4. Update methods to catch exceptions and rethrow as McpClientBlockingError

    This ensures users get meaningful errors and timeout protection.
  </action>
  <verify>grep "with_timeout" src/mcpp/client_blocking.h returns timeout method</verify>
  <done>McpClientBlocking has timeout variants and proper error handling with McpClientBlockingError</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **FutureBuilder exists**: Template class with create, wrap, and with_timeout methods
2. **Promise pattern**: Uses shared_ptr<promise> to ensure lifetime
3. **McpClientBlocking exists**: Class with reference to McpClient
4. **Blocking methods**: initialize, list_roots, create_message, send_request
5. **Timeout support**: with_timeout method and timeout variants
6. **Error handling**: McpClientBlockingError for typed exceptions

Manual verification (if needed):
- Create McpClientBlocking, call initialize() - blocks until complete
- Call with timeout that expires - throws timeout exception
- Call on disconnected client - throws appropriate error
</verification>

<success_criteria>
1. FutureBuilder template with wrap() method
2. McpClientBlocking class wraps McpClient reference
3. Blocking initialize() returns InitializeResult
4. Blocking list_roots() returns ListRootsResult
5. Blocking create_message() returns CreateMessageResult
6. Generic send_request() for any method
7. Timeout support prevents infinite blocking
8. Error handling with typed exception
</success_criteria>

<output>
After completion, create `.planning/phases/03-client-capabilities/03-06-SUMMARY.md` with:
- Frontmatter: phase, plan, wave, depends_on: ["03-01", "03-02", "03-03", "03-04", "03-05"], affects: [], subsystem: "client", tech-stack-added: ["std::future/std::promise"], patterns-established: ["promise/future wrapping for blocking API", "shared_ptr<promise> for lifetime management"], key-files: ["future_wrapper.h", "client_blocking.h"]
- Summary of future wrapper implementation
- Blocking API coverage (all major client operations)
- Timeout and error handling
- Any deviations from plan
- Next: Phase 3 complete, ready for Phase 4 (Advanced Features & HTTP Transport)
</output>

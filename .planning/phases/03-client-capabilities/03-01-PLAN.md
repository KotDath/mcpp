---
phase: 03-client-capabilities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CMakeLists.txt
  - src/mcpp/client/cancellation.h
  - src/mcpp/client/cancellation.cpp
  - src/mcpp/core/request_tracker.h
  - src/mcpp/client.h
  - src/mcpp/client.cpp
autonomous: true

must_haves:
  truths:
    - "Project compiles with C++20 standard enabled"
    - "CancellationSource can create CancellationToken and request cancellation"
    - "CancellationManager tracks pending requests by RequestId and handles cancellation"
    - "notifications/cancelled from server triggers cancellation for matching request"
    - "Cancellation properly handles race conditions (cancel after completion)"
    - "RequestTracker integrates with CancellationManager for cleanup on completion"
    - "User can poll CancellationToken.is_cancelled() in long-running operations"
  artifacts:
    - path: "CMakeLists.txt"
      provides: "C++20 build configuration"
      contains: "CMAKE_CXX_STANDARD 20"
    - path: "src/mcpp/client/cancellation.h"
      provides: "Cancellation token types using std::stop_token"
      min_lines: 80
    - path: "src/mcpp/client/cancellation.cpp"
      provides: "Cancellation implementation"
      min_lines: 60
    - path: "src/mcpp/core/request_tracker.h"
      provides: "Extended RequestTracker with cancellation support"
      contains: "unregister_request"
  key_links:
    - from: "src/mcpp/client.cpp"
      to: "mcpp::client::CancellationManager"
      via: "Handle notifications/cancelled"
      pattern: "notifications/cancelled"
    - from: "src/mcpp/client.cpp"
      to: "mcpp::client::CancellationManager"
      via: "Register request on send_request"
      pattern: "register_request"
    - from: "src/mcpp/client.cpp"
      to: "mcpp::client::CancellationManager"
      via: "Unregister on response"
      pattern: "unregister_request"
---

<objective>
Implement C++20 upgrade and cancellation support for cooperative request cancellation with std::stop_token.

Purpose: Enable MCP clients to cancel in-flight requests via notifications/cancelled from servers with proper race condition handling. Cancellation is fundamental to user experience (allowing users to stop long-running operations) and required by the MCP 2025-11-25 spec.

Output: C++20 build configuration, CancellationToken/CancellationSource types using std::stop_token, CancellationManager for tracking cancelable requests, and integration with McpClient.

Context: ASYNC-02 requirement (Cancellation support). Research recommends std::stop_token over atomic<bool> for better composability and std::jthread integration. This is a foundation that other client capability features can use for cancellation.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-client-capabilities/03-RESEARCH.md

# Only reference prior plan SUMMARYs if genuinely needed
@src/mcpp/client.h
@src/mcpp/core/request_tracker.h
@src/mcpp/async/callbacks.h
</context>

<tasks>

<task type="auto">
  <name>Upgrade project to C++20</name>
  <files>CMakeLists.txt</files>
  <action>
    1. Find CMakeLists.txt in the project root
    2. Locate the CMAKE_CXX_STANDARD setting (currently C++17)
    3. Change from C++17 to C++20
    4. Ensure CMAKE_CXX_STANDARD_REQUIRED is set to ON
    5. Add comment explaining the upgrade is for std::stop_token support (ASYNC-02 cancellation)

    Do NOT change any other compiler settings or flags.
  </action>
  <verify>grep "CMAKE_CXX_STANDARD 20" CMakeLists.txt returns the setting</verify>
  <done>CMakeLists.txt specifies C++20 standard with CMAKE_CXX_STANDARD_REQUIRED ON</done>
</task>

<task type="auto">
  <name>Create cancellation token types</name>
  <files>src/mcpp/client/cancellation.h</files>
  <action>
    Create src/mcpp/client/cancellation.h with:

    1. Include guards: MCPP_CLIENT_CANCELLATION_H
    2. Includes: <stop_token>, <optional>, <string>, <unordered_map>, <mutex>, <variant>
    3. Import mcpp::core::RequestId from "../core/json_rpc.h"

    4. CancellationToken class:
       - Default constructor (no cancellation)
       - Explicit constructor from std::stop_token
       - bool is_cancelled() const - checks if stop was requested
       - const std::stop_token& get() const - accessor
       - Private: std::stop_token token_

    5. CancellationSource class:
       - Default constructor
       - Non-copyable, non-movable
       - CancellationToken get_token() const - creates token from source
       - void cancel() - requests stop via source_
       - bool is_cancelled() const - checks if stop requested
       - Private: std::stop_source source_

    6. CancellationManager class:
       - Public:
         * void register_request(RequestId id, CancellationSource source)
         * void handle_cancelled(RequestId id, const std::optional<std::string>& reason)
         * void unregister_request(RequestId id)
         * size_t pending_count() const
       - Private:
         * std::unordered_map<RequestId, CancellationSource> pending_
         * mutable std::mutex mutex_

    All classes in mcpp::client namespace.
    MIT license header at top.
  </action>
  <verify>grep -c "class CancellationToken" src/mcpp/client/cancellation.h returns 1</verify>
  <done>cancellation.h defines CancellationToken, CancellationSource, and CancellationManager with std::stop_token backing</done>
</task>

<task type="auto">
  <name>Implement cancellation manager</name>
  <files>src/mcpp/client/cancellation.cpp</files>
  <action>
    Create src/mcpp/client/cancellation.cpp with:

    1. Include "mcpp/client/cancellation.h"
    2. MIT license header

    3. CancellationManager::register_request:
       - Lock mutex_
       - emplace id with std::move(source) into pending_
       - (No return value)

    4. CancellationManager::handle_cancelled:
       - Lock mutex_
       - Find id in pending_
       - If found: call source.cancel(), erase from pending_
       - If not found: no-op (request already completed - race condition handled)
       - Log reason to stderr if provided (for debugging)

    5. CancellationManager::unregister_request:
       - Lock mutex_
       - Erase id from pending_ if present
       - No error if not present (already unregistered or cancelled)

    6. CancellationManager::pending_count:
       - Lock mutex_
       - Return pending_.size()

    All methods in mcpp::client namespace.
  </action>
  <verify>grep -c "CancellationManager::" src/mcpp/client/cancellation.cpp returns 4 or more</verify>
  <done>cancellation.cpp implements all CancellationManager methods with proper mutex locking and race condition handling</done>
</task>

<task type="auto">
  <name>Integrate cancellation with McpClient</name>
  <files>src/mcpp/client.h src/mcpp/client.cpp</files>
  <action>
    Update McpClient to integrate CancellationManager:

    1. Add include "mcpp/client/cancellation.h" to client.h
    2. Add private member: client::CancellationManager cancellation_manager_
    3. Add public method: void cancel_request(RequestId id) - for manual cancellation

    4. In client.cpp, update send_request:
       - After generating request ID, create CancellationSource
       - Call cancellation_manager_.register_request(id, source)
       - Store source in PendingRequest (update PendingRequest in request_tracker.h to include std::optional<client::CancellationSource>)
       - This requires updating request_tracker.h to include cancellation.h forward declaration

    5. Register notification handler for "notifications/cancelled":
       - In McpClient constructor or connect(), register:
         client.set_notification_handler("notifications/cancelled",
             [this](std::string_view, const JsonValue& params) {
                 std::optional<RequestId> request_id;
                 if (params.contains("requestId")) {
                     request_id = parse_request_id(params["requestId"]);
                 }
                 std::optional<std::string> reason;
                 if (params.contains("reason")) {
                     reason = params["reason"].get<std::string>();
                 }
                 if (request_id) {
                     cancellation_manager_.handle_cancelled(*request_id, reason);
                 }
             });

    6. Update handle_response in client.cpp:
       - After completing request (calling callbacks), call cancellation_manager_.unregister_request(id)

    7. Update RequestTracker::complete to return the CancellationSource along with callbacks (update PendingRequest struct):
       - This is tricky - better approach: have separate cancellation tracking in McpClient
       - Simpler: McpClient tracks cancellation separately from RequestTracker

    Actually, let's simplify: Keep RequestTracker as-is, track cancellation separately in McpClient.
  </action>
  <verify>grep "cancellation_manager_" src/mcpp/client.h returns the member declaration</verify>
  <done>McpClient integrates CancellationManager with registration on send_request, unregister on completion, and notifications/cancelled handler</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **C++20 compiles**: `cmake .. && make` succeeds without errors
2. **Cancellation types exist**: grep confirms CancellationToken, CancellationSource, CancellationManager defined
3. **Client integration**: McpClient has cancellation_manager_ member and cancel_request method
4. **Notification handler registered**: notifications/cancelled handler calls cancellation_manager_.handle_cancelled
5. **Cleanup on completion**: handle_response calls unregister_request
6. **Race condition handling**: handle_cancelled gracefully handles missing request IDs (already completed)

Manual verification (if needed):
- Create a CancellationSource, get token, call cancel() - token.is_cancelled() returns true
- Register multiple requests, cancel one - only that request is cancelled
- Cancel already-completed request - no crash or error
</verification>

<success_criteria>
1. Project compiles with C++20 standard
2. CancellationSource/CancellationToken work correctly with std::stop_token
3. CancellationManager tracks and cancels requests by ID
4. McpClient handles notifications/cancelled from server
5. Cancellation properly handles race conditions (cancel after completion)
6. Request cleanup unregisters from CancellationManager
</success_criteria>

<output>
After completion, create `.planning/phases/03-client-capabilities/03-01-SUMMARY.md` with:
- Frontmatter: phase, plan, wave, affects: ["04-client-capabilities"], subsystem: "client", tech-stack-added: ["C++20 std::stop_token"], patterns-established: ["cooperative cancellation with stop_token"], key-files: ["cancellation.h", "cancellation.cpp"]
- Summary of C++20 upgrade
- Cancellation implementation details
- Integration points with McpClient
- Any deviations from plan
- Next: Roots management (03-02)
</output>

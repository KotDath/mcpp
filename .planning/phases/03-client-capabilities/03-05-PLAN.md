---
phase: 03-client-capabilities
plan: 05
type: execute
wave: 2
depends_on: []
files_modified:
  - src/mcpp/client/elicitation.h
  - src/mcpp/client/elicitation.cpp
  - src/mcpp/protocol/capabilities.h
  - src/mcpp/client.h
  - src/mcpp/client.cpp
autonomous: true

must_haves:
  truths:
    - "ElicitRequestForm defines primitive schema for form mode"
    - "ElicitRequestURL defines URL mode with elicitation_id"
    - "ElicitationHandler callback receives form or URL request"
    - "ElicitationClient handles elicitation/create requests"
    - "elicitation/create request handler registered on McpClient"
    - "notifications/elicitation/complete handler registered for URL mode"
    - "ClientCapabilities.elicitation can be advertised with form and url fields"
  artifacts:
    - path: "src/mcpp/client/elicitation.h"
      provides: "Elicitation types (ElicitRequestForm, ElicitRequestURL, ElicitResult, ElicitationHandler, ElicitationClient)"
      min_lines: 120
    - path: "src/mcpp/client/elicitation.cpp"
      provides: "ElicitationClient implementation"
      min_lines: 80
    - path: "src/mcpp/protocol/capabilities.h"
      provides: "ElicitationCapability in protocol types"
      contains: "ElicitationCapability"
  key_links:
    - from: "src/mcpp/client.cpp"
      to: "mcpp::client::ElicitationClient"
      via: "Register elicitation/create handler"
      pattern: "elicitation/create"
    - from: "src/mcpp/client.cpp"
      to: "mcpp::client::ElicitationClient"
      via: "Register elicitation/complete notification"
      pattern: "elicitation/complete"
---

<objective>
Implement elicitation support for MCP clients to collect user input via forms and out-of-band URLs.

Purpose: Enable MCP servers to request structured user input during tool execution. Form mode allows in-app prompts with JSON Schema validation. URL mode enables secure out-of-band interactions (e.g., OAuth flows) with completion notification. This is CLNT-04 (form mode) and CLNT-05 (URL mode).

Output: ElicitRequestForm/URL types, PrimitiveSchema for form fields, ElicitResult for user response, ElicitationHandler callback, ElicitationClient for request handling, and notification handler for URL mode completion.

Context: CLNT-04 and CLNT-05 requirements (Elicitation form and URL modes). Elicitation allows servers to interact with users during execution - for sensitive data entry, confirmations, or external auth. Form mode is synchronous (user responds immediately), URL mode is asynchronous (notification completes it).
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-client-capabilities/03-RESEARCH.md

@src/mcpp/client.h
@src/mcpp/protocol/capabilities.h
@src/mcpp/core/json_rpc.h
</context>

<tasks>

<task type="auto">
  <name>Create elicitation protocol types</name>
  <files>src/mcpp/client/elicitation.h</files>
  <action>
    Create src/mcpp/client/elicitation.h with:

    1. Include guards: MCPP_CLIENT_ELICITATION_H
    2. Includes: <string>, <map>, <vector>, <optional>, <functional>, <variant>, <nlohmann/json.hpp>

    3. PrimitiveSchema for form mode (simplified JSON Schema - top level only):
       ```cpp
       struct PrimitiveSchema {
           std::string type;  // "string", "number", "integer", "boolean", "array"
           std::optional<std::string> title;
           std::optional<std::string> description;
           std::optional<std::string> default_value;  // Renamed from 'default' (keyword)

           // For string type
           std::optional<std::string> pattern;  // Regex pattern
           std::optional<size_t> min_length;
           std::optional<size_t> max_length;

           // For number/integer type
           std::optional<double> minimum;
           std::optional<double> maximum;

           // For array type (enum - single or multi select)
           std::optional<std::vector<std::string>> enum_values;
           std::optional<bool> multiselect;
       };
       ```

    4. ElicitRequestForm (form mode):
       ```cpp
       struct ElicitRequestForm {
           std::string message;  // Prompt shown to user
           std::string mode = "form";
           std::map<std::string, PrimitiveSchema> requested_schema;  // Field name -> schema
           std::optional<std::vector<std::string>> required;  // Required field names
       };
       ```

    5. ElicitRequestURL (URL mode):
       ```cpp
       struct ElicitRequestURL {
           std::string message;  // Prompt shown to user
           std::string mode = "url";
           std::string elicitation_id;  // Unique ID for this request
           std::string url;  // URL to open
           std::optional<std::string> confirm_url;  // URL to confirm completion
       };
       ```

    6. ElicitResult (user's response):
       ```cpp
       struct ElicitResult {
           std::string action;  // "accept", "decline", "cancel"
           std::optional<std::map<std::string, std::variant<std::string, double, bool, std::vector<std::string>>>> content;

           nlohmann::json to_json() const;
       };
       ```

    7. ElicitationHandler callback:
       ```cpp
       using ElicitationHandler = std::function<ElicitResult(const std::variant<ElicitRequestForm, ElicitRequestURL>&)>;
       ```

    8. ElicitationCompleteNotification (for URL mode):
       ```cpp
       struct ElicitationCompleteNotification {
           std::string elicitation_id;
           std::string action;  // "accept", "decline", "cancel"
           std::optional<nlohmann::json> content;

           static std::optional<ElicitationCompleteNotification> from_json(const nlohmann::json& j);
       };
       ```

    9. ElicitationClient class:
       ```cpp
       class ElicitationClient {
       public:
           void set_elicitation_handler(ElicitationHandler handler);
           nlohmann::json handle_elicitation_create(const nlohmann::json& params);
           void handle_elicitation_complete(const nlohmann::json& params);

       private:
           ElicitationHandler handler_;
           std::unordered_map<std::string, std::function<void(const ElicitResult&)>> pending_url_requests_;
           std::mutex mutex_;
       };
       ```

    All in mcpp::client namespace. MIT license header.
  </action>
  <verify>grep -c "struct ElicitRequest" src/mcpp/client/elicitation.h returns 2</verify>
  <done>elicitation.h defines ElicitRequestForm, ElicitRequestURL, ElicitResult, ElicitationHandler, and ElicitationClient</done>
</task>

<task type="auto">
  <name>Implement elicitation client</name>
  <files>src/mcpp/client/elicitation.cpp</files>
  <action>
    Create src/mcpp/client/elicitation.cpp with:

    1. Include "mcpp/client/elicitation.h"
    2. MIT license header

    3. ElicitResult::to_json:
       - Build JSON: {{"action", action}}
       - Include content if present
       - For content, convert variant to JSON based on type

    4. ElicitationCompleteNotification::from_json:
       - Parse elicitation_id, action, content
       - Return nullopt if required fields missing

    5. ElicitationClient::set_elicitation_handler:
       - Store std::move(handler) in handler_

    6. ElicitationClient::handle_elicitation_create:
       - Parse mode from params
       - If mode == "form":
         * Parse ElicitRequestForm
         * Call handler_ with form variant
         * Return ElicitResult::to_json()
       - If mode == "url":
         * Parse ElicitRequestURL with elicitation_id
         * Store promise/callback in pending_url_requests_
         * Call handler_ with URL variant (async - will complete later)
         * For now, return immediately with acknowledgment
       - If no handler set: return error

    7. ElicitationClient::handle_elicitation_complete:
       - Parse ElicitationCompleteNotification
       - Find pending request by elicitation_id
       - Invoke stored callback with result
       - Remove from pending map

    The key distinction: form mode is synchronous (user responds immediately), URL mode is asynchronous (notification completes later).
  </action>
  <verify>grep -c "ElicitationClient::" src/mcpp/client/elicitation.cpp returns 3</verify>
  <done>elicitation.cpp implements form mode (synchronous) and URL mode (async with completion notification)</done>
</task>

<task type="auto">
  <name>Add elicitation capability to protocol types</name>
  <files>src/mcpp/protocol/capabilities.h</files>
  <action>
    Update src/mcpp/protocol/capabilities.h:

    1. Add ElicitationCapability struct:
       ```cpp
       struct ElicitationCapability {
           std::optional<bool> form;  // Client supports form mode (CLNT-04)
           std::optional<bool> url;   // Client supports URL mode (CLNT-05)
       };
       ```

    2. Add to ClientCapabilities:
       ```cpp
       std::optional<ElicitationCapability> elicitation;
       ```

    Follow the existing pattern of other optional capability fields.
  </action>
  <verify>grep "std::optional<ElicitationCapability> elicitation" src/mcpp/protocol/capabilities.h returns the field</verify>
  <done>ClientCapabilities includes optional elicitation field of type ElicitationCapability with form and url flags</done>
</task>

<task type="auto">
  <name>Integrate elicitation with McpClient</name>
  <files>src/mcpp/client.h src/mcpp/client.cpp</files>
  <action>
    Update McpClient to integrate ElicitationClient:

    1. Add include "mcpp/client/elicitation.h" to client.h

    2. Add public method:
       - void set_elicitation_handler(client::ElicitationHandler handler)

    3. Add private member: client::ElicitationClient elicitation_client_

    4. Implement set_elicitation_handler in client.cpp:
       - Forward to elicitation_client_.set_elicitation_handler(std::move(handler))

    5. Register elicitation/create request handler (in constructor):
       ```cpp
       set_request_handler("elicitation/create",
           [this](std::string_view, const JsonValue& params) -> JsonValue {
               return elicitation_client_.handle_elicitation_create(params);
           });
       ```

    6. Register notifications/elicitation/complete notification handler (in constructor):
       ```cpp
       set_notification_handler("notifications/elicitation/complete",
           [this](std::string_view, const JsonValue& params) {
               elicitation_client_.handle_elicitation_complete(params);
           });
       ```

    This enables the server to request user input via forms (synchronous) or URLs (async with completion notification).
  </action>
  <verify>grep "elicitation_client_" src/mcpp/client.h returns the member declaration</verify>
  <done>McpClient integrates ElicitationClient with elicitation/create handler and elicitation/complete notification handler</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Elicitation types exist**: ElicitRequestForm, ElicitRequestURL, ElicitResult defined
2. **PrimitiveSchema**: Defines form field types with validation rules
3. **Handler type**: ElicitationHandler is function<ElicitResult(variant<Form, URL>)>
4. **ElicitationClient**: Has set_elicitation_handler, handle_elicitation_create, handle_elicitation_complete
5. **Protocol capability**: ElicitationCapability with form and url fields
6. **Client integration**: McpClient has elicitation_client_ and set_elicitation_handler
7. **Request handlers**: elicitation/create and notifications/elicitation/complete registered

Manual verification (if needed):
- Create ElicitationClient, set handler, call handle_elicitation_create with form mode - handler invoked with form
- Call with URL mode - handler invoked with URL, pending request stored
- Call handle_elicitation_complete with matching elicitation_id - callback invoked
</verification>

<success_criteria>
1. ElicitRequestForm with message, mode, requested_schema, required fields
2. ElicitRequestURL with message, mode, elicitation_id, url
3. ElicitResult with action and optional content
4. PrimitiveSchema for form field definitions
5. ElicitationClient with handlers for create and complete
6. elicitation/create request handler registered
7. notifications/elicitation/complete notification handler registered
</success_criteria>

<output>
After completion, create `.planning/phases/03-client-capabilities/03-05-SUMMARY.md` with:
- Frontmatter: phase, plan, wave, depends_on: [], affects: ["03-client-capabilities"], subsystem: "client", tech-stack-added: [], patterns-established: ["variant-based request modes", "async completion notification pattern"], key-files: ["elicitation.h", "elicitation.cpp"]
- Summary of elicitation implementation
- Form mode (synchronous) vs URL mode (async) distinction
- Integration with McpClient
- Any deviations from plan
- Next: std::future wrapper API (03-06)
</output>

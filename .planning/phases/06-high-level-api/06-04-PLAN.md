---
phase: 06-high-level-api
plan: 04
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - src/mcpp/util/pagination.h
  - src/mcpp/util/error.h
  - src/mcpp/util/retry.h
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "list_all helper automatically paginates through cursor-based results"
    - "ServiceError hierarchy provides typed error categories with context preservation"
    - "RetryPolicy template with exponential backoff strategy"
    - "All new utility headers are exported in CMakeLists.txt"
  artifacts:
    - path: "src/mcpp/util/pagination.h"
      provides: "list_all helper for automatic pagination"
      exports: ["template<typename T> list_all", "struct PaginatedRequest"]
    - path: "src/mcpp/util/error.h"
      provides: "Unified error types"
      exports: ["class ServiceError", "class TransportError", "class ProtocolError"]
    - path: "src/mcpp/util/retry.h"
      provides: "Retry with backoff strategies"
      exports: ["template<typename T> class RetryPolicy", "class ExponentialBackoff"]
  key_links:
    - from: "src/mcpp/util/pagination.h"
      to: "src/mcpp/content/pagination.h"
      via: "include"
      pattern: "#include.*pagination.h"
    - from: "src/mcpp/util/retry.h"
      to: "src/mcpp/util/error.h"
      via: "include"
      pattern: "#include.*error.h"
    - from: "CMakeLists.txt"
      to: "src/mcpp/util/*.h"
      via: "MCPP_PUBLIC_HEADERS"
      pattern: "api/|util/"
---

<objective>
Utility features: pagination helper, unified error hierarchy, and retry strategies for high-level API.

Purpose: Provide helper utilities that make the high-level API more ergonomic and production-ready. Pagination helper eliminates manual cursor tracking, unified error types enable structured error handling, and retry strategies add resilience for transient failures.

Output: list_all pagination helper, ServiceError hierarchy, RetryPolicy with exponential backoff, and CMakeLists.txt updates for new headers.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-high-level-api/06-CONTEXT.md
@.planning/phases/06-high-level-api/06-RESEARCH.md
@.planning/phases/06-high-level-api/06-01-SUMMARY.md
@.planning/phases/06-high-level-api/06-02-SUMMARY.md
@.planning/phases/06-high-level-api/06-03-SUMMARY.md
@thirdparty/rust-sdk/crates/rmcp/src/service/client.rs
@thirdparty/gopher-mcp/sdk/go/src/filters/retry.go
@src/mcpp/content/pagination.h
@src/mcpp/core/error.h
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Create list_all pagination helper</name>
  <files>src/mcpp/util/pagination.h</files>
  <action>
Create src/mcpp/util/pagination.h with:

1. PaginatedRequest struct:
   - std::optional<std::string> cursor
   - Optional limit parameter

2. list_all template function:
   ```cpp
   template <typename T, typename ListFn>
   std::vector<T> list_all(ListFn&& list_fn) {
       std::vector<T> items;
       std::optional<std::string> cursor;

       do {
           auto page = list_fn(cursor);
           items.insert(items.end(),
                       std::make_move_iterator(page.items.begin()),
                       std::make_move_iterator(page.items.end()));
           cursor = page.next_cursor;
       } while (cursor);

       return items;
   }
   ```

3. Include mcpp/content/pagination.h for PaginatedResult
4. Include <vector>, <optional>, <functional>

5. Namespace: mcpp::util

Follow rust-sdk list_all pattern from service/client.rs.

Note: This is header-only template - no .cpp file needed.
  </action>
  <verify>
grep -q "list_all" src/mcpp/util/pagination.h && \
grep -q "template.*typename T" src/mcpp/util/pagination.h && \
grep -q "PaginatedResult" src/mcpp/util/pagination.h
  </verify>
  <done>
list_all helper:
- Accepts lambda or function returning PaginatedResult<T>
- Accumulates all items across pages
- Handles cursor pagination automatically
  </done>
</task>

<task type="auto">
  <name>Create unified error hierarchy</name>
  <files>src/mcpp/util/error.h</files>
  <action>
Create src/mcpp/util/error.h with:

1. ServiceError base class:
   - Inherits from std::runtime_error
   - Members: std::string message_, std::optional<int> code_, std::map<std::string, std::string> context_
   - Constructor: ServiceError(std::string_view message, std::optional<int> code = {}, std::map<std::string, std::string> context = {})
   - Methods: code() const, context() const, what() const override

2. TransportError (inherits ServiceError):
   - For transport-layer failures (connection lost, timeout)
   - Additional context: transport_type_

3. ProtocolError (inherits ServiceError):
   - For protocol violations (invalid JSON, unexpected message type)
   - Additional context: protocol_version_

4. RequestError (inherits ServiceError):
   - For request-specific errors (invalid params, method not found)
   - Additional context: method_, request_id_

5. Include <stdexcept>, <string>, <optional>, <map>

6. Namespace: mcpp::util

Follow rust-sdk error pattern from crates/rmcp/src/error.rs.
  </action>
  <verify>
grep -q "class ServiceError" src/mcpp/util/error.h && \
grep -q "class TransportError" src/mcpp/util/error.h && \
grep -q "class ProtocolError" src/mcpp/util/error.h && \
grep -q "class RequestError" src/mcpp/util/error.h && \
grep -q "std::runtime_error" src/mcpp/util/error.h
  </verify>
  <done>
Error hierarchy provides:
- ServiceError base with message, code, and context
- Specialized error types for each layer
- Context preservation for debugging
- std::exception compatible for catch blocks
  </done>
</task>

<task type="auto">
  <name>Create retry policy with backoff strategies</name>
  <files>src/mcpp/util/retry.h</files>
  <action>
Create src/mcpp/util/retry.h with:

1. RetryPolicy<T> template interface:
   - virtual std::chrono::milliseconds next_delay(int attempt) const = 0
   - virtual bool should_retry(const std::exception& e) const = 0
   - virtual ~RetryPolicy() = default

2. ExponentialBackoff policy:
   Members:
   - double initial_delay_ = 1000 (1 second)
   - double multiplier_ = 2.0
   - double max_delay_ = 30000 (30 seconds)

   Methods:
   - std::chrono::milliseconds next_delay(int attempt) const override
   - bool should_retry(const std::exception& e) const override (default: true for transient errors)

3. retry_with_backoff template function:
   ```cpp
   template<typename T>
   Result<T> retry_with_backoff(
       std::function<Result<T>()> fn,
       const RetryPolicy<T>& policy,
       int max_attempts = 3
   )
   ```
   - Loop max_attempts times
   - Call fn(), return result on success
   - On exception: check should_retry, sleep via next_delay, retry
   - Return last error if all attempts fail

4. Include <chrono>, <functional>, <exception>, <thread>, <cmath>
5. Include mcpp/util/error.h for error types

6. Namespace: mcpp::util

Follow gopher-mcp retry pattern from sdk/go/src/filters/retry.go.
  </action>
  <verify>
grep -q "class RetryPolicy" src/mcpp/util/retry.h && \
grep -q "class ExponentialBackoff" src/mcpp/util/retry.h && \
grep -q "retry_with_backoff" src/mcpp/util/retry.h && \
grep -q "next_delay" src/mcpp/util/retry.h
  </verify>
  <done>
Retry utilities provide:
- Pluggable retry policy interface
- Exponential backoff with configurable parameters
- Automatic retry with sleep between attempts
- Transient error detection
  </done>
</task>

<task type="auto">
  <name>Update CMakeLists.txt with new headers</name>
  <files>CMakeLists.txt</files>
  <action>
Update CMakeLists.txt:

1. Add new util headers to MCPP_PUBLIC_HEADERS:
   - api/service.h
   - api/role.h
   - api/peer.h
   - api/running_service.h
   - api/context.h
   - util/logger.h
   - util/pagination.h
   - util/error.h
   - util/retry.h

2. Add util/logger.cpp to MCPP_SOURCES (if not header-only)

3. Ensure headers are grouped logically:
   - Core headers (already present)
   - Client headers (already present)
   - Server headers (already present)
   - API headers (new: src/mcpp/api/*.h)
   - Util headers (new: src/mcpp/util/*.h)

4. Add find_package(spdlog) if needed, with fallback to internal stub

5. Verify alphabetical ordering within groups

Follow existing CMakeLists.txt structure from Phase 3 (03-07-PLAN.md).
  </action>
  <verify>
grep -q "api/service.h" CMakeLists.txt && \
grep -q "api/role.h" CMakeLists.txt && \
grep -q "api/peer.h" CMakeLists.txt && \
grep -q "api/running_service.h" CMakeLists.txt && \
grep -q "api/context.h" CMakeLists.txt && \
grep -q "util/logger.h" CMakeLists.txt && \
grep -q "util/pagination.h" CMakeLists.txt && \
grep -q "util/error.h" CMakeLists.txt && \
grep -q "util/retry.h" CMakeLists.txt
  </verify>
  <done>
CMakeLists.txt includes:
- All new API headers in public headers list
- All new util headers in public headers list
- logger.cpp in sources if applicable
- spdlog dependency with fallback
  </done>
</task>

</tasks>

<verification>
1. list_all compiles with lambda returning PaginatedResult
2. Error types can be caught as std::exception
3. ExponentialBackoff produces correct delay sequence (1s, 2s, 4s, 8s...)
4. retry_with_backoff retries on failure, returns success on first success
5. CMakeLists.txt lists all new headers for installation
</verification>

<success_criteria>
1. list_all eliminates manual cursor pagination boilerplate
2. ServiceError hierarchy enables structured error handling
3. RetryPolicy interface allows pluggable backoff strategies
4. ExponentialBackoff implements standard exponential backoff
5. All new headers are exported for library consumers
</success_criteria>

<output>
After completion, create `.planning/phases/06-high-level-api/06-04-SUMMARY.md` with:
- Tech stack added: Pagination helpers, error hierarchy, retry strategies
- Patterns established: Result-based error handling, pluggable retry policies
- Key files: src/mcpp/util/pagination.h, src/mcpp/util/error.h, src/mcpp/util/retry.h
- Integration: CMakeLists.txt updated for all new headers
</output>

---
phase: 06-high-level-api
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/mcpp/api/running_service.h
  - src/mcpp/api/peer.h
  - src/mcpp/api/service.h
autonomous: true

must_haves:
  truths:
    - "RunningService provides RAII wrapper for background service lifecycle"
    - "Service can be started with cancellation token support"
    - "Background thread joins automatically on destruction"
    - "Peer methods send requests via transport-agnostic message passing"
  artifacts:
    - path: "src/mcpp/api/running_service.h"
      provides: "RunningService RAII wrapper"
      exports: ["template<ServiceRole Role, Service<Role> S> class RunningService"]
    - path: "src/mcpp/api/peer.h"
      provides: "Enhanced Peer with message channel"
      exports: ["Peer::send_request", "Peer::send_notification"]
  key_links:
    - from: "src/mcpp/api/running_service.h"
      to: "src/mcpp/api/service.h"
      via: "include"
      pattern: "#include.*service.h"
    - from: "src/mcpp/api/running_service.h"
      to: "src/mcpp/api/peer.h"
      via: "include"
      pattern: "#include.*peer.h"
    - from: "src/mcpp/api/peer.h"
      to: "src/mcpp/client/cancellation.h"
      via: "include"
      pattern: "#include.*cancellation.h"
---

<objective>
RAII-based service lifecycle management with RunningService wrapper and message-passing Peer implementation.

Purpose: Provide RAII-guaranteed cleanup for background service threads and implement message passing between API calls and the event loop. This enables safe service ownership with automatic cleanup and transport-agnostic communication patterns following rust-sdk's RunningService pattern.

Output: RunningService RAII wrapper with std::jthread integration and Peer with message channel for thread-safe communication.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-high-level-api/06-CONTEXT.md
@.planning/phases/06-high-level-api/06-RESEARCH.md
@.planning/phases/06-high-level-api/06-01-SUMMARY.md
@thirdparty/rust-sdk/crates/rmcp/src/service.rs
@src/mcpp/client.h
@src/mcpp/client/cancellation.h
@src/mcpp/transport/transport.h
@src/mcpp/api/service.h
@src/mcpp/api/role.h
@src/mcpp/api/peer.h
</context>

<tasks>

<task type="auto">
  <name>Implement message channel for Peer communication</name>
  <files>src/mcpp/api/peer.h</files>
  <action>
Enhance src/mcpp/api/peer.h with message passing infrastructure:

1. Add message types (within Peer or as nested types):
   - struct RequestMessage { RequestId id; std::string method; JsonValue params; std::function<void(JsonValue)> on_success; std::function<void(JsonRpcError)> on_error; }
   - struct NotificationMessage { std::string method; JsonValue params; }

2. Add message channel to Peer:
   - Use thread-safe queue (mpsc pattern - single sender, single receiver)
   - std::queue<std::variant<RequestMessage, NotificationMessage>> with std::mutex protection
   - Condition variable for blocking wait in event loop

3. Implement Peer methods:
   - send_request: Push request to queue, return std::future<JsonValue>
   - send_notification: Push notification to queue
   - process_messages(): Process pending messages (called by event loop)

4. Include <future>, <variant>, <condition_variable>
5. Use std::shared_ptr<promise> pattern for future creation (follow client/future_wrapper.h pattern)

Follow gopher-mcp channel patterns from sdk/go/src/core/chain.go.

Note: Keep transport integration separate - Peer focuses on message passing only.
  </action>
  <verify>
grep -q "RequestMessage\|NotificationMessage" src/mcpp/api/peer.h && \
grep -q "send_request" src/mcpp/api/peer.h && \
grep -q "send_notification" src/mcpp/api/peer.h && \
grep -q "std::variant" src/mcpp/api/peer.h
  </verify>
  <done>
Peer has message queue with:
- Thread-safe push operations for requests/notifications
- Future-based response handling
- Condition variable for event loop blocking
  </done>
</task>

<task type="auto">
  <name>Create RunningService RAII wrapper</name>
  <files>src/mcpp/api/running_service.h</files>
  <action>
Create src/mcpp/api/running_service.h with:

1. RunningService<ServiceRole Role, Service<Role> S> class:
   Members:
   - std::shared_ptr<S> service_ (keeps service alive)
   - Peer<Role> peer_
   - std::optional<std::jthread> handle_ (C++20 RAII thread)
   - std::stop_source stop_source_ (for cancellation)

   Methods:
   - Constructor: Takes shared_ptr<S>, optional transport, starts event loop
   - Destructor: Logs warning if not explicitly closed, stops thread via jthread
   - close_with_timeout(std::chrono::milliseconds): Request stop, join with timeout
   - operator->(): Returns pointer to peer for convenient access
   - is_running(): Check if event loop is active

2. Event loop function:
   - Runs in jthread, checks stop_token periodically
   - Calls peer_.process_messages() in loop
   - Calls service->handle_request/handle_notification for messages

3. Include:
   - mcpp/api/service.h, mcpp/api/role.h, mcpp/api/peer.h
   - <jthread> (C++20), <stop_token>
   - <optional>, <memory>, <chrono>

4. Namespace: mcpp::api

Follow rust-sdk RunningService pattern from service.rs lines 434-548.

Note: This is header-only template - no .cpp file needed.
  </action>
  <verify>
grep -q "class RunningService" src/mcpp/api/running_service.h && \
grep -q "std::jthread" src/mcpp/api/running_service.h && \
grep -q "close_with_timeout" src/mcpp/api/running_service.h && \
grep -q "operator->" src/mcpp/api/running_service.h
  </verify>
  <done>
RunningService provides:
- RAII thread ownership via std::jthread
- Automatic cleanup on destruction
- Timeout-based graceful shutdown
- Convenient access to Peer via operator->
  </done>
</task>

<task type="auto">
  <name>Refine Service trait with Role-specific types</name>
  <files>src/mcpp/api/service.h</files>
  <action>
Update src/mcpp/api/service.h to define Role-specific type aliases:

1. Add nested type definitions for each Role:
   For RoleClient:
   - using PeerReq = JsonValue;  // Request from server
   - using PeerNot = JsonValue;  // Notification from server
   - using Info = ClientInfo;    // Client implementation info

   For RoleServer:
   - using PeerReq = JsonValue;  // Request from client
   - using PeerNot = JsonValue;  // Notification from client
   - using Info = ServerInfo;    // Server implementation info

2. Add struct ClientInfo and ServerInfo:
   - std::string name, version
   - to_json() conversion method

3. Update Service interface:
   - Use Role::PeerReq, Role::PeerNot, Role::Info in method signatures
   - Remove placeholder types

4. Add RequestContext and NotificationContext stubs:
   - Will be enhanced in 06-03 with actual context data

5. Include mcpp/protocol/types.h for Implementation type

Follow rust-sdk type specialization pattern from service/client.rs and service/server.rs.
  </action>
  <verify>
grep -q "struct ClientInfo" src/mcpp/api/service.h && \
grep -q "struct ServerInfo" src/mcpp/api/service.h && \
grep -q "using PeerReq" src/mcpp/api/service.h && \
grep -q "using.*::Info" src/mcpp/api/service.h
  </verify>
  <done>
Service trait has:
- Role-specific type aliases defined
- ClientInfo/ServerInfo structs for role information
- Updated method signatures using Role types
  </done>
</task>

</tasks>

<verification>
1. RunningService compiles with test Service implementation
2. std::jthread joins correctly on destruction
3. stop_token propagation works (event loop exits on cancellation)
4. Peer message queue handles concurrent push/pop operations
5. Future/promise pattern correctly returns responses
</verification>

<success_criteria>
1. RunningService owns service lifecycle with RAII guarantees
2. Event loop runs in background thread, processes messages
3. Graceful shutdown with timeout support
4. Peer message passing is thread-safe
5. Service trait is complete with Role-specific types
</success_criteria>

<output>
After completion, create `.planning/phases/06-high-level-api/06-02-SUMMARY.md` with:
- Tech stack added: std::jthread, std::stop_token, message passing queue
- Patterns established: RAII service ownership, event loop pattern, future-based responses
- Key files: src/mcpp/api/running_service.h (enhanced peer.h, service.h)
- Integration: C++20 jthread for automatic thread cleanup
</output>

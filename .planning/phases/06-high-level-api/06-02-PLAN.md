---
phase: 06-high-level-api
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/mcpp/api/running_service.h
  - src/mcpp/api/peer.h
  - src/mcpp/server/request_context.h
autonomous: true

must_haves:
  truths:
    - "RunningService provides RAII wrapper for background service lifecycle"
    - "Service can be started with cancellation token support"
    - "Background thread joins automatically on destruction"
    - "Peer methods send requests via transport-agnostic message passing"
    - "Timeout clock resets on progress notification (UTIL-02)"
  artifacts:
    - path: "src/mcpp/api/running_service.h"
      provides: "RunningService RAII wrapper"
      exports: ["template<ServiceRole Role, Service<Role> S> class RunningService"]
    - path: "src/mcpp/api/peer.h"
      provides: "Enhanced Peer with message channel"
      exports: ["Peer::send_request", "Peer::send_notification"]
    - path: "src/mcpp/server/request_context.h"
      provides: "RequestContext with timeout reset on progress"
      exports: ["class RequestContext", "reset_timeout_on_progress()"]
  key_links:
    - from: "src/mcpp/api/running_service.h"
      to: "src/mcpp/api/service.h"
      via: "include"
      pattern: "#include.*service.h"
    - from: "src/mcpp/api/running_service.h"
      to: "src/mcpp/api/peer.h"
      via: "include"
      pattern: "#include.*peer.h"
    - from: "src/mcpp/api/peer.h"
      to: "src/mcpp/client/cancellation.h"
      via: "include"
      pattern: "#include.*cancellation.h"
    - from: "src/mcpp/server/request_context.h"
      to: "src/mcpp/protocol/types.h"
      via: "include"
      pattern: "#include.*types.h"
---

<objective>
RAII-based service lifecycle management with RunningService wrapper and message-passing Peer implementation.

Purpose: Provide RAII-guaranteed cleanup for background service threads and implement message passing between API calls and the event loop. This enables safe service ownership with automatic cleanup and transport-agnostic communication patterns following rust-sdk's RunningService pattern.

Output: RunningService RAII wrapper with std::jthread integration and Peer with message channel for thread-safe communication.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-high-level-api/06-CONTEXT.md
@.planning/phases/06-high-level-api/06-RESEARCH.md
@.planning/phases/06-high-level-api/06-01-SUMMARY.md
@thirdparty/rust-sdk/crates/rmcp/src/service.rs
@src/mcpp/client.h
@src/mcpp/client/cancellation.h
@src/mcpp/transport/transport.h
@src/mcpp/api/service.h
@src/mcpp/api/role.h
@src/mcpp/api/peer.h
</context>

<tasks>

<task type="auto">
  <name>Implement message channel for Peer communication</name>
  <files>src/mcpp/api/peer.h</files>
  <action>
Enhance src/mcpp/api/peer.h with message passing infrastructure:

1. Add message types (within Peer or as nested types):
   - struct RequestMessage { RequestId id; std::string method; JsonValue params; std::function<void(JsonValue)> on_success; std::function<void(JsonRpcError)> on_error; }
   - struct NotificationMessage { std::string method; JsonValue params; }

2. Add message channel to Peer:
   - Use thread-safe queue (mpsc pattern - single sender, single receiver)
   - std::queue<std::variant<RequestMessage, NotificationMessage>> with std::mutex protection
   - Condition variable for blocking wait in event loop

3. Implement Peer methods:
   - send_request: Push request to queue, return std::future<JsonValue>
   - send_notification: Push notification to queue
   - process_messages(): Process pending messages (called by event loop)

4. Include <future>, <variant>, <condition_variable>
5. Use std::shared_ptr<promise> pattern for future creation (follow client/future_wrapper.h pattern)

Follow gopher-mcp channel patterns from sdk/go/src/core/chain.go.

Note: Keep transport integration separate - Peer focuses on message passing only.
  </action>
  <verify>
grep -q "RequestMessage\|NotificationMessage" src/mcpp/api/peer.h && \
grep -q "send_request" src/mcpp/api/peer.h && \
grep -q "send_notification" src/mcpp/api/peer.h && \
grep -q "std::variant" src/mcpp/api/peer.h
  </verify>
  <done>
Peer has message queue with:
- Thread-safe push operations for requests/notifications
- Future-based response handling
- Condition variable for event loop blocking
  </done>
</task>

<task type="auto">
  <name>Create RunningService RAII wrapper</name>
  <files>src/mcpp/api/running_service.h</files>
  <action>
Create src/mcpp/api/running_service.h with:

1. RunningService<ServiceRole Role, Service<Role> S> class:
   Members:
   - std::shared_ptr<S> service_ (keeps service alive)
   - Peer<Role> peer_
   - std::optional<std::jthread> handle_ (C++20 RAII thread)
   - std::stop_source stop_source_ (for cancellation)

   Methods:
   - Constructor: Takes shared_ptr<S>, optional transport, starts event loop
   - Destructor: Logs warning if not explicitly closed, stops thread via jthread
   - close_with_timeout(std::chrono::milliseconds): Request stop, join with timeout
   - operator->(): Returns pointer to peer for convenient access
   - is_running(): Check if event loop is active

2. Event loop function:
   - Runs in jthread, checks stop_token periodically
   - Calls peer_.process_messages() in loop
   - Calls service->handle_request/handle_notification for messages

3. Include:
   - mcpp/api/service.h, mcpp/api/role.h, mcpp/api/peer.h
   - <jthread> (C++20), <stop_token>
   - <optional>, <memory>, <chrono>

4. Namespace: mcpp::api

Follow rust-sdk RunningService pattern from service.rs lines 434-548.

Note: This is header-only template - no .cpp file needed.
  </action>
  <verify>
grep -q "class RunningService" src/mcpp/api/running_service.h && \
grep -q "std::jthread" src/mcpp/api/running_service.h && \
grep -q "close_with_timeout" src/mcpp/api/running_service.h && \
grep -q "operator->" src/mcpp/api/running_service.h
  </verify>
  <done>
RunningService provides:
- RAII thread ownership via std::jthread
- Automatic cleanup on destruction
- Timeout-based graceful shutdown
- Convenient access to Peer via operator->
  </done>
</task>

<task type="auto">
  <name>Add timeout reset on progress notification (UTIL-02)</name>
  <files>src/mcpp/server/request_context.h</files>
  <action>
Update src/mcpp/server/request_context.h to add timeout reset on progress notification:

UTIL-02: Progress notifications should reset the timeout clock to prevent long-running operations from timing out.

1. Add timeout tracking to RequestContext:
   - std::chrono::steady_clock::time_point deadline_
   - std::chrono::milliseconds default_timeout_ (default: 5 minutes)
   - std::mutex for thread-safe deadline access

2. Add reset_timeout_on_progress() method:
   - Resets deadline_ to now + default_timeout_
   - Thread-safe via mutex lock
   - Called when progress notification with matching progress_token is received

3. Update timeout checking logic:
   - is_timeout_expired() returns true if steady_clock::now() > deadline_
   - Called by event loop before processing each message
   - Resets deadline when progress notification arrives

4. Integration with message passing:
   - When RunningService receives notifications/progress with a progress_token
   - Find matching RequestContext by progress_token
   - Call reset_timeout_on_progress() on that context

5. Include <chrono>, <mutex>
6. Namespace: mcpp::server

Follow rust-sdk timeout reset pattern from service/server.rs (progress handling).

Note: This handles the MCP spec requirement where long-running operations use progress notifications to keep the request alive.
  </action>
  <verify>
grep -q "reset_timeout_on_progress\|reset.*timeout" src/mcpp/server/request_context.h && \
grep -q "deadline_\|timeout" src/mcpp/server/request_context.h && \
grep -q "progress_token" src/mcpp/server/request_context.h
  </verify>
  <done>
RequestContext provides:
- Timeout tracking with deadline_
- reset_timeout_on_progress() method to reset the clock
- Thread-safe deadline access via mutex
- Integration with progress token matching
- UTIL-02 satisfied: progress notifications reset request timeout
  </done>
</task>

</tasks>

<verification>
1. RunningService compiles with test Service implementation
2. std::jthread joins correctly on destruction
3. stop_token propagation works (event loop exits on cancellation)
4. Peer message queue handles concurrent push/pop operations
5. Future/promise pattern correctly returns responses
6. Timeout resets when progress notification is received
</verification>

<success_criteria>
1. RunningService owns service lifecycle with RAII guarantees
2. Event loop runs in background thread, processes messages
3. Graceful shutdown with timeout support
4. Peer message passing is thread-safe
5. Progress notifications reset request timeout clock (UTIL-02)
</success_criteria>

<output>
After completion, create `.planning/phases/06-high-level-api/06-02-SUMMARY.md` with:
- Tech stack added: std::jthread, std::stop_token, message passing queue
- Patterns established: RAII service ownership, event loop pattern, future-based responses
- Key files: src/mcpp/api/running_service.h, src/mcpp/api/peer.h (enhanced request_context.h)
- UTIL-02 satisfied: progress notifications reset timeout clock
- Integration: C++20 jthread for automatic thread cleanup
</output>

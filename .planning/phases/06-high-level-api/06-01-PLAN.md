---
phase: 06-high-level-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/api/service.h
  - src/mcpp/api/role.h
  - src/mcpp/api/peer.h
autonomous: true

must_haves:
  truths:
    - "Role-based type safety distinguishes client and server APIs at compile time"
    - "Service trait abstraction provides polymorphic handler interface"
    - "Peer template encapsulates connection state with thread-safe access"
    - "Atomic ID provider generates request IDs without locks"
  artifacts:
    - path: "src/mcpp/api/role.h"
      provides: "Role marker types (RoleClient, RoleServer)"
      exports: ["struct RoleClient", "struct RoleServer", "concept ServiceRole"]
    - path: "src/mcpp/api/service.h"
      provides: "Service trait abstraction"
      exports: ["template<ServiceRole Role> class Service"]
    - path: "src/mcpp/api/peer.h"
      provides: "Peer<Role> for connection handling"
      exports: ["template<ServiceRole Role> class Peer", "class AtomicRequestIdProvider"]
  key_links:
    - from: "src/mcpp/api/service.h"
      to: "src/mcpp/api/role.h"
      via: "include"
      pattern: "#include.*role.h"
    - from: "src/mcpp/api/peer.h"
      to: "src/mcpp/api/role.h"
      via: "include"
      pattern: "#include.*role.h"
    - from: "src/mcpp/api/peer.h"
      to: "src/mcpp/api/service.h"
      via: "template parameter"
      pattern: "Service<Role>"
---

<objective>
High-level API foundation with role-based type safety, Service trait abstraction, and thread-safe Peer connection handling.

Purpose: Establish the architectural foundation for type-safe, RAII-based high-level API wrappers following rust-sdk patterns. This provides compile-time role distinction, polymorphic handler interfaces, and thread-safe connection state management that all higher-level wrappers will build upon.

Output: Role marker types, Service trait abstraction, Peer template for connection handling, and AtomicRequestIdProvider for lock-free ID generation.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-high-level-api/06-CONTEXT.md
@.planning/phases/06-high-level-api/06-RESEARCH.md
@thirdparty/rust-sdk/crates/rmcp/src/service.rs
@src/mcpp/client.h
@src/mcpp/client/cancellation.h
@src/mcpp/protocol/types.h
</context>

<tasks>

<task type="auto">
  <name>Create role marker types and ServiceRole concept</name>
  <files>src/mcpp/api/role.h</files>
  <action>
Create src/mcpp/api/role.h with:

1. Empty marker types RoleClient and RoleServer for compile-time role distinction
2. ServiceRole concept requiring std::same_as<Role, RoleClient> or std::same_as<Role, RoleServer>
3. Add MIT license header following existing project convention
4. Namespace: mcpp::api

Follow rust-sdk pattern from service.rs lines 1-50 (Role types).

Do NOT implement any logic - these are marker types only.
  </action>
  <verify>
grep -q "struct RoleClient" src/mcpp/api/role.h && \
grep -q "struct RoleServer" src/mcpp/api/role.h && \
grep -q "concept ServiceRole" src/mcpp/api/role.h
  </verify>
  <done>
File compiles successfully with:
- RoleClient and RoleServer empty structs defined
- ServiceRole concept validates role types
- MIT license header present
  </done>
</task>

<task type="auto">
  <name>Create Service trait abstraction</name>
  <files>src/mcpp/api/service.h</files>
  <action>
Create src/mcpp/api/service.h with:

1. Template class Service<ServiceRole Role> as abstract interface
2. Pure virtual methods:
   - void handle_request(const typename Role::PeerReq& request, RequestContext& ctx) = 0
   - void handle_notification(const typename Role::PeerNot& notification, NotificationContext& ctx) = 0
   - typename Role::Info get_info() const = 0
3. Virtual destructor ~Service() = default
4. Include mcpp/api/role.h for ServiceRole concept
5. Namespace: mcpp::api

Follow rust-sdk pattern from service.rs lines 50-150 (Service trait).

Note: Use placeholder types for Role::PeerReq, Role::PeerNot, Role::Info - these will be refined in later plans.
  </action>
  <verify>
grep -q "template<ServiceRole Role>" src/mcpp/api/service.h && \
grep -q "class Service" src/mcpp/api/service.h && \
grep -q "virtual.*handle_request" src/mcpp/api/service.h && \
grep -q "virtual.*handle_notification" src/mcpp/api/service.h
  </verify>
  <done>
File compiles successfully with:
- Service<Role> template class defined
- Pure virtual handler methods declared
- Virtual destructor present
  </done>
</task>

<task type="auto">
  <name>Create AtomicRequestIdProvider and Peer template</name>
  <files>src/mcpp/api/peer.h</files>
  <action>
Create src/mcpp/api/peer.h with:

1. AtomicRequestIdProvider class:
   - std::atomic<uint32_t> next_id_{1} as private member
   - uint32_t next_id() noexcept method using fetch_add with memory_order_relaxed
   - Non-copyable, non-movable

2. Peer<ServiceRole Role> template class:
   - std::shared_ptr<AtomicRequestIdProvider> id_provider_
   - std::shared_mutex for thread-safe peer state
   - Thread-safe send_request() and send_notification() methods (stub implementations)
   - Optional peer_info() accessor with shared_lock

3. Include mcpp/api/role.h for Role types
4. Include <atomic>, <shared_mutex>, <memory>
5. Namespace: mcpp::api

Follow rust-sdk pattern from service.rs lines 312-347 (Peer state) and AtomicU32Provider pattern.

Peer methods should be stub implementations returning std::future or using std::function - full implementation comes in 06-02.
  </action>
  <verify>
grep -q "class AtomicRequestIdProvider" src/mcpp/api/peer.h && \
grep -q "std::atomic<uint32_t>" src/mcpp/api/peer.h && \
grep -q "template<ServiceRole Role>" src/mcpp/api/peer.h && \
grep -q "class Peer" src/mcpp/api/peer.h && \
grep -q "fetch_add" src/mcpp/api/peer.h
  </verify>
  <done>
File compiles successfully with:
- AtomicRequestIdProvider generates sequential IDs
- Peer<Role> template defined with mutex-protected state
- std::shared_mutex for multi-reader, single-writer access
  </done>
</task>

</tasks>

<verification>
1. All three new headers compile without errors: g++ -std=c++20 -fsyntax-only src/mcpp/api/*.h
2. Static assertions verify ServiceRole concept: static_assert(ServiceRole<RoleClient>)
3. AtomicRequestIdProvider generates unique IDs in multi-threaded test
4. No circular dependencies between headers
</verification>

<success_criteria>
1. Role marker types enable compile-time role distinction
2. Service trait defines polymorphic handler interface
3. Peer template provides thread-safe connection state foundation
4. AtomicRequestIdProvider generates lock-free sequential IDs
5. Headers are self-documenting with doxygen comments
</success_criteria>

<output>
After completion, create `.planning/phases/06-high-level-api/06-01-SUMMARY.md` with:
- Tech stack added: C++20 concepts, std::atomic, std::shared_mutex
- Patterns established: Role-based typing, Service trait, Peer state management
- Key files: src/mcpp/api/role.h, src/mcpp/api/service.h, src/mcpp/api/peer.h
- Decisions: Placeholder types for Role-specific types (refined in 06-02)
</output>

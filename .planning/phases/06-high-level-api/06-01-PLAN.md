---
phase: 06-high-level-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/api/service.h
  - src/mcpp/api/role.h
  - src/mcpp/api/peer.h
  - src/mcpp/util/atomic_id.h
autonomous: true

must_haves:
  truths:
    - "Role-based type safety distinguishes client and server APIs at compile time"
    - "Service trait abstraction provides polymorphic handler interface"
    - "Peer template encapsulates connection state with thread-safe access"
    - "Atomic ID provider generates request IDs without locks"
    - "ClientInfo/ServerInfo include experimental capabilities field (UTIL-03)"
  artifacts:
    - path: "src/mcpp/api/role.h"
      provides: "Role marker types (RoleClient, RoleServer)"
      exports: ["struct RoleClient", "struct RoleServer", "concept ServiceRole"]
    - path: "src/mcpp/api/service.h"
      provides: "Service trait abstraction with experimental capabilities"
      exports: ["template<ServiceRole Role> class Service", "struct ClientInfo", "struct ServerInfo"]
    - path: "src/mcpp/api/peer.h"
      provides: "Peer<Role> for connection handling"
      exports: ["template<ServiceRole Role> class Peer"]
    - path: "src/mcpp/util/atomic_id.h"
      provides: "Lock-free atomic ID provider"
      exports: ["class AtomicRequestIdProvider"]
  key_links:
    - from: "src/mcpp/api/service.h"
      to: "src/mcpp/api/role.h"
      via: "include"
      pattern: "#include.*role.h"
    - from: "src/mcpp/api/peer.h"
      to: "src/mcpp/api/role.h"
      via: "include"
      pattern: "#include.*role.h"
    - from: "src/mcpp/api/peer.h"
      to: "src/mcpp/api/service.h"
      via: "template parameter"
      pattern: "Service<Role>"
    - from: "src/mcpp/api/peer.h"
      to: "src/mcpp/util/atomic_id.h"
      via: "include"
      pattern: "#include.*atomic_id.h"
    - from: "src/mcpp/api/service.h"
      to: "src/mcpp/util/atomic_id.h"
      via: "include"
      pattern: "#include.*atomic_id.h"
---

<objective>
High-level API foundation with role-based type safety, Service trait abstraction, and thread-safe Peer connection handling.

Purpose: Establish the architectural foundation for type-safe, RAII-based high-level API wrappers following rust-sdk patterns. This provides compile-time role distinction, polymorphic handler interfaces, and thread-safe connection state management that all higher-level wrappers will build upon.

Output: Role marker types, Service trait abstraction, Peer template for connection handling, and AtomicRequestIdProvider for lock-free ID generation.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-high-level-api/06-CONTEXT.md
@.planning/phases/06-high-level-api/06-RESEARCH.md
@thirdparty/rust-sdk/crates/rmcp/src/service.rs
@src/mcpp/client.h
@src/mcpp/client/cancellation.h
@src/mcpp/protocol/types.h
</context>

<tasks>

<task type="auto">
  <name>Create role marker types and ServiceRole concept</name>
  <files>src/mcpp/api/role.h</files>
  <action>
Create src/mcpp/api/role.h with:

1. Empty marker types RoleClient and RoleServer for compile-time role distinction
2. ServiceRole concept requiring std::same_as<Role, RoleClient> or std::same_as<Role, RoleServer>
3. Add MIT license header following existing project convention
4. Namespace: mcpp::api

Follow rust-sdk pattern from service.rs lines 1-50 (Role types).

Do NOT implement any logic - these are marker types only.
  </action>
  <verify>
grep -q "struct RoleClient" src/mcpp/api/role.h && \
grep -q "struct RoleServer" src/mcpp/api/role.h && \
grep -q "concept ServiceRole" src/mcpp/api/role.h
  </verify>
  <done>
File compiles successfully with:
- RoleClient and RoleServer empty structs defined
- ServiceRole concept validates role types
- MIT license header present
  </done>
</task>

<task type="auto">
  <name>Create Service trait abstraction with experimental capabilities</name>
  <files>src/mcpp/api/service.h</files>
  <action>
Create src/mcpp/api/service.h with:

1. Template class Service<ServiceRole Role> as abstract interface:
   - Pure virtual methods:
     - void handle_request(const typename Role::PeerReq& request, RequestContext& ctx) = 0
     - void handle_notification(const typename Role::PeerNot& notification, NotificationContext& ctx) = 0
     - typename Role::Info get_info() const = 0
   - Virtual destructor ~Service() = default

2. Struct ClientInfo (for RoleClient):
   - std::string name, version
   - std::map<std::string, nlohmann::json> experimental (UTIL-03: custom feature negotiation)
   - to_json() conversion method

3. Struct ServerInfo (for RoleServer):
   - std::string name, version
   - std::map<std::string, nlohmann::json> experimental (UTIL-03: custom feature negotiation)
   - to_json() conversion method

4. Role-specific type aliases:
   - For RoleClient: using PeerReq = JsonValue, PeerNot = JsonValue, Info = ClientInfo
   - For RoleServer: using PeerReq = JsonValue, PeerNot = JsonValue, Info = ServerInfo

5. Include mcpp/api/role.h for ServiceRole concept
6. Include mcpp/util/atomic_id.h for AtomicRequestIdProvider (for reference in RequestContext)
7. Include <string>, <map>, <nlohmann/json.hpp>
8. Namespace: mcpp::api

Follow rust-sdk pattern from service.rs lines 50-150 (Service trait) and experimental capabilities from MCP spec.

UTIL-03: The experimental field allows custom feature negotiation beyond standard MCP capabilities.
  </action>
  <verify>
grep -q "template<ServiceRole Role>" src/mcpp/api/service.h && \
grep -q "class Service" src/mcpp/api/service.h && \
grep -q "virtual.*handle_request" src/mcpp/api/service.h && \
grep -q "virtual.*handle_notification" src/mcpp/api/service.h && \
grep -q "struct ClientInfo" src/mcpp/api/service.h && \
grep -q "struct ServerInfo" src/mcpp/api/service.h && \
grep -q "experimental" src/mcpp/api/service.h
  </verify>
  <done>
File compiles successfully with:
- Service<Role> template class defined
- Pure virtual handler methods declared
- Virtual destructor present
- ClientInfo/ServerInfo with experimental capabilities field
  </done>
</task>

<task type="auto">
  <name>Create AtomicRequestIdProvider utility</name>
  <files>src/mcpp/util/atomic_id.h</files>
  <action>
Create src/mcpp/util/atomic_id.h with:

1. AtomicRequestIdProvider class:
   - std::atomic<uint32_t> next_id_{1} as private member
   - uint32_t next_id() noexcept method using fetch_add with memory_order_relaxed
   - Non-copyable (=delete), non-movable (=delete)
   - Shared pointer constructor for sharing between Peer and RequestContext

2. Include <atomic>, <memory>
3. Namespace: mcpp::util

Follow rust-sdk AtomicU32Provider pattern from service.rs.

Note: This is a utility class used across the API for request ID generation.
  </action>
  <verify>
grep -q "class AtomicRequestIdProvider" src/mcpp/util/atomic_id.h && \
grep -q "std::atomic<uint32_t>" src/mcpp/util/atomic_id.h && \
grep -q "fetch_add" src/mcpp/util/atomic_id.h && \
grep -q "memory_order_relaxed" src/mcpp/util/atomic_id.h
  </verify>
  <done>
AtomicRequestIdProvider:
- Generates sequential IDs starting from 1
- Lock-free using std::atomic with relaxed memory ordering
- Non-copyable and non-movable for safe shared_ptr usage
  </done>
</task>

<task type="auto">
  <name>Create Peer template with thread-safe state</name>
  <files>src/mcpp/api/peer.h</files>
  <action>
Create src/mcpp/api/peer.h with:

1. Peer<ServiceRole Role> template class:
   - std::shared_ptr<util::AtomicRequestIdProvider> id_provider_
   - std::shared_mutex for thread-safe peer state
   - Thread-safe send_request() and send_notification() methods (stub implementations)
   - Optional peer_info() accessor with shared_lock

2. Include mcpp/api/role.h for Role types
3. Include mcpp/util/atomic_id.h for AtomicRequestIdProvider
4. Include <shared_mutex>, <memory>, <future>
5. Namespace: mcpp::api

Follow rust-sdk pattern from service.rs lines 312-347 (Peer state).

Peer methods should be stub implementations returning std::future or using std::function - full implementation comes in 06-02.
  </action>
  <verify>
grep -q "template<ServiceRole Role>" src/mcpp/api/peer.h && \
grep -q "class Peer" src/mcpp/api/peer.h && \
grep -q "std::shared_mutex" src/mcpp/api/peer.h && \
grep -q "send_request" src/mcpp/api/peer.h && \
grep -q "AtomicRequestIdProvider" src/mcpp/api/peer.h
  </verify>
  <done>
Peer template:
- Uses shared AtomicRequestIdProvider for ID generation
- Thread-safe state access via std::shared_mutex
- Stub methods for send_request/send_notification
- peer_info() accessor with shared_lock for reads
  </done>
</task>

</tasks>

<verification>
1. All new headers compile without errors: g++ -std=c++20 -fsyntax-only src/mcpp/api/*.h src/mcpp/util/atomic_id.h
2. Static assertions verify ServiceRole concept: static_assert(ServiceRole<RoleClient>)
3. AtomicRequestIdProvider generates unique IDs in multi-threaded test
4. No circular dependencies between headers
5. ClientInfo/ServerInfo contain experimental field for custom capabilities
</verification>

<success_criteria>
1. Role marker types enable compile-time role distinction
2. Service trait defines polymorphic handler interface with experimental capabilities
3. Peer template provides thread-safe connection state foundation
4. AtomicRequestIdProvider generates lock-free sequential IDs
5. Experimental capabilities field enables custom feature negotiation (UTIL-03)
6. Headers are self-documenting with doxygen comments
</success_criteria>

<output>
After completion, create `.planning/phases/06-high-level-api/06-01-SUMMARY.md` with:
- Tech stack added: C++20 concepts, std::atomic, std::shared_mutex
- Patterns established: Role-based typing, Service trait, Peer state management, experimental capabilities
- Key files: src/mcpp/api/role.h, src/mcpp/api/service.h, src/mcpp/api/peer.h, src/mcpp/util/atomic_id.h
- UTIL-03 satisfied: experimental field in ClientInfo/ServerInfo for custom feature negotiation
</output>

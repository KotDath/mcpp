---
phase: 06-high-level-api
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - src/mcpp/util/logger.h
  - src/mcpp/util/logger.cpp
  - src/mcpp/api/context.h
autonomous: true

must_haves:
  truths:
    - "Logger provides structured logging with level filtering (Trace/Debug/Info/Warn/Error)"
    - "Log messages support contextual key-value pairs for request tracking"
    - "Logging can be toggled at runtime without restart"
    - "RequestContext provides request-scoped context with thread-safe property access"
  artifacts:
    - path: "src/mcpp/util/logger.h"
      provides: "Structured logging interface"
      exports: ["class Logger", "enum class Level", "class Logger::Span"]
    - path: "src/mcpp/util/logger.cpp"
      provides: "Logger implementation with spdlog backend"
      contains: "spdlog integration"
    - path: "src/mcpp/api/context.h"
      provides: "RequestContext and NotificationContext for request metadata"
      exports: ["class RequestContext", "class NotificationContext"]
  key_links:
    - from: "src/mcpp/util/logger.cpp"
      to: "thirdparty/spdlog"
      via: "external dependency"
      pattern: "#include.*spdlog"
    - from: "src/mcpp/api/context.h"
      to: "src/mcpp/util/logger.h"
      via: "include"
      pattern: "#include.*logger.h"
    - from: "src/mcpp/api/context.h"
      to: "src/mcpp/api/service.h"
      via: "forward declaration"
      pattern: "class.*Service"
---

<objective>
Structured logging integration with spdlog backend and request-scoped context for high-level API.

Purpose: Provide production-ready logging with level filtering, contextual key-value pairs, and request-scoped context propagation. This enables debugging, monitoring, and observability for high-level API operations following rust-sdk's tracing pattern and gopher-mcp's LoggingFilter.

Output: Logger class with spdlog backend, Span for request tracking, and RequestContext/NotificationContext for request metadata.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-high-level-api/06-CONTEXT.md
@.planning/phases/06-high-level-api/06-RESEARCH.md
@.planning/phases/06-high-level-api/06-01-SUMMARY.md
@.planning/phases/06-high-level-api/06-02-SUMMARY.md
@thirdparty/rust-sdk/crates/rmcp/src/service.rs
@thirdparty/gopher-mcp/sdk/go/src/filters/logging.go
@src/mcpp/async/callbacks.h
@src/mcpp/core/json_rpc.h
</context>

<tasks>

<task type="auto">
  <name>Create Logger interface with spdlog backend</name>
  <files>src/mcpp/util/logger.h, src/mcpp/util/logger.cpp</files>
  <action>
Create src/mcpp/util/logger.h and src/mcpp/util/logger.cpp with:

1. Logger class (header-only interface, separate implementation):
   Public interface:
   - enum class Level { Trace, Debug, Info, Warn, Error }
   - static Logger& global() - singleton accessor
   - void log(Level level, std::string_view message, const std::map<std::string, std::string>& context = {})
   - void set_level(Level level)
   - void enable_payload_logging(bool enable, size_t max_size = 1024)

2. Span class (nested in Logger):
   - Span(std::string_view name, std::map<std::string, std::string> context = {})
   - ~Span() auto-logs duration and context
   - void add_context(std::string_view key, std::string_view value)

3. Implementation details (.cpp):
   - Use spdlog as backend (check for SPDLOG_ACTIVE_LEVEL)
   - Thread-safe singleton pattern with std::call_once
   - Format logs with spdlog fmtlib: "[{}] {} - {}" with level, context, message
   - Payload logging: truncate JSON payloads at max_size to avoid log spam

4. Includes:
   - <string>, <string_view>, <map>, <chrono>
   - <mutex>, <optional>
   - spdlog headers (spdlog/spdlog.h, spdlog/fmt/ostr.h)

5. Namespace: mcpp::util

Follow rust-sdk tracing pattern and gopher-mcp LoggingFilter.

Note: Make spdlog optional - if not available, provide stub implementation logging to stderr.
  </action>
  <verify>
grep -q "class Logger" src/mcpp/util/logger.h && \
grep -q "enum class Level" src/mcpp/util/logger.h && \
grep -q "class Span" src/mcpp/util/logger.h && \
grep -q "spdlog" src/mcpp/util/logger.cpp
  </verify>
  <done>
Logger provides:
- Structured logging with level filtering
- Global singleton for application-wide logging
- Span for request duration tracking
- Optional spdlog backend with stderr fallback
  </done>
</task>

<task type="auto">
  <name>Create RequestContext and NotificationContext</name>
  <files>src/mcpp/api/context.h</files>
  <action>
Create src/mcpp/api/context.h with:

1. RequestContext class:
   Members:
   - std::string request_id_ (for tracking)
   - std::string method_ (RPC method name)
   - std::optional<std::string> progress_token_
   - std::shared_mutex for thread-safe property access
   - util::Logger::Span span_ (auto-logging)

   Methods:
   - RequestContext(std::string_view request_id, std::string_view method)
   - std::string request_id() const (shared_lock)
   - std::string method() const (shared_lock)
   - std::optional<std::string> progress_token() const
   - void set_progress_token(std::string_view token)
   - void add_context(std::string_view key, std::string_view value)

2. NotificationContext class (simpler, no ID):
   - Similar structure but without request_id
   - Has method_name and context map
   - util::Logger::Span span_

3. Include:
   - mcpp/util/logger.h for Span
   - <shared_mutex>, <map>, <string>, <optional>

4. Namespace: mcpp::api

Follow gopher-mcp ProcessingContext pattern from sdk/go/src/core/context.go.
  </action>
  <verify>
grep -q "class RequestContext" src/mcpp/api/context.h && \
grep -q "class NotificationContext" src/mcpp/api/context.h && \
grep -q "std::shared_mutex" src/mcpp/api/context.h && \
grep -q "Logger::Span" src/mcpp/api/context.h
  </verify>
  <done>
Context classes provide:
- Thread-safe property access via shared_mutex
- Request-scoped logging via Span
- Progress token tracking for notifications
- Context propagation for distributed tracing
  </done>
</task>

</tasks>

<verification>
1. Logger singleton is thread-safe (test concurrent log calls)
2. Span logs duration on destruction
3. Context classes allow concurrent reads via shared_lock
4. spdlog integration works when available, stderr fallback otherwise
5. Log level filtering takes effect at runtime
</verification>

<success_criteria>
1. Logger provides structured logging with contextual key-value pairs
2. Runtime toggle for log level and payload logging
3. RequestContext enables request tracking across async boundaries
4. Thread-safe context access for multi-threaded scenarios
5. Span automatically logs duration and context
</success_criteria>

<output>
After completion, create `.planning/phases/06-high-level-api/06-03-SUMMARY.md` with:
- Tech stack added: spdlog (optional), structured logging, request contexts
- Patterns established: Singleton logger, request-scoped contexts, span-based tracking
- Key files: src/mcpp/util/logger.h, src/mcpp/util/logger.cpp, src/mcpp/api/context.h
- Integration: spdlog backend with stderr fallback for portability
</output>

---
phase: 07-build-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CMakeLists.txt
  - cmake/mcppConfig.cmake.in
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Library consumer can build the project using CMake with C++20 standard on gcc-11/g++-11 or compatible"
    - "Library consumer can link against a static library target (mcpp_static)"
    - "Library consumer can link against a shared library target with proper versioning (libmcpp.so.0)"
    - "Library consumer can install the library using 'make install' or 'cmake --install'"
    - "Library consumer can find the installed package using 'find_package(mcpp)'"
  artifacts:
    - path: "CMakeLists.txt"
      provides: "Root CMake build configuration with static/shared library targets"
      contains: "add_library(mcpp_static", "add_library(mcpp_shared"
    - path: "cmake/mcppConfig.cmake.in"
      provides: "CMake package config template for find_package() support"
      contains: "include(CMakeFindDependencyMacro)"
  key_links:
    - from: "CMakeLists.txt"
      to: "MCPP_SOURCES"
      via: "add_library targets"
      pattern: "add_library\\(mcpp_\\w+\\s+\\$\\{MCPP_SOURCES\\}"
    - from: "install(TARGETS mcpp"
      to: "install(EXPORT mcppTargets"
      via: "CMake install rules"
      pattern: "install\\(EXPORT\\s+mcppTargets"
---

<objective>
Build CMake build system with both static and shared library targets, proper versioning (SONAME), package config for find_package(mcpp) support, and install rules.

Purpose: Deliver production-ready build infrastructure that allows consumers to build, link, and install the mcpp library using standard CMake workflows.

Output: Updated CMakeLists.txt with dual library targets, cmake/mcppConfig.cmake.in for package config, and working 'make install' with find_package() support.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-build-validation/07-CONTEXT.md
@.planning/phases/07-build-validation/07-RESEARCH.md
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Create cmake directory and package config template</name>
  <files>cmake/mcppConfig.cmake.in</files>
  <action>
Create directory cmake/ and file cmake/mcppConfig.cmake.in with:

```cmake
@PACKAGE_INIT@

include(CMakeFindDependencyMacro)

# Find nlohmann_json dependency (assume it's installed or user provides it)
# For header-only, we just need to find the include path
find_dependency(nlohmann_json 3.11.0 REQUIRED)

# Include the targets file
include("${CMAKE_CURRENT_LIST_DIR}/mcppTargets.cmake")

# Create the mcpp::mcpp alias that points to the correct library type
# This is handled by the imported targets, but we set up a convenience alias
if(NOT TARGET mcpp::mcpp)
    if(TARGET mcpp::mcpp_shared)
        add_library(mcpp::mcpp ALIAS mcpp::mcpp_shared)
    elseif(TARGET mcpp::mcpp_static)
        add_library(mcpp::mcpp ALIAS mcpp::mcpp_static)
    endif()
endif()

check_required_components(mcpp)
```

Do NOT commit yet - wait for CMakeLists.txt updates.
  </action>
  <verify>File cmake/mcppConfig.cmake.in exists with valid CMake syntax</verify>
  <done>Package config template created with dependency finding and target alias setup</done>
</task>

<task type="auto">
  <name>Update CMakeLists.txt for dual library build</name>
  <files>CMakeLists.txt</files>
  <action>
Modify CMakeLists.txt to build both static and shared libraries:

1. After the MCPP_SOURCES definition (around line 102), change:
   - Remove the single `add_library(mcpp ${MCPP_SOURCES})` line
   - Replace with dual library targets:

```cmake
# Build both static and shared libraries
add_library(mcpp_static STATIC ${MCPP_SOURCES})
add_library(mcpp_shared SHARED ${MCPP_SOURCES})

# Common include directories for both libraries
target_include_directories(mcpp_static PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>
    $<INSTALL_INTERFACE:include>
)
target_include_directories(mcpp_shared PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>
    $<INSTALL_INTERFACE:include>
)

# Link nlohmann_json to both libraries
target_link_libraries(mcpp_static PUBLIC nlohmann_json::nlohmann_json)
target_link_libraries(mcpp_shared PUBLIC nlohmann_json::nlohmann_json)

# Set library properties
set_target_properties(mcpp_static PROPERTIES
    VERSION ${PROJECT_VERSION}
    OUTPUT_NAME mcpp
    ARCHIVE_OUTPUT_NAME mcpp
)

set_target_properties(mcpp_shared PROPERTIES
    VERSION ${PROJECT_VERSION}
    SOVERSION ${PROJECT_VERSION_MAJOR}
    OUTPUT_NAME mcpp
    LIBRARY_OUTPUT_NAME mcpp
    PUBLIC_HEADER "${MCPP_PUBLIC_HEADERS}"
)

# Apply warning flags to both libraries
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    target_compile_options(mcpp_static PRIVATE
        -Wall -Wextra -Wpedantic -Wno-unused-parameter
    )
    target_compile_options(mcpp_shared PRIVATE
        -Wall -Wextra -Wpedantic -Wno-unused-parameter
    )
endif()
```

2. Replace the entire install(TARGETS mcpp ...) block (around line 132-137) with:

```cmake
# Installation
include(GNUInstallDirs)
include(CMakePackageConfigHelpers)

# Generate version file
write_basic_package_version_file(
    "${CMAKE_CURRENT_BINARY_DIR}/mcppConfigVersion.cmake"
    VERSION ${PROJECT_VERSION}
    COMPATIBILITY SameMajorVersion
)

# Configure package config
configure_package_config_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/mcppConfig.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/mcppConfig.cmake"
    INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/mcpp
)

# Install both static and shared libraries
install(TARGETS mcpp_static mcpp_shared
    EXPORT mcppTargets
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/mcpp
    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)

# Install exported targets
install(EXPORT mcppTargets
    FILE mcppTargets.cmake
    NAMESPACE mcpp::
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/mcpp
)

# Install package config files
install(
    FILES
        "${CMAKE_CURRENT_BINARY_DIR}/mcppConfig.cmake"
        "${CMAKE_CURRENT_BINARY_DIR}/mcppConfigVersion.cmake"
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/mcpp
)
```

3. Fix the http_transport.cpp missing from MCPP_SOURCES:
   - Add after line 92 (after stdio_transport.cpp):
   ```cmake
   src/mcpp/transport/http_transport.cpp
   ```

Do NOT modify other sections. The Tests and Examples sections remain as-is.
  </action>
  <verify>
Run: cmake -B build && cmake --build build
Expected: No CMake errors, both libmcpp.a and libmcpp.so.0.1.0 are built in build/src/
  </verify>
  <done>
CMakeLists.txt builds both static and shared libraries with:
- libmcpp.a (static archive)
- libmcpp.so.0.1.0, libmcpp.so.0, libmcpp.so (shared with proper symlinks)
- Package config files generated
- Install rules configured
  </done>
</task>

<task type="auto">
  <name>Verify build and install workflow</name>
  <files>CMakeLists.txt, cmake/mcppConfig.cmake.in</files>
  <action>
Test the complete build and install workflow:

1. Clean build:
   ```bash
   rm -rf build
   cmake -B build -DCMAKE_BUILD_TYPE=Release
   cmake --build build
   ```

2. Verify both library types exist:
   ```bash
   ls -la build/src/libmcpp.*
   ls -la build/src/libmcpp.so*
   ```
   Expected: libmcpp.a and libmcpp.so* files

3. Test install to temporary location:
   ```bash
   cmake --install build --prefix /tmp/mcpp-test-install
   ```

4. Verify installed structure:
   ```bash
   ls -la /tmp/mcpp-test-install/lib/
   ls -la /tmp/mcpp-test-install/lib/cmake/mcpp/
   ls -la /tmp/mcpp-test-install/include/mcpp/
   ```

5. Clean up test install:
   ```bash
   rm -rf /tmp/mcpp-test-install
   ```

Do NOT commit anything - this is verification only.
  </action>
  <verify>
Build succeeds and install creates:
- /tmp/mcpp-test-install/lib/libmcpp.a
- /tmp/mcpp-test-install/lib/libmcpp.so.0.1.0 with symlinks
- /tmp/mcpp-test-install/lib/cmake/mcpp/mcppConfig.cmake
- /tmp/mcpp-test-install/lib/cmake/mcpp/mcppTargets.cmake
- /tmp/mcpp-test-install/include/mcpp/*.h (all public headers)
  </verify>
  <done>
Complete build and install workflow verified working for both library types
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. `cmake -B build && cmake --build build` succeeds without errors
2. Both libmcpp.a and libmcpp.so.0.1.0 are built in build/src/
3. `cmake --install build --prefix /tmp/test` installs all files correctly
4. Installed package config (mcppConfig.cmake, mcppTargets.cmake) allows find_package(mcpp)
5. BUILD-01 (CMake build system), BUILD-02 (static library), BUILD-03 (shared library with SONAME) requirements satisfied
</verification>

<success_criteria>
1. CMakeLists.txt builds both static (mcpp_static) and shared (mcpp_shared) library targets
2. Shared library has proper versioning: libmcpp.so -> libmcpp.so.0 -> libmcpp.so.0.1.0
3. `cmake --install` installs libraries, headers, and CMake config files to correct locations
4. find_package(mcpp) will work after installation (package config files are installable)
5. http_transport.cpp is included in MCPP_SOURCES (fixes the gap from research)
</success_criteria>

<output>
After completion, create `.planning/phases/07-build-validation/07-01-SUMMARY.md` with:
- Build system changes made
- Static/shared library configuration
- Package config setup
- Any issues encountered and resolutions
</output>

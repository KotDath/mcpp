---
phase: 07-build-validation
plan: 04
type: execute
wave: 2
depends_on: [07-02b]
files_modified:
  - tests/integration/test_client_server.cpp
  - examples/inspector_server.cpp
  - examples/CMakeLists.txt
  - tests/CMakeLists.txt
  - README.md
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Library consumer can build and run the example MCP server for Inspector testing"
    - "Library consumer can connect MCP Inspector to the example server"
    - "Integration tests validate end-to-end client-server communication"
    - "Example server demonstrates tools, resources, and prompts registration"
  artifacts:
    - path: "examples/inspector_server.cpp"
      provides: "Example MCP server for Inspector integration testing"
      min_lines: 100
    - path: "examples/CMakeLists.txt"
      provides: "Examples build configuration"
      contains: "add_executable"
    - path: "tests/integration/test_client_server.cpp"
      provides: "End-to-end client-server integration tests"
      contains: "TEST(ClientServerIntegration"
  key_links:
    - from: "examples/inspector_server.cpp"
      to: "mcpp library"
      via: "McpServer usage"
      pattern: "mcpp::server::McpServer"
    - from: "README.md"
      to: "examples/inspector_server.cpp"
      via: "Documentation"
      pattern: "Inspector.*inspector_server"
---

<objective>
Create an example MCP server that can be tested with MCP Inspector, and integration tests validating end-to-end client-server communication including tools, resources, and prompts.

Purpose: Provide manual validation via MCP Inspector and automated integration tests for the complete MCP workflow.

Output: Working example server, integration tests, and README documentation for Inspector usage.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-build-validation/07-CONTEXT.md
@.planning/phases/07-build-validation/07-RESEARCH.md
@.planning/phases/07-build-validation/07-02-SUMMARY.md
@thirdparty/inspector/ (for MCP Inspector reference)
</context>

<tasks>

<task type="auto">
  <name>Create example MCP Inspector server</name>
  <files>examples/inspector_server.cpp</files>
  <action>
Create examples/inspector_server.cpp - a fully functional MCP server that works with MCP Inspector:

```cpp
// mcpp - MCP C++ library
// https://github.com/mcpp-project/mcpp
//
// Copyright (c) 2025 mcpp contributors
// Distributed under MIT License

/**
 * @file inspector_server.cpp
 * @brief Example MCP server for testing with MCP Inspector
 *
 * This server demonstrates the complete mcpp API:
 * - Tool registration and execution
 * - Resource registration and reading
 * - Prompt registration and retrieval
 * - Stdio transport for communication
 *
 * Usage:
 *   mcp-inspector connect stdio ./build/examples/inspector_server
 *
 * Or directly:
 *   ./build/examples/inspector_server
 */

#include "mcpp/server/mcp_server.h"
#include "mcpp/transport/stdio_transport.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <thread>
#include <chrono>

using namespace mcpp;
using namespace mcpp::server;

// ============================================================================
// Tool Handlers
// ============================================================================

/**
 * @brief Simple calculator tool
 */
ToolResult handle_calculate(const nlohmann::json& params) {
    try {
        std::string operation = params.value("operation", "add");
        double a = params.value("a", 0.0);
        double b = params.value("b", 0.0);

        double result = 0.0;
        if (operation == "add") {
            result = a + b;
        } else if (operation == "subtract") {
            result = a - b;
        } else if (operation == "multiply") {
            result = a * b;
        } else if (operation == "divide") {
            if (b == 0.0) {
                return ToolResult{
                    {"content", nlohmann::json::array({
                        {{"type", "text"}, {"text", "Error: Division by zero"}}
                    })},
                    {"isError", true}
                };
            }
            result = a / b;
        } else {
            return ToolResult{
                {"content", nlohmann::json::array({
                    {{"type", "text"}, {"text", "Unknown operation: " + operation}}
                })},
                {"isError", true}
            };
        }

        std::ostringstream oss;
        oss << result;
        return ToolResult{
            {"content", nlohmann::json::array({
                {{"type", "text"}, {"text", oss.str()}}
            })}
        };
    } catch (const std::exception& e) {
        return ToolResult{
            {"content", nlohmann::json::array({
                {{"type", "text"}, {"text", std::string("Error: ") + e.what()}}
            })},
            {"isError", true}
        };
    }
}

/**
 * @brief Echo tool - returns the input text
 */
ToolResult handle_echo(const nlohmann::json& params) {
    std::string text = params.value("text", "");
    return ToolResult{
        {"content", nlohmann::json::array({
            {{"type", "text"}, {"text", "Echo: " + text}}
        })}
    };
}

/**
 * @brief Get current time
 */
ToolResult handle_get_time(const nlohmann::json& params) {
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);

    std::string time_str = std::ctime(&time);
    // Remove trailing newline
    if (!time_str.empty() && time_str.back() == '\n') {
        time_str.pop_back();
    }

    return ToolResult{
        {"content", nlohmann::json::array({
            {{"type", "text"}, {"text", "Current time: " + time_str}}
        })}
    };
}

// ============================================================================
// Resource Handlers
// ============================================================================

/**
 * @brief Read a text file resource
 */
ReadResourceResult handle_read_file(const std::string& uri_str) {
    // Extract file path from URI (file://path or just path)
    std::string path = uri_str;
    if (path.find("file://") == 0) {
        path = path.substr(7);
    }

    // For security, only allow reading from /tmp directory
    if (path.find("/tmp/") != 0 && path != "/tmp/mcpp_test.txt") {
        return ReadResourceResult{
            {"contents", nlohmann::json::array()},
            {"error", "Access denied: only /tmp directory is allowed"}
        };
    }

    std::ifstream file(path);
    if (!file.is_open()) {
        return ReadResourceResult{
            {"contents", nlohmann::json::array()},
            {"error", "File not found: " + path}
        };
    }

    std::stringstream buffer;
    buffer << file.rdbuf();

    return ReadResourceResult{
        {"contents", nlohmann::json::array({
            {
                {"uri", uri_str},
                {"mimeType", "text/plain"},
                {"text", buffer.str()}
            }
        })}
    };
}

/**
 * @brief Get server info as a resource
 */
ReadResourceResult handle_server_info(const std::string& uri) {
    nlohmann::json info = {
        {"name", "mcpp Inspector Server"},
        {"version", "0.1.0"},
        {"description", "Example MCP server for testing with Inspector"},
        {"capabilities", {
            {"tools", true},
            {"resources", true},
            {"prompts", true}
        }}
    };

    return ReadResourceResult{
        {"contents", nlohmann::json::array({
            {
                {"uri", uri},
                {"mimeType", "application/json"},
                {"text", info.dump(2)}
            }
        })}
    };
}

// ============================================================================
// Prompt Handlers
// ============================================================================

/**
 * @brief Generate a greeting prompt
 */
GetPromptResult handle_greeting(const nlohmann::json& args) {
    std::string name = args.value("name", "World");
    std::string tone = args.value("tone", "friendly");

    std::string greeting;
    if (tone == "formal") {
        greeting = "Good day, " + name + ". How may I assist you today?";
    } else if (tone == "casual") {
        greeting = "Hey " + name + "! What's up?";
    } else {
        greeting = "Hello, " + name + "! Nice to meet you.";
    }

    return GetPromptResult{
        {"messages", nlohmann::json::array({
            {
                {"role", "user"},
                {"content", nlohmann::json::array({
                    {{"type", "text"}, {"text", greeting}}
                })}
            }
        })},
        {"description", "A " + tone + " greeting for " + name}
    };
}

/**
 * @brief Generate a code review prompt template
 */
GetPromptResult handle_code_review(const nlohmann::json& args) {
    std::string language = args.value("language", "C++");
    std::string focus = args.value("focus", "general");

    std::string prompt_text = "Please review the following " + language + " code.\n";
    prompt_text += "Focus on: " + focus + "\n\n";
    prompt_text += "[Code will be provided here]";

    return GetPromptResult{
        {"messages", nlohmann::json::array({
            {
                {"role", "user"},
                {"content", nlohmann::json::array({
                    {{"type", "text"}, {"text", prompt_text}}
                })}
            }
        })},
        {"description", "Code review prompt for " + language + " with focus on " + focus}
    };
}

// ============================================================================
// Main Server Setup
// ============================================================================

int main(int argc, char* argv[]) {
    std::cerr << "=== mcpp Inspector Server ===" << std::endl;
    std::cerr << "This server communicates via stdio for MCP Inspector." << std::endl;
    std::cerr << "Connect with: mcp-inspector connect stdio ./build/examples/inspector_server" << std::endl;
    std::cerr << std::endl;

    // Create stdio transport
    auto transport = std::make_unique<StdioTransport>();

    // Create MCP server
    McpServer server(std::move(transport));
    server.set_server_info({
        {"name", "mcpp Inspector Server"},
        {"version", "0.1.0"},
        {"protocolVersion", "2025-11-25"}
    });

    // Register tools
    nlohmann::json calculate_schema = nlohmann::json::parse(R"({
        "type": "object",
        "properties": {
            "operation": {
                "type": "string",
                "enum": ["add", "subtract", "multiply", "divide"],
                "description": "The operation to perform"
            },
            "a": {"type": "number", "description": "First operand"},
            "b": {"type": "number", "description": "Second operand"}
        },
        "required": ["operation", "a", "b"]
    })");

    server.get_tool_registry().register_tool(
        "calculate",
        {
            {"description", "Perform basic arithmetic operations"},
            {"inputSchema", calculate_schema}
        },
        handle_calculate
    );

    nlohmann::json echo_schema = nlohmann::json::parse(R"({
        "type": "object",
        "properties": {
            "text": {"type": "string", "description": "Text to echo back"}
        },
        "required": ["text"]
    })");

    server.get_tool_registry().register_tool(
        "echo",
        {
            {"description", "Echo the input text back to the caller"},
            {"inputSchema", echo_schema}
        },
        handle_echo
    );

    server.get_tool_registry().register_tool(
        "get_time",
        {
            {"description", "Get the current server time"},
            {"inputSchema", nlohmann::json::parse(R"({"type": "object"})")}
        },
        handle_get_time
    );

    // Register resources
    server.get_resource_registry().register_resource(
        "file://tmp/mcpp_test.txt",
        "text/plain",
        handle_read_file
    );

    server.get_resource_registry().register_resource(
        "info://server",
        "application/json",
        handle_server_info
    );

    // Register prompts
    nlohmann::json greeting_args = nlohmann::json::parse(R"({
        "type": "object",
        "properties": {
            "name": {
                "type": "string",
                "description": "Name to greet"
            },
            "tone": {
                "type": "string",
                "enum": ["friendly", "formal", "casual"],
                "description": "Tone of the greeting"
            }
        }
    })");

    server.get_prompt_registry().register_prompt(
        "greeting",
        {
            {"description", "Generate a personalized greeting"},
            {"arguments", greeting_args}
        },
        handle_greeting
    );

    nlohmann::json review_args = nlohmann::json::parse(R"({
        "type": "object",
        "properties": {
            "language": {
                "type": "string",
                "description": "Programming language",
                "default": "C++"
            },
            "focus": {
                "type": "string",
                "description": "Review focus area",
                "default": "general"
            }
        }
    })");

    server.get_prompt_registry().register_prompt(
        "code_review",
        {
            {"description", "Generate a code review prompt template"},
            {"arguments", review_args}
        },
        handle_code_review
    );

    std::cerr << "Registered:" << std::endl;
    std::cerr << "  - 3 tools (calculate, echo, get_time)" << std::endl;
    std::cerr << "  - 2 resources (file://tmp/mcpp_test.txt, info://server)" << std::endl;
    std::cerr << "  - 2 prompts (greeting, code_review)" << std::endl;
    std::cerr << std::endl;
    std::cerr << "Starting server loop..." << std::endl;

    // Run server (blocking)
    server.run();

    return 0;
}
```
  </action>
  <verify>File examples/inspector_server.cpp exists with complete MCP server implementation</verify>
  <done>Example MCP Inspector server created with tools, resources, and prompts</done>
</task>

<task type="auto">
  <name>Create examples CMakeLists.txt</name>
  <files>examples/CMakeLists.txt</files>
  <action>
Create examples/CMakeLists.txt:

```cmake
# mcpp examples

# Inspector server example
add_executable(inspector_server
    inspector_server.cpp
)

target_link_libraries(inspector_server
    PRIVATE mcpp
)

target_include_directories(inspector_server
    PRIVATE ${CMAKE_SOURCE_DIR}/src
)

# HTTP server integration example (pseudo-code for documentation)
add_executable(http_server_integration
    http_server_integration.cpp
)

target_link_libraries(http_server_integration
    PRIVATE mcpp
)

target_include_directories(http_server_integration
    PRIVATE ${CMAKE_SOURCE_DIR}/src
)
```
  </action>
  <verify>File examples/CMakeLists.txt exists with both example executables configured</verify>
  <done>Examples CMakeLists.txt created with inspector_server and http_server_integration targets</done>
</task>

<task type="auto">
  <name>Create integration tests</name>
  <files>tests/integration/test_client_server.cpp</files>
  <action>
Replace the placeholder in tests/integration/test_client_server.cpp with actual integration tests:

```cpp
// mcpp - MCP C++ library
// https://github.com/mcpp-project/mcpp
//
// Copyright (c) 2025 mcpp contributors
// Distributed under MIT License

#include "mcpp/client.h"
#include "mcpp/server/mcp_server.h"
#include "mcpp/transport/stdio_transport.h"

#include <gtest/gtest.h>
#include <thread>
#include <chrono>
#include <cstdio>
#include <memory>

using namespace mcpp;
using namespace mcpp::server;

// ============================================================================
// Test Fixture for Client-Server Integration
// ============================================================================

class ClientServerIntegration : public ::testing::Test {
protected:
    void SetUp() override {
        // Create a simple server for testing
        auto transport = std::make_unique<StdioTransport>();
        test_server = std::make_unique<McpServer>(std::move(transport));
        test_server->set_server_info({
            {"name", "Test Server"},
            {"version", "0.1.0"},
            {"protocolVersion", "2025-11-25"}
        });

        // Register a simple tool
        test_server->get_tool_registry().register_tool(
            "test_tool",
            {{"description", "A test tool"}},
            [](const nlohmann::json& params) {
                return ToolResult{
                    {"content", nlohmann::json::array({
                        {{"type", "text"}, {"text", "Test executed"}}
                    })}
                };
            }
        );
    }

    void TearDown() override {
        test_server.reset();
    }

    std::unique_ptr<McpServer> test_server;
};

// ============================================================================
// Server Registration Tests
// ============================================================================

TEST_F(ClientServerIntegration, ServerRegistersTools) {
    auto tools = test_server->get_tool_registry().list_tools();
    EXPECT_EQ(tools.size(), 1);
    EXPECT_EQ(tools[0]["name"], "test_tool");
}

TEST_F(ClientServerIntegration, ServerCallsTool) {
    auto result = test_server->get_tool_registry().call_tool("test_tool", {{}});
    EXPECT_FALSE(result.contains("error"));
    EXPECT_TRUE(result.contains("content"));
}

TEST_F(ClientServerIntegration, ServerRegistersResources) {
    test_server->get_resource_registry().register_resource(
        "test://resource",
        "text/plain",
        [](const std::string&) {
            return ReadResourceResult{
                {"contents", nlohmann::json::array({
                    {{"uri", "test://resource"}, {"text", "Test content"}}
                })}
            };
        }
    );

    auto resources = test_server->get_resource_registry().list_resources();
    EXPECT_EQ(resources.size(), 1);
    EXPECT_EQ(resources[0]["uri"], "test://resource");
}

TEST_F(ClientServerIntegration, ServerReadsResource) {
    test_server->get_resource_registry().register_resource(
        "test://data",
        "text/plain",
        [](const std::string&) {
            return ReadResourceResult{
                {"contents", nlohmann::json::array({
                    {{"uri", "test://data"}, {"text", "Data"}}
                })}
            };
        }
    );

    auto result = test_server->get_resource_registry().read_resource("test://data");
    EXPECT_FALSE(result.contains("error"));
    EXPECT_TRUE(result.contains("contents"));
}

TEST_F(ClientServerIntegration, ServerRegistersPrompts) {
    test_server->get_prompt_registry().register_prompt(
        "test_prompt",
        {{"description", "A test prompt"}},
        [](const nlohmann::json&) {
            return GetPromptResult{
                {"messages", nlohmann::json::array({
                    {{{"role", "user"}, {"content", "Test"}}}
                })}
            };
        }
    );

    auto prompts = test_server->get_prompt_registry().list_prompts();
    EXPECT_EQ(prompts.size(), 1);
    EXPECT_EQ(prompts[0]["name"], "test_prompt");
}

TEST_F(ClientServerIntegration, ServerGetsPrompt) {
    test_server->get_prompt_registry().register_prompt(
        "hello",
        {{"description", "Say hello"}},
        [](const nlohmann::json&) {
            return GetPromptResult{
                {"messages", nlohmann::json::array({
                    {{{"role", "user"}, {"content", "Hello!"}}}
                })}
            };
        }
    );

    auto result = test_server->get_prompt_registry().get_prompt("hello", {{}});
    EXPECT_FALSE(result.contains("error"));
    EXPECT_TRUE(result.contains("messages"));
}

// ============================================================================
// Server Lifecycle Tests
// ============================================================================

TEST_F(ClientServerIntegration, ServerStartsAndStops) {
    // Server should be able to start and stop without errors
    // This is a basic smoke test
    EXPECT_EQ(test_server->get_server_info()["name"], "Test Server");
}

// ============================================================================
// Multi-Registration Tests
// ============================================================================

TEST_F(ClientServerIntegration, MultipleToolsRegistered) {
    for (int i = 0; i < 5; i++) {
        std::string name = "tool_" + std::to_string(i);
        test_server->get_tool_registry().register_tool(
            name,
            {{"description", "Tool " + std::to_string(i)}},
            [i](const nlohmann::json&) {
                return ToolResult{
                    {"content", nlohmann::json::array({
                        {{"type", "text"}, {"text", "Result " + std::to_string(i)}}
                    })}
                };
            }
        );
    }

    auto tools = test_server->get_tool_registry().list_tools();
    EXPECT_EQ(tools.size(), 6);  // 1 from SetUp + 5 new
}

TEST_F(ClientServerIntegration, ToolUnregister) {
    test_server->get_tool_registry().register_tool(
        "to_remove",
        {{"description", "Will be removed"}},
        [](const nlohmann::json&) {
            return ToolResult{{"content", "x"}};
        }
    );

    EXPECT_EQ(test_server->get_tool_registry().list_tools().size(), 2);

    test_server->get_tool_registry().unregister("to_remove");
    EXPECT_EQ(test_server->get_tool_registry().list_tools().size(), 1);
}

// ============================================================================
// Error Handling Tests
// ============================================================================

TEST_F(ClientServerIntegration, UnknownToolReturnsError) {
    auto result = test_server->get_tool_registry().call_tool("unknown_tool", {{}});
    EXPECT_TRUE(result.contains("error"));
}

TEST_F(ClientServerIntegration, UnknownResourceReturnsError) {
    auto result = test_server->get_resource_registry().read_resource("unknown://resource");
    EXPECT_TRUE(result.contains("error"));
}

TEST_F(ClientServerIntegration, UnknownPromptReturnsError) {
    auto result = test_server->get_prompt_registry().get_prompt("unknown_prompt", {{}});
    EXPECT_TRUE(result.contains("error"));
}

// ============================================================================
// Parameter Passing Tests
// ============================================================================

TEST_F(ClientServerIntegration, ToolReceivesParameters) {
    std::string received_param;

    test_server->get_tool_registry().register_tool(
        "param_tool",
        {{"description", "Accepts parameters"}},
        [&received_param](const nlohmann::json& params) {
            received_param = params.value("test_param", "");
            return ToolResult{{"content", "OK"}};
        }
    );

    nlohmann::json args = {{"test_param", "hello"}};
    test_server->get_tool_registry().call_tool("param_tool", args);

    EXPECT_EQ(received_param, "hello");
}

TEST_F(ClientServerIntegration, PromptReceivesArguments) {
    std::string received_arg;

    test_server->get_prompt_registry().register_prompt(
        "arg_prompt",
        {{"description", "Accepts arguments"}},
        [&received_arg](const nlohmann::json& args) {
            received_arg = args.value("name", "");
            return GetPromptResult{{"messages", {}}};
        }
    );

    nlohmann::json args = {{"name", "Alice"}};
    test_server->get_prompt_registry().get_prompt("arg_prompt", args);

    EXPECT_EQ(received_arg, "Alice");
}
```
  </action>
  <verify>File tests/integration/test_client_server.cpp exists with comprehensive integration tests</verify>
  <done>Integration tests created covering server registration, lifecycle, error handling, and parameter passing</done>
</task>

<task type="auto">
  <name>Build examples and integration tests</name>
  <files>examples/inspector_server.cpp, tests/integration/test_client_server.cpp</files>
  <action>
Build and verify all examples and integration tests:

1. Build everything:
   ```bash
   cd build
   cmake --build .
   ```

2. Verify inspector_server executable exists:
   ```bash
   ls -la examples/inspector_server
   ```

3. Run integration tests:
   ```bash
   ctest -L integration --output-on-failure
   ```

4. Run inspector_server manually (brief test):
   ```bash
   echo '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2025-11-25","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}},"id":1}' | ./examples/inspector_server
   ```

   Expected: JSON-RPC initialize response with server capabilities.

5. Clean up any issues found.

Do NOT commit - verification only.
  </action>
  <verify>
- examples/inspector_server builds successfully
- Integration tests pass via ctest -L integration
- inspector_server responds to initialize request
  </verify>
  <done>All examples and integration tests build and pass</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Example MCP Inspector server (examples/inspector_server.cpp) with tools, resources, and prompts</what-built>
  <how-to-verify>
1. Build the example server:
   ```bash
   cmake -B build -DCMAKE_BUILD_TYPE=Release
   cmake --build build --target inspector_server
   ```

2. Test with MCP Inspector (if installed):
   ```bash
   mcp-inspector connect stdio ./build/examples/inspector_server
   ```

3. In Inspector, verify:
   - Server connects and initializes successfully
   - tools/list shows: calculate, echo, get_time
   - resources/list shows: file://tmp/mcpp_test.txt, info://server
   - prompts/list shows: greeting, code_review

4. Test a tool call:
   - Click on "calculate" tool
   - Enter: operation=add, a=5, b=3
   - Expected result: 8

5. Test a prompt:
   - Click on "greeting" prompt
   - Enter: name=Claude, tone=formal
   - Expected: Formatted greeting message

If you don't have MCP Inspector installed, install with:
   ```bash
   npm install -g @modelcontextprotocol/inspector
   ```

Type "approved" if the Inspector integration works correctly, or describe any issues found.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues with the Inspector integration</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. examples/inspector_server builds and runs
2. MCP Inspector can connect to the server
3. Integration tests pass (ctest -L integration)
4. Server demonstrates tools, resources, and prompts
5. TEST-02 (MCP Inspector integration) requirement satisfied
</verification>

<success_criteria>
1. Example MCP server compiles and runs
2. Server registers 3 tools, 2 resources, 2 prompts
3. MCP Inspector can connect and interact with the server
4. Integration tests validate client-server communication
5. README documents Inspector usage
</success_criteria>

<output>
After completion, create `.planning/phases/07-build-validation/07-04-SUMMARY.md` with:
- Example server implementation details
- Inspector testing results
- Integration test coverage
- Any issues found and resolved
</output>

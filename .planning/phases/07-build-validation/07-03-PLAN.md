---
phase: 07-build-validation
plan: 03
type: execute
wave: 2
depends_on: [07-02b]
files_modified:
  - tests/compliance/test_jsonrpc_spec.cpp
  - tests/data/jsonrpc_examples.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Library consumer can run JSON-RPC compliance tests via 'ctest -L compliance'"
    - "Compliance tests validate JSON-RPC 2.0 spec conformance (request/response formats, error codes)"
    - "Tests cover both valid and invalid JSON-RPC messages"
  artifacts:
    - path: "tests/compliance/test_jsonrpc_spec.cpp"
      provides: "JSON-RPC specification compliance tests"
      contains: "TEST(JsonRpcSpecCompliance"
    - path: "tests/data/jsonrpc_examples.json"
      provides: "Test fixture data for JSON-RPC messages"
      contains: "\"valid_request\""
  key_links:
    - from: "tests/compliance/test_jsonrpc_spec.cpp"
      to: "tests/data/jsonrpc_examples.json"
      via: "load_test_data function"
      pattern: "load_test_data|jsonrpc_examples"
---

<objective>
Create JSON-RPC compliance tests validating conformance to the JSON-RPC 2.0 specification, including request/response formats, error codes, and edge cases.

Purpose: Ensure protocol correctness by validating against the official JSON-RPC 2.0 specification, catching protocol-level bugs before integration testing.

Output: Comprehensive JSON-RPC compliance test suite with test fixtures and documented validation.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-build-validation/07-CONTEXT.md
@.planning/phases/07-build-validation/07-RESEARCH.md
@.planning/phases/07-build-validation/07-02-SUMMARY.md
@thirdparty/modelcontextprotocol/docs/schema/ (for JSON-RPC reference)
</context>

<tasks>

<task type="auto">
  <name>Create JSON-RPC test fixture data</name>
  <files>tests/data/jsonrpc_examples.json</files>
  <action>
Create tests/data/jsonrpc_examples.json with valid and invalid JSON-RPC messages for testing:

```json
{
  "valid_requests": {
    "with_positional_params": {
      "jsonrpc": "2.0",
      "method": "subtract",
      "params": [42, 23],
      "id": 1
    },
    "with_named_params": {
      "jsonrpc": "2.0",
      "method": "subtract",
      "params": {"subtrahend": 23, "minuend": 42},
      "id": 2
    },
    "no_params": {
      "jsonrpc": "2.0",
      "method": "initialize",
      "id": 3
    },
    "string_id": {
      "jsonrpc": "2.0",
      "method": "update",
      "params": {"value": 100},
      "id": "req-123"
    },
    "null_id": {
      "jsonrpc": "2.0",
      "method": "notification",
      "params": {"message": "hello"}
    },
    "array_params": {
      "jsonrpc": "2.0",
      "method": "process",
      "params": ["a", "b", "c"],
      "id": 4
    }
  },

  "valid_responses": {
    "success_result": {
      "jsonrpc": "2.0",
      "result": 19,
      "id": 1
    },
    "success_object": {
      "jsonrpc": "2.0",
      "result": {"status": "ok", "data": [1, 2, 3]},
      "id": 2
    },
    "error_parse": {
      "jsonrpc": "2.0",
      "error": {
        "code": -32700,
        "message": "Parse error"
      },
      "id": null
    },
    "error_invalid_request": {
      "jsonrpc": "2.0",
      "error": {
        "code": -32600,
        "message": "Invalid Request"
      },
      "id": null
    },
    "error_method_not_found": {
      "jsonrpc": "2.0",
      "error": {
        "code": -32601,
        "message": "Method not found",
        "data": "unknown_method"
      },
      "id": 1
    },
    "error_invalid_params": {
      "jsonrpc": "2.0",
      "error": {
        "code": -32602,
        "message": "Invalid params"
      },
      "id": 2
    },
    "error_internal": {
      "jsonrpc": "2.0",
      "error": {
        "code": -32603,
        "message": "Internal error"
      },
      "id": 3
    },
    "error_custom_data": {
      "jsonrpc": "2.0",
      "error": {
        "code": -32000,
        "message": "Server error",
        "data": {"details": "Database connection failed"}
      },
      "id": 4
    }
  },

  "valid_notifications": {
    "without_params": {
      "jsonrpc": "2.0",
      "method": "notifications/cancelled"
    },
    "with_params": {
      "jsonrpc": "2.0",
      "method": "notifications/message",
      "params": {"content": "Hello, world!"}
    }
  },

  "invalid_requests": {
    "missing_jsonrpc": {
      "method": "test",
      "id": 1
    },
    "wrong_jsonrpc_version": {
      "jsonrpc": "1.0",
      "method": "test",
      "id": 1
    },
    "missing_method": {
      "jsonrpc": "2.0",
      "id": 1
    },
    "notification_with_id": {
      "jsonrpc": "2.0",
      "method": "notifications/test",
      "id": 1
    }
  },

  "batch_requests": {
    "valid_batch": [
      {"jsonrpc": "2.0", "method": "method1", "params": [1, 2], "id": 1},
      {"jsonrpc": "2.0", "method": "method2", "params": {"arg": "value"}, "id": 2},
      {"jsonrpc": "2.0", "method": "method3", "id": 3}
    ],
    "batch_with_notification": [
      {"jsonrpc": "2.0", "method": "notify", "params": [1, 2]},
      {"jsonrpc": "2.0", "method": "method", "id": 1}
    ],
    "batch_all_notifications": [
      {"jsonrpc": "2.0", "method": "notify1"},
      {"jsonrpc": "2.0", "method": "notify2"}
    ]
  },

  "malformed_json": [
    "{\"jsonrpc\": \"2.0\", \"method\": \"test\", \"id\": 1",
    "{\"jsonrpc\": \"2.0\", \"method\": 123, \"id\": }",
    "not json at all",
    "{invalid json"
  ]
}
```
  </action>
  <verify>File tests/data/jsonrpc_examples.json exists with valid JSON structure</verify>
  <done>JSON-RPC test fixture data file created with valid and invalid examples</done>
</task>

<task type="auto">
  <name>Create JSON-RPC specification compliance tests</name>
  <files>tests/compliance/test_jsonrpc_spec.cpp</files>
  <action>
Replace the placeholder in tests/compliance/test_jsonrpc_spec.cpp with comprehensive compliance tests:

```cpp
// mcpp - MCP C++ library
// https://github.com/mcpp-project/mcpp
//
// Copyright (c) 2025 mcpp contributors
// Distributed under MIT License

#include "mcpp/core/json_rpc.h"
#include <gtest/gtest.h>
#include <nlohmann/json.hpp>
#include <fstream>

using namespace mcpp;
using namespace mcpp::core;

// ============================================================================
// Test Data Loader
// ============================================================================

class JsonRpcSpecCompliance : public ::testing::Test {
protected:
    void SetUp() override {
        // Load test data from jsonrpc_examples.json
        std::ifstream file(TEST_DATA_DIR "/jsonrpc_examples.json");
        if (file.is_open()) {
            try {
                test_data = nlohmann::json::parse(file);
            } catch (const nlohmann::json::parse_error& e) {
                ADD_FAILURE() << "Failed to parse test data: " << e.what();
            }
        }
    }

    nlohmann::json test_data;

    // Helper: Check if JSON has required request fields
    bool is_valid_request_structure(const nlohmann::json& j) {
        return j.contains("jsonrpc") && j["jsonrpc"] == "2.0" &&
               j.contains("method") && j["method"].is_string();
    }

    // Helper: Check if JSON has required response fields
    bool is_valid_response_structure(const nlohmann::json& j) {
        return j.contains("jsonrpc") && j["jsonrpc"] == "2.0" &&
               j.contains("id") &&
               (j.contains("result") || j.contains("error"));
    }
};

// ============================================================================
// JSON-RPC 2.0 Specification Compliance Tests
// ============================================================================

TEST_F(JsonRpcSpecCompliance, ValidRequest_Structure) {
    // A JSON-RPC request must have: jsonrpc="2.0", method (string), optional params, optional id
    if (!test_data.contains("valid_requests")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, req_json] : test_data["valid_requests"].items()) {
        EXPECT_TRUE(req_json.contains("jsonrpc")) << "Request '" << name << "' missing jsonrpc field";
        EXPECT_EQ(req_json["jsonrpc"], "2.0") << "Request '" << name << "' has wrong jsonrpc version";
        EXPECT_TRUE(req_json.contains("method")) << "Request '" << name << "' missing method field";
        EXPECT_TRUE(req_json["method"].is_string()) << "Request '" << name << "' method must be string";
    }
}

TEST_F(JsonRpcSpecCompliance, ValidResponse_Structure) {
    // A JSON-RPC response must have: jsonrpc="2.0", result OR error, id
    if (!test_data.contains("valid_responses")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, resp_json] : test_data["valid_responses"].items()) {
        EXPECT_TRUE(resp_json.contains("jsonrpc")) << "Response '" << name << "' missing jsonrpc field";
        EXPECT_EQ(resp_json["jsonrpc"], "2.0") << "Response '" << name << "' has wrong jsonrpc version";
        EXPECT_TRUE(resp_json.contains("id")) << "Response '" << name << "' missing id field";
        EXPECT_TRUE(resp_json.contains("result") || resp_json.contains("error"))
            << "Response '" << name << "' must have result or error field";
        EXPECT_FALSE(resp_json.contains("result") && resp_json.contains("error"))
            << "Response '" << name << "' cannot have both result and error";
    }
}

TEST_F(JsonRpcSpecCompliance, Error_CodeStandardValues) {
    // JSON-RPC 2.0 defines standard error codes
    struct ErrorCodeCheck {
        int code;
        const char* name;
    } standard_codes[] = {
        {-32700, "Parse error"},
        {-32600, "Invalid Request"},
        {-32601, "Method not found"},
        {-32602, "Invalid params"},
        {-32603, "Internal error"}
    };

    if (!test_data.contains("valid_responses")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, resp_json] : test_data["valid_responses"].items()) {
        if (!resp_json.contains("error")) continue;

        int error_code = resp_json["error"]["code"];
        std::string message = resp_json["error"]["message"];

        // Verify error has required fields
        EXPECT_TRUE(resp_json["error"].contains("code")) << "Error '" << name << "' missing code";
        EXPECT_TRUE(resp_json["error"].contains("message")) << "Error '" << name << "' missing message";

        // Verify code is integer
        EXPECT_TRUE(resp_json["error"]["code"].is_number_integer()) << "Error '" << name << "' code must be integer";
    }
}

TEST_F(JsonRpcSpecCompliance, Notification_NoIdField) {
    // Notifications are requests without id field
    if (!test_data.contains("valid_notifications")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, notif_json] : test_data["valid_notifications"].items()) {
        EXPECT_FALSE(notif_json.contains("id")) << "Notification '" << name << "' must not have id field";
        EXPECT_TRUE(notif_json.contains("method")) << "Notification '" << name << "' must have method";
    }
}

TEST_F(JsonRpcSpecCompliance, InvalidRequest_Detection) {
    // Verify our parser rejects invalid requests
    if (!test_data.contains("invalid_requests")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, invalid_json] : test_data["invalid_requests"].items()) {
        // These should fail to parse as valid requests
        auto req = JsonRpcRequest::from_json(invalid_json);
        EXPECT_FALSE(req.has_value()) << "Invalid request '" << name << "' should not parse successfully";
    }
}

TEST_F(JsonRpcSpecCompliance, BatchRequest_Structure) {
    // Batch requests are JSON arrays of individual requests
    if (!test_data.contains("batch_requests")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, batch_json] : test_data["batch_requests"].items()) {
        EXPECT_TRUE(batch_json.is_array()) << "Batch request '" << name << "' must be an array";

        for (const auto& item : batch_json) {
            EXPECT_TRUE(item.contains("jsonrpc")) << "Batch item in '" << name << "' missing jsonrpc";
            EXPECT_TRUE(item.contains("method")) << "Batch item in '" << name << "' missing method";
        }
    }
}

// ============================================================================
// JsonRpcRequest Type Compliance Tests
// ============================================================================

TEST_F(JsonRpcSpecCompliance, Request_ParseValidExamples) {
    if (!test_data.contains("valid_requests")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, req_json] : test_data["valid_requests"].items()) {
        auto req = JsonRpcRequest::from_json(req_json);
        EXPECT_TRUE(req.has_value()) << "Valid request '" << name << "' failed to parse";
        if (req.has_value()) {
            EXPECT_EQ(req->method, req_json["method"]);
        }
    }
}

TEST_F(JsonRpcSpecCompliance, Request_SerializePreservesData) {
    // Round-trip test: serialize -> deserialize -> compare
    JsonRpcRequest original("test/method", {{"arg1", "value1"}}, 42);
    nlohmann::json serialized = original.to_json();
    auto deserialized = JsonRpcRequest::from_json(serialized);

    ASSERT_TRUE(deserialized.has_value());
    EXPECT_EQ(deserialized->method, original.method);
    EXPECT_EQ(deserialized->id, original.id);
}

// ============================================================================
// JsonRpcResponse Type Compliance Tests
// ============================================================================

TEST_F(JsonRpcSpecCompliance, Response_ParseValidExamples) {
    if (!test_data.contains("valid_responses")) {
        GTEST_SKIP() << "Test data not available";
        return;
    }

    for (auto& [name, resp_json] : test_data["valid_responses"].items()) {
        // Responses without errors
        if (resp_json.contains("result")) {
            nlohmann::json result = resp_json["result"];
            JsonRpcResponse resp(result, resp_json["id"]);
            nlohmann::json serialized = resp.to_json();

            EXPECT_EQ(serialized["jsonrpc"], "2.0");
            EXPECT_TRUE(serialized.contains("result"));
            EXPECT_FALSE(serialized.contains("error"));
        }
    }
}

TEST_F(JsonRpcSpecCompliance, Response_ErrorCodesMatchSpec) {
    JsonRpcError parse_err(JsonRpcError::ErrorCode::ParseError, "Parse error");
    EXPECT_EQ(parse_err.code, -32700);

    JsonRpcError invalid_req(JsonRpcError::ErrorCode::InvalidRequest, "Invalid request");
    EXPECT_EQ(invalid_req.code, -32600);

    JsonRpcError method_err(JsonRpcError::ErrorCode::MethodNotFound, "Method not found");
    EXPECT_EQ(method_err.code, -32601);

    JsonRpcError params_err(JsonRpcError::ErrorCode::InvalidParams, "Invalid params");
    EXPECT_EQ(params_err.code, -32602);

    JsonRpcError internal_err(JsonRpcError::ErrorCode::InternalError, "Internal error");
    EXPECT_EQ(internal_err.code, -32603);
}

// ============================================================================
// Edge Cases and Boundary Tests
// ============================================================================

TEST_F(JsonRpcSpecCompliance, Request_EmptyStringMethod) {
    nlohmann::json req_json = {
        {"jsonrpc", "2.0"},
        {"method", ""},
        {"id", 1}
    };

    auto req = JsonRpcRequest::from_json(req_json);
    // Empty method string might be valid per spec (though unusual)
    // This tests our implementation's behavior
    if (req.has_value()) {
        EXPECT_EQ(req->method, "");
    }
}

TEST_F(JsonRpcSpecCompliance, Request_LargeIntegerId) {
    nlohmann::json req_json = {
        {"jsonrpc", "2.0"},
        {"method", "test"},
        {"id", 9007199254740991}  // max safe integer
    };

    auto req = JsonRpcRequest::from_json(req_json);
    EXPECT_TRUE(req.has_value()) << "Large integer ID should be supported";
}

TEST_F(JsonRpcSpecCompliance, Request_NullParams) {
    nlohmann::json req_json = {
        {"jsonrpc", "2.0"},
        {"method", "test"},
        {"params", nullptr},
        {"id", 1}
    };

    auto req = JsonRpcRequest::from_json(req_json);
    // Null params should be valid (explicitly no parameters)
    EXPECT_TRUE(req.has_value());
}

TEST_F(JsonRpcSpecCompliance, Response_NullResult) {
    // Null result is valid (indicates successful void method)
    nlohmann::json result = nullptr;
    JsonRpcResponse resp(result, 1);
    nlohmann::json serialized = resp.to_json();

    EXPECT_TRUE(serialized.contains("result"));
    EXPECT_TRUE(serialized["result"].is_null());
}
```

Note: Add TEST_DATA_DIR definition to tests/CMakeLists.txt as a compile definition:
```cmake
target_compile_definitions(mcpp_compliance_tests PRIVATE
    TEST_DATA_DIR="${CMAKE_CURRENT_SOURCE_DIR}/data"
)
```
  </action>
  <verify>File tests/compliance/test_jsonrpc_spec.cpp exists with comprehensive JSON-RPC spec compliance tests</verify>
  <done>JSON-RPC compliance tests created covering spec requirements, edge cases, and error codes</done>
</task>

<task type="auto">
  <name>Update tests/CMakeLists.txt for data directory</name>
  <files>tests/CMakeLists.txt</files>
  <action>
Update tests/CMakeLists.txt to add the test data directory definition:

Find the compliance test executable definition and add:
```cmake
target_compile_definitions(mcpp_compliance_tests PRIVATE
    TEST_DATA_DIR="${CMAKE_CURRENT_SOURCE_DIR}/data"
)
```

Also add data files to be available for tests:
```cmake
# Ensure test data is available
configure_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/data/jsonrpc_examples.json"
    "${CMAKE_CURRENT_BINARY_DIR}/data/jsonrpc_examples.json"
    COPYONLY
)
```
  </action>
  <verify>tests/CMakeLists.txt updated with TEST_DATA_DIR definition</verify>
  <done>Test data directory configured for compliance tests</done>
</task>

<task type="auto">
  <name>Build and run compliance tests</name>
  <files>tests/compliance/test_jsonrpc_spec.cpp</files>
  <action>
Build and verify compliance tests:

1. Build tests:
   ```bash
   cd build
   cmake --build . --target mcpp_compliance_tests
   ```

2. Run compliance tests:
   ```bash
   ctest -L compliance --output-on-failure
   ```

3. Or run directly:
   ```bash
   ./tests/mcpp_compliance_tests --gtest_filter="JsonRpcSpecCompliance.*"
   ```

4. If tests fail due to API mismatches, update test code to match actual implementation.

5. Verify test count:
   ```bash
   ./tests/mcpp_compliance_tests --gtest_list_tests
   ```

Expected: At least 15 test cases covering JSON-RPC spec compliance.

Do NOT commit - verification only.
  </action>
  <verify>
Compliance tests pass:
- ctest -L compliance returns 0
- At least 15 spec compliance test cases run
- Tests validate JSON-RPC request/response structure, error codes, notifications
  </verify>
  <done>JSON-RPC compliance test suite validated and passing</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. `ctest -L compliance` runs all compliance tests
2. Compliance tests validate JSON-RPC 2.0 spec requirements
3. Test fixture data (jsonrpc_examples.json) is properly loaded
4. Tests cover: valid/invalid requests, responses, error codes, notifications, batch requests, edge cases
5. TEST-03 (JSON-RPC compliance tests) requirement satisfied
</verification>

<success_criteria>
1. tests/data/jsonrpc_examples.json contains comprehensive test fixtures
2. tests/compliance/test_jsonrpc_spec.cpp has 15+ test cases
3. All compliance tests pass via ctest
4. Tests validate JSON-RPC 2.0 spec conformance
5. Test data is properly loaded and used in tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-build-validation/07-03-SUMMARY.md` with:
- JSON-RPC spec compliance tests created
- Test coverage areas (request, response, errors, notifications)
- Number of test cases
- Any spec deviations found and documented
</output>

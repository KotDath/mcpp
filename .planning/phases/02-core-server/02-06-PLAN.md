---
phase: 02-core-server
plan: 06
type: execute
wave: 3
depends_on: [02-05]
files_modified:
  - src/mcpp/transport/stdio_transport.h
  - src/mcpp/transport/stdio_transport.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "StdioTransport implements Transport interface for subprocess stdio communication"
    - "spawn() creates subprocess with popen and returns StdioTransport"
    - "Messages are newline-delimited JSON per MCP spec"
    - "Read thread continuously reads from subprocess stdout"
    - "Destructor closes pipe and waits for subprocess (RAII cleanup)"
  artifacts:
    - path: "src/mcpp/transport/stdio_transport.h"
      provides: "Stdio transport with subprocess spawning and newline-delimited JSON messaging"
      min_lines: 60
      contains: "class StdioTransport", "spawn", "public Transport"
  key_links:
    - from: "src/mcpp/transport/stdio_transport.h"
      to: "src/mcpp/transport/transport.h"
      via: "Inheritance from Transport interface"
      pattern: "public Transport|:.*Transport"
    - from: "src/mcpp/transport/stdio_transport.cpp"
      to: "src/mcpp/transport/stdio_transport.h"
      via: "Implementation of Transport interface methods"
      pattern: "(connect|disconnect|send|set_message_callback)"
---

<objective>
Implement StdioTransport for subprocess communication with newline-delimited JSON messaging.

Purpose: Stdio is the primary transport for MCP servers. Clients spawn servers as subprocesses and communicate via stdin/stdout. StdioTransport handles subprocess spawning, message framing (newline-delimited JSON), and provides the Transport interface for use with McpServer.

Output: Working StdioTransport class with subprocess spawning, newline-delimited JSON I/O, background read thread, and RAII cleanup.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-CONTEXT.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-RESEARCH.md
@src/mcpp/transport/transport.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StdioTransport class header</name>
  <files>src/mcpp/transport/stdio_transport.h</files>
  <action>
Create src/mcpp/transport/stdio_transport.h with:

1. Include guards and includes:
   ```cpp
   #include <string>
   #include <string_view>
   #include <vector>
   #include <thread>
   #include <atomic>
   #include <functional>
   #include <cstdio>
   #include "mcpp/transport/transport.h"
   ```

2. namespace mcpp::transport

3. StdioTransport class (following RESEARCH.md Pattern 4 "Stdio Transport with Subprocess Spawning"):
   ```cpp
   class StdioTransport : public Transport {
   public:
       // Spawn a subprocess for stdio communication
       static std::expected<StdioTransport, std::string> spawn(
           const std::string& command,
           const std::vector<std::string>& args = {}
       );

       // Destructor: cleanup subprocess
       ~StdioTransport() override;

       // Non-copyable, non-movable (subprocess handle)
       StdioTransport(const StdioTransport&) = delete;
       StdioTransport& operator=(const StdioTransport&) = delete;
       StdioTransport(StdioTransport&&) = delete;
       StdioTransport& operator=(StdioTransport&&) = delete;

       // Transport interface implementation
       bool connect() override;
       void disconnect() override;
       bool is_connected() const override;
       bool send(std::string_view message) override;
       void set_message_callback(MessageCallback cb) override;
       void set_error_callback(ErrorCallback cb) override;

   private:
       // Private constructor for spawn()
       StdioTransport(FILE* pipe, pid_t pid);

       void read_loop();

       FILE* pipe_;              // pipe for stdin/stdout
       pid_t pid_;               // subprocess PID
       std::atomic<bool> running_;
       std::thread read_thread_;
       MessageCallback message_callback_;
       ErrorCallback error_callback_;
   };
   ```

Use std::expected for spawn result (C++23 feature, use std::optional or custom for C++17 - follow existing project pattern).
Use POSIX types (pid_t) for process management.
popen() provides bidirectional communication for simplicity.

Note: For C++17 compatibility without std::expected, use:
   ```cpp
   static bool spawn(
       const std::string& command,
       const std::vector<std::string>& args,
       StdioTransport& out_transport,
       std::string& error_message
   );
   ```
  </action>
  <verify>grep -E "class StdioTransport|public Transport|spawn|~StdioTransport" src/mcpp/transport/stdio_transport.h</verify>
  <done>stdio_transport.h defines StdioTransport inheriting from Transport with spawn static method, read thread, and RAII cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Implement StdioTransport subprocess spawning</name>
  <files>src/mcpp/transport/stdio_transport.cpp</files>
  <action>
Create src/mcpp/transport/stdio_transport.cpp with:

1. Includes:
   ```cpp
   #include "mcpp/transport/stdio_transport.h"
   #include <cstdio>
   #include <unistd.h>
   #include <signal.h>
   #include <sys/wait.h>
   #include <fcntl.h>
   ```

2. Implement spawn (using C++17 compatible API):
   ```cpp
   bool StdioTransport::spawn(
       const std::string& command,
       const std::vector<std::string>& args,
       StdioTransport& out_transport,
       std::string& error_message
   ) {
       // Build command string with arguments
       std::string full_command = command;
       for (const auto& arg : args) {
           full_command += " ";
           full_command += arg;
       }

       // Open pipe for reading and writing
       FILE* pipe = popen(full_command.c_str(), "r+");
       if (!pipe) {
           error_message = "Failed to spawn subprocess: " + full_command;
           return false;
       }

       // Make pipe non-blocking
       int fd = fileno(pipe);
       fcntl(fd, F_SETFL, O_NONBLOCK);

       // Get PID from pipe (platform-specific, simplification)
       pid_t pid = 0;  // popen doesn't directly give PID

       // Create transport object
       out_transport = StdioTransport(pipe, pid);
       return true;
   }
   ```

Note: popen() is simpler than fork/exec+pipe but doesn't provide direct PID access.
For proper PID management, consider using fork/exec/pipe directly or posix_spawn.
For MVP, track connection state via pipe_ being non-null.

3. Implement private constructor:
   ```cpp
   StdioTransport::StdioTransport(FILE* pipe, pid_t pid)
       : pipe_(pipe), pid_(pid), running_(false) {}
   ```

4. Implement connect:
   ```cpp
   bool StdioTransport::connect() {
       if (!pipe_) return false;
       running_ = true;
       read_thread_ = std::thread(&StdioTransport::read_loop, this);
       return true;
   }
   ```

Follow CONTEXT.md "Stdio transport" decisions: simple spawn interface, RAII cleanup in destructor.
  </action>
  <verify>grep -E "spawn|pclose|connect|read_thread_" src/mcpp/transport/stdio_transport.cpp</verify>
  <done>stdio_transport.cpp implements spawn using popen, connect starts read thread, pipe and PID are stored for cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Implement StdioTransport message I/O</name>
  <files>src/mcpp/transport/stdio_transport.cpp</files>
  <action>
Extend stdio_transport.cpp with:

1. Implement send with newline delimiter:
   ```cpp
   bool StdioTransport::send(std::string_view message) {
       if (!pipe_ || !running_) return false;

       std::string full_message(message);
       full_message += '\n';  // Add newline delimiter per MCP spec

       size_t written = fwrite(full_message.data(), 1, full_message.size(), pipe_);
       fflush(pipe_);

       return written == full_message.size();
   }
   ```

2. Implement read_loop for background reading:
   ```cpp
   void StdioTransport::read_loop() {
       char buffer[4096];
       std::string line_buffer;

       while (running_ && pipe_) {
           // Read from subprocess stdout
           if (fgets(buffer, sizeof(buffer), pipe_)) {
               line_buffer += buffer;

               // Process complete lines (newline-delimited)
               size_t pos;
               while ((pos = line_buffer.find('\n')) != std::string::npos) {
                   std::string line = line_buffer.substr(0, pos);
                   line_buffer.erase(0, pos + 1);

                   if (message_callback_) {
                       message_callback_(line);
                   }
               }
           } else {
               // EOF or error
               if (error_callback_) {
                   error_callback_("Read error or EOF");
               }
               break;
           }
       }
   }
   ```

3. Implement remaining Transport methods:
   ```cpp
   void StdioTransport::disconnect() {
       running_ = false;
       if (read_thread_.joinable()) {
           read_thread_.join();
       }
   }

   bool StdioTransport::is_connected() const {
       return running_ && pipe_ != nullptr;
   }

   void StdioTransport::set_message_callback(MessageCallback cb) {
       message_callback_ = std::move(cb);
   }

   void StdioTransport::set_error_callback(ErrorCallback cb) {
       error_callback_ = std::move(cb);
   }
   ```

4. Implement destructor with RAII cleanup:
   ```cpp
   StdioTransport::~StdioTransport() {
       disconnect();

       if (pipe_) {
           // Close pipe and wait for subprocess
           pclose(pipe_);
           pipe_ = nullptr;
       }
   }
   ```

Follow RESEARCH.md Pitfall 4 "Stdio Message Framing" - always append '\n' after JSON.
Follow RESEARCH.md Pitfall 5 "Subprocess Zombie Processes" - pclose waits for subprocess.
  </action>
  <verify>grep -E "send|read_loop|disconnect|is_connected|set_message_callback|set_error_callback|~StdioTransport" src/mcpp/transport/stdio_transport.cpp</verify>
  <done>stdio_transport.cpp implements send with newline delimiter, read_loop for background reading, disconnect stops thread, destructor closes pipe with pclose</done>
</task>

</tasks>

<verification>
- spawn() uses popen to create subprocess with bidirectional pipe
- send() appends '\n' delimiter to messages before writing
- read_loop() reads lines in background thread, invokes callback for each complete line
- Line buffering handles partial reads and multiple messages
- disconnect() stops read thread and joins
- destructor calls pclose() to close pipe and wait for subprocess
- is_connected() checks running_ and pipe_
- Callbacks are stored by value to avoid lifetime issues
</verification>

<success_criteria>
StdioTransport spawns subprocess and manages its lifecycle.
Messages sent have newline delimiter per MCP stdio spec.
Read thread continuously processes incoming messages.
Callbacks are invoked for each complete line (JSON message).
Destructor cleans up subprocess (pclose waits for process exit).
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-server/02-06-SUMMARY.md`
</output>

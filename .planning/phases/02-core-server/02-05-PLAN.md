---
phase: 02-core-server
plan: 05
type: execute
wave: 2
depends_on: [02-01, 02-02, 02-03, 02-04]
files_modified:
  - src/mcpp/server/mcp_server.h
  - src/mcpp/server/mcp_server.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "McpServer integrates tool, resource, and prompt registries"
    - "McpServer handles initialize request and returns ServerCapabilities"
    - "McpServer dispatches tools/list, tools/call requests"
    - "McpServer dispatches resources/list, resources/read requests"
    - "McpServer dispatches prompts/list, prompts/get requests"
  artifacts:
    - path: "src/mcpp/server/mcp_server.h"
      provides: "Main MCP server class integrating all registries and request routing"
      min_lines: 100
      contains: "class McpServer", "handle_request", "register_tool", "register_resource", "register_prompt"
  key_links:
    - from: "src/mcpp/server/mcp_server.h"
      to: "src/mcpp/server/tool_registry.h"
      via: "Composition for tool operations"
      pattern: "ToolRegistry"
    - from: "src/mcpp/server/mcp_server.h"
      to: "src/mcpp/server/resource_registry.h"
      via: "Composition for resource operations"
      pattern: "ResourceRegistry"
    - from: "src/mcpp/server/mcp_server.h"
      to: "src/mcpp/server/prompt_registry.h"
      via: "Composition for prompt operations"
      pattern: "PromptRegistry"
    - from: "src/mcpp/server/mcp_server.cpp"
      to: "src/mcpp/core/json_rpc.h"
      via: "JSON-RPC request/response parsing"
      pattern: "JsonRpc(Request|Response)"
---

<objective>
Implement McpServer main class integrating all registries and routing JSON-RPC requests to appropriate handlers.

Purpose: McpServer is the central class that ties together all server components (tools, resources, prompts). It handles the MCP initialize handshake, dispatches JSON-RPC requests to appropriate registries, and returns properly formatted responses. This is the main entry point for server consumers.

Output: Working McpServer class with initialize handling, request routing, and integration of all registries.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-CONTEXT.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-RESEARCH.md
@src/mcpp/core/json_rpc.h
@src/mcpp/protocol/types.h
@src/mcpp/protocol/capabilities.h
@src/mcpp/server/tool_registry.h
@src/mcpp/server/resource_registry.h
@src/mcpp/server/prompt_registry.h
@src/mcpp/server/request_context.h
@src/mcpp/transport/transport.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create McpServer class header with registry composition</name>
  <files>src/mcpp/server/mcp_server.h</files>
  <action>
Create src/mcpp/server/mcp_server.h with:

1. Include guards and includes:
   ```cpp
   #include <string>
   #include <optional>
   #include <nlohmann/json.hpp>
   #include "mcpp/server/tool_registry.h"
   #include "mcpp/server/resource_registry.h"
   #include "mcpp/server/prompt_registry.h"
   #include "mcpp/transport/transport.h"
   #include "mcpp/protocol/types.h"
   #include "mcpp/protocol/capabilities.h"
   ```

2. namespace mcpp::server

3. McpServer class:
   ```cpp
   class McpServer {
   public:
       // Constructor with optional server info
       explicit McpServer(
           const std::string& name = "mcpp-server",
           const std::string& version = "1.0.0"
       );

       // Set the transport (must be set before handling requests)
       void set_transport(transport::Transport& transport);

       // Tool registration
       void register_tool(
           const std::string& name,
           const std::string& description,
           const nlohmann::json& input_schema,
           ToolHandler handler
       );

       // Resource registration
       void register_resource(
           const std::string& uri,
           const std::string& name,
           const std::optional<std::string>& description,
           const std::string& mime_type,
           ResourceHandler handler
       );

       // Prompt registration
       void register_prompt(
           const std::string& name,
           const std::optional<std::string>& description,
           const std::vector<PromptArgument>& arguments,
           PromptHandler handler
       );

       // Handle incoming JSON-RPC request, return response
       std::optional<nlohmann::json> handle_request(
           const nlohmann::json& request_json
       );

   private:
       // Request handlers
       nlohmann::json handle_initialize(const nlohmann::json& params);
       nlohmann::json handle_tools_list();
       nlohmann::json handle_tools_call(const nlohmann::json& params);
       nlohmann::json handle_resources_list();
       nlohmann::json handle_resources_read(const nlohmann::json& params);
       nlohmann::json handle_prompts_list();
       nlohmann::json handle_prompts_get(const nlohmann::json& params);

       // Extract progress token from request metadata
       std::optional<std::string> extract_progress_token(const nlohmann::json& params);

       Implementation server_info_;
       std::optional<transport::Transport*> transport_;

       ToolRegistry tools_;
       ResourceRegistry resources_;
       PromptRegistry prompts_;
   };
   ```

Server holds registries by value for proper lifecycle management.
Transport is stored as pointer (non-owning) since it's provided by caller.
  </action>
  <verify>grep -E "class McpServer|register_tool|register_resource|register_prompt|handle_request" src/mcpp/server/mcp_server.h</verify>
  <done>mcp_server.h defines McpServer with registry composition, registration methods, and handle_request for JSON-RPC routing</done>
</task>

<task type="auto">
  <name>Task 2: Implement McpServer request routing</name>
  <files>src/mcpp/server/mcp_server.cpp</files>
  <action>
Create src/mcpp/server/mcp_server.cpp with:

1. Include headers and JSON-RPC types

2. Implement constructor:
   ```cpp
   McpServer::McpServer(const std::string& name, const std::string& version)
       : server_info_{name, version}, transport_(std::nullopt) {}
   ```

3. Implement set_transport:
   ```cpp
   void McpServer::set_transport(transport::Transport& transport) {
       transport_ = &transport;
   }
   ```

4. Implement registration methods (delegating to registries):
   - register_tool: calls tools_.register_tool()
   - register_resource: calls resources_.register_resource()
   - register_prompt: calls prompts_.register_prompt()

5. Implement handle_request with method routing:
   ```cpp
   std::optional<nlohmann::json> McpServer::handle_request(
       const nlohmann::json& request_json
   ) {
       // Parse as JSON-RPC request
       std::string method = request_json["method"];
       nlohmann::json params = request_json.value("params", nlohmann::json::object());
       nlohmann::json id = request_json.value("id", nlohmann::json());

       nlohmann::json result;

       // Route to handler based on method
       if (method == "initialize") {
           result = handle_initialize(params);
       } else if (method == "tools/list") {
           result = handle_tools_list();
       } else if (method == "tools/call") {
           result = handle_tools_call(params);
       } else if (method == "resources/list") {
           result = handle_resources_list();
       } else if (method == "resources/read") {
           result = handle_resources_read(params);
       } else if (method == "prompts/list") {
           result = handle_prompts_list();
       } else if (method == "prompts/get") {
           result = handle_prompts_get(params);
       } else {
           // Method not found error
           return nlohmann::json{
               {"jsonrpc", "2.0"},
               {"id", id},
               {"error", {
                   {"code", -32601},
                   {"message", "Method not found"}
               }}
           };
       }

       // Return successful response
       return nlohmann::json{
           {"jsonrpc", "2.0"},
           {"id", id},
           {"result", result}
       };
   }
   ```

6. Implement handle_initialize:
   ```cpp
   nlohmann::json McpServer::handle_initialize(const nlohmann::json& params) {
       // Build ServerCapabilities based on registered items
       nlohmann::json capabilities = {
           {"tools", nlohmann::json::object()},  // tools/listChanged support can be added later
           {"resources", {{"subscribe", false}}},
           {"prompts", nlohmann::json::object()}
       };

       return {
           {"protocolVersion", "2025-11-25"},
           {"serverInfo", {
               {"name", server_info_.name},
               {"version", server_info_.version}
           }},
           {"capabilities", capabilities}
       };
   }
   ```

7. Implement list/call/read/get handlers (delegating to registries):
   - handle_tools_list: return tools_.list_tools()
   - handle_tools_call: extract progress token, create RequestContext, call tools_.call_tool()
   - handle_resources_list: return resources_.list_resources()
   - handle_resources_read: return resources_.read_resource(uri)
   - handle_prompts_list: return prompts_.list_prompts()
   - handle_prompts_get: return prompts_.get_prompt(name, arguments)

8. Implement extract_progress_token:
   ```cpp
   std::optional<std::string> McpServer::extract_progress_token(
       const nlohmann::json& params
   ) {
       if (params.contains("_meta") && params["_meta"].contains("progressToken")) {
           return params["_meta"]["progressToken"].get<std::string>();
       }
       return std::nullopt;
   }
   ```

Follow RESEARCH.md "Progress Notification" example for token location (_meta.progressToken).
  </action>
  <verify>grep -E "handle_initialize|handle_tools|handle_resources|handle_prompts|extract_progress_token" src/mcpp/server/mcp_server.cpp</verify>
  <done>mcp_server.cpp implements request routing by method name, initialize handshake, delegation to registries, and progress token extraction</done>
</task>

</tasks>

<verification>
- McpServer constructor stores server name and version
- set_transport stores non-owning pointer to Transport
- Registration methods delegate to respective registries
- handle_request routes based on method name
- initialize returns ServerCapabilities with tools, resources, prompts
- tools/call creates RequestContext with progress token and passes to handler
- Progress token is extracted from params._meta.progressToken
- Method not found returns JSON-RPC error code -32601
</verification>

<success_criteria>
McpServer integrates all registries (tools, resources, prompts).
handle_request routes JSON-RPC requests to appropriate handlers.
initialize returns proper MCP InitializeResult format.
tools/call creates RequestContext with progress token.
All handlers return properly formatted JSON-RPC responses.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-server/02-05-SUMMARY.md`
</output>

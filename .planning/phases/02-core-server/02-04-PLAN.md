---
phase: 02-core-server
plan: 04
type: execute
wave: 2
depends_on: [02-01, 02-02, 02-03]
files_modified:
  - src/mcpp/server/request_context.h
  - src/mcpp/server/request_context.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "RequestContext provides access to transport for sending notifications"
    - "Handlers can call report_progress with token, progress value, and optional message"
    - "Progress notifications are sent via notifications/progress method"
    - "RequestContext extracts progress token from request._meta.progressToken"
  artifacts:
    - path: "src/mcpp/server/request_context.h"
      provides: "RequestContext for handler access to transport and progress reporting"
      min_lines: 50
      contains: "class RequestContext", "report_progress", "has_progress_token", "progress_token"
  key_links:
    - from: "src/mcpp/server/request_context.h"
      to: "src/mcpp/transport/transport.h"
      via: "Transport reference for sending notifications"
      pattern: "Transport&|transport_"
    - from: "src/mcpp/server/tool_registry.h"
      to: "src/mcpp/server/request_context.h"
      via: "ToolHandler receives RequestContext& parameter"
      pattern: "RequestContext"
---

<objective>
Implement RequestContext for handler access to transport and progress token support.

Purpose: Handlers need a way to send progress notifications for long-running operations. RequestContext provides access to the transport for sending notifications and encapsulates the progress token from the request metadata. This connects the handler layer to the transport layer.

Output: RequestContext class with transport access, progress token storage, and report_progress method that sends notifications/progress messages.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-CONTEXT.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-RESEARCH.md
@src/mcpp/transport/transport.h
@src/mcpp/protocol/types.h
@src/mcpp/server/tool_registry.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RequestContext class with transport and progress token</name>
  <files>src/mcpp/server/request_context.h</files>
  <action>
Create src/mcpp/server/request_context.h with:

1. Include guards and includes:
   ```cpp
   #include <string>
   #include <optional>
   #include <nlohmann/json.hpp>
   #include "mcpp/transport/transport.h"
   ```

2. namespace mcpp::server

3. RequestContext class (following RESEARCH.md Pattern 2 "RequestContext for Progress Reporting"):
   ```cpp
   class RequestContext {
   public:
       // Constructor with request ID and transport reference
       RequestContext(
           const std::string& request_id,
           transport::Transport& transport
       );

       // Set the progress token from request metadata
       void set_progress_token(const std::string& token);

       // Check if client requested progress
       bool has_progress_token() const;

       // Get the progress token
       const std::optional<std::string>& progress_token() const;

       // Get the request ID
       const std::string& request_id() const;

       // Report progress for long-running operations
       void report_progress(
           double progress,  // 0-100
           const std::string& message = ""
       );

       // Get transport reference
       transport::Transport& transport();

   private:
       std::string request_id_;
       transport::Transport& transport_;
       std::optional<std::string> progress_token_;
   };
   ```

Follow RESEARCH.md Pattern 2 exactly. Progress values are 0-100 percentage.
Progress token is extracted from request._meta.progressToken by server (not RequestContext).
  </action>
  <verify>grep -E "class RequestContext|report_progress|has_progress_token|progress_token" src/mcpp/server/request_context.h</verify>
  <done>request_context.h defines RequestContext with request_id, transport reference, progress_token storage, and report_progress method</done>
</task>

<task type="auto">
  <name>Task 2: Implement RequestContext progress notification</name>
  <files>src/mcpp/server/request_context.cpp</files>
  <action>
Create src/mcpp/server/request_context.cpp with:

1. Include request_context.h and core JSON-RPC types

2. Implement constructor:
   ```cpp
   RequestContext::RequestContext(
       const std::string& request_id,
       transport::Transport& transport
   ) : request_id_(request_id), transport_(transport) {}
   ```

3. Implement setter and accessors:
   - set_progress_token: Store token in progress_token_
   - has_progress_token: Return progress_token_.has_value()
   - progress_token: Return progress_token_
   - request_id: Return request_id_
   - transport: Return transport_

4. Implement report_progress (following RESEARCH.md "Progress Notification" example):
   ```cpp
   void RequestContext::report_progress(
       double progress,
       const std::string& message
   ) {
       if (!has_progress_token()) {
           return;  // No progress token, skip notification
       }

       nlohmann::json notification = {
           {"jsonrpc", "2.0"},
           {"method", "notifications/progress"},
           {"params", {
               {"progressToken", *progress_token_},
               {"progress", progress}
           }}
       };

       if (!message.empty()) {
           notification["params"]["message"] = message;
       }

       std::string serialized = notification.dump() + "\n";
       transport_.send(serialized);
   }
   ```

Notifications are sent via transport.send() with newline delimiter per MCP stdio spec.
Progress value is clamped to 0-100 range.
  </action>
  <verify>grep -E "report_progress|notifications/progress|progressToken|transport_\\.send" src/mcpp/server/request_context.cpp</verify>
  <done>request_context.cpp implements report_progress that sends notifications/progress via transport with progressToken, progress value, and optional message</done>
</task>

<task type="auto">
  <name>Task 3: Update tool_registry.h to include RequestContext definition</name>
  <files>src/mcpp/server/tool_registry.h</files>
  <action>
Update tool_registry.h to include the RequestContext header:

1. Add include (after forward declaration):
   ```cpp
   #include "mcpp/server/request_context.h"
   ```

2. Remove the forward declaration if present:
   ```cpp
   // Remove: class RequestContext;
   ```

This ensures ToolHandler signature has complete type information for RequestContext.
  </action>
  <verify>grep -E "#include.*request_context\\.h" src/mcpp/server/tool_registry.h</verify>
  <done>tool_registry.h includes request_context.h for complete RequestContext type in ToolHandler signature</done>
</task>

</tasks>

<verification>
- RequestContext holds reference to Transport for sending notifications
- RequestContext stores optional progress token from request metadata
- report_progress sends notifications/progress with progressToken, progress (0-100), optional message
- Notifications are newline-delimited JSON sent via transport.send()
- report_progress is no-op if no progress token is set
- tool_registry.h includes request_context.h for complete type
</verification>

<success_criteria>
RequestContext provides handler access to transport for sending notifications.
Progress token is stored and accessible via progress_token() accessor.
report_progress sends properly formatted notifications/progress messages.
Handlers can use ctx.report_progress(value, message) during long operations.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-server/02-04-SUMMARY.md`
</output>

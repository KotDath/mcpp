---
phase: 02-core-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/server/mcp_server.h
  - src/mcpp/server/mcp_server.cpp
  - src/mcpp/server/tool_registry.h
  - src/mcpp/server/tool_registry.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Library consumer can register tools with name, description, and JSON Schema input validation"
    - "Library consumer can call tools/list and receive tool discovery metadata"
    - "Library consumer can execute tool calls with JSON Schema input validation"
    - "Tool handlers receive RequestContext for progress reporting"
    - "Tool errors return with isError flag, not JSON-RPC errors"
  artifacts:
    - path: "src/mcpp/server/tool_registry.h"
      provides: "Tool registration and dispatch with JSON Schema validation"
      min_lines: 60
      contains: "class ToolRegistry", "struct ToolRegistration", "using ToolHandler"
    - path: "src/mcpp/server/mcp_server.h"
      provides: "Main server class with tool registration methods"
      min_lines: 80
      contains: "class McpServer", "register_tool", "list_tools", "call_tool"
  key_links:
    - from: "src/mcpp/server/tool_registry.cpp"
      to: "nlohmann/json-schema-validator"
      via: "json_validator for schema compilation and validation"
      pattern: "json_validator|validate\\(.*json"
    - from: "src/mcpp/server/tool_registry.h"
      to: "src/mcpp/server/request_context.h"
      via: "RequestContext passed to tool handlers"
      pattern: "RequestContext"
---

<objective>
Implement tool registration, discovery, and execution with JSON Schema input validation and structured result handling.

Purpose: Tools are the primary server primitive in MCP - they enable LLMs to perform actions. Tool discovery (tools/list) and execution (tools/call) are required for any functional MCP server. JSON Schema validation ensures tool arguments match expected shapes before handler invocation.

Output: Working tool registry with registration, discovery, and execution; JSON Schema validation pre-processing; ToolResult with isError flag for handler errors.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-CONTEXT.md
@.planning/phases/02-core-server**---tools,-resources,-prompts-with-stdio-transport-and-progress-support/02-RESEARCH.md
@src/mcpp/protocol/types.h
@src/mcpp/protocol/capabilities.h
@src/mcpp/core/json_rpc.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool types and handler signatures</name>
  <files>src/mcpp/server/tool_registry.h</files>
  <action>
Create src/mcpp/server/tool_registry.h with:

1. Include guards and includes:
   - #include <nlohmann/json.hpp>
   - #include <functional>
   - #include <string>
   - #include <unordered_map>
   - #include <optional>

2. Forward declare RequestContext (will be defined in 02-04)
   ```cpp
   class RequestContext;
   ```

3. namespace mcpp::server

4. Tool handler signature:
   ```cpp
   using ToolHandler = std::function<nlohmann::json(
       const std::string& name,
       const nlohmann::json& args,
       RequestContext& ctx
   )>;
   ```

5. Tool registration struct:
   ```cpp
   struct ToolRegistration {
       std::string name;
       std::string description;
       nlohmann::json input_schema;  // JSON Schema for validation
       ToolHandler handler;
   };
   ```

Follow CONTEXT.md "Tool registration" decisions exactly. Handler returns JSON result directly (MCP CallToolResult format).
Do NOT implement validation yet (Task 3).
  </action>
  <verify>grep -E "struct ToolRegistration|using ToolHandler|class RequestContext" src/mcpp/server/tool_registry.h</verify>
  <done>tool_registry.h defines ToolRegistration with name, description, input_schema, handler and ToolHandler function type</done>
</task>

<task type="auto">
  <name>Task 2: Create ToolRegistry class with registration and discovery</name>
  <files>src/mcpp/server/tool_registry.h src/mcpp/server/tool_registry.cpp</files>
  <action>
Extend tool_registry.h and create tool_registry.cpp with:

1. In tool_registry.h, add ToolRegistry class:
   ```cpp
   class ToolRegistry {
   public:
       // Register a tool with its schema
       bool register_tool(
           const std::string& name,
           const std::string& description,
           const nlohmann::json& input_schema,
           ToolHandler handler
       );

       // List all registered tools
       std::vector<nlohmann::json> list_tools() const;

       // Call a tool by name
       std::optional<nlohmann::json> call_tool(
           const std::string& name,
       const nlohmann::json& args,
       RequestContext& ctx
   ) const;

       // Check if tool exists
       bool has_tool(const std::string& name) const;

   private:
       std::unordered_map<std::string, ToolRegistration> tools_;
   };
   ```

2. In tool_registry.cpp, implement methods:
   - register_tool: Store in tools_ map, return true on success
   - list_tools: Return array of tool objects with name, description, inputSchema
   - call_tool: Find tool, call handler, return result; return std::nullopt if not found
   - has_tool: Check if name exists in tools_

Use std::unordered_map for O(1) lookup. Return std::optional for not-found handling (not exceptions).
Do NOT implement JSON Schema validation yet (Task 3).
  </action>
  <verify>grep -E "class ToolRegistry|register_tool|list_tools|call_tool|has_tool" src/mcpp/server/tool_registry.h src/mcpp/server/tool_registry.cpp</verify>
  <done>ToolRegistry provides register_tool, list_tools, call_tool, has_tool methods with unordered_map storage</done>
</task>

<task type="auto">
  <name>Task 3: Add JSON Schema validation to tool execution</name>
  <files>src/mcpp/server/tool_registry.h src/mcpp/server/tool_registry.cpp</files>
  <action>
Extend ToolRegistry with JSON Schema validation using nlohmann/json-schema-validator:

1. In tool_registry.h, add include:
   ```cpp
   #include <nlohmann/json-schema.hpp>
   ```

2. Extend ToolRegistration to hold validator:
   ```cpp
   struct ToolRegistration {
       std::string name;
       std::string description;
       nlohmann::json input_schema;
       std::unique_ptr<nlohmann::json_schema::json_validator> validator;
       ToolHandler handler;
   };
   ```

3. In register_tool implementation:
   - Compile the schema: Create json_validator instance
   - Set schema using validator->set_root_schema(input_schema)
   - Store validator in ToolRegistration

4. In call_tool implementation, before calling handler:
   - Use validator->validate(args) to validate arguments
   - If validation fails, return error result: {"error": {"code": -32602, "message": "Invalid arguments", "data": validation_error}}
   - Only call handler if validation passes

Follow RESEARCH.md Pattern 3 "JSON Schema Validation" exactly.
Compile schema once during registration (not on every call).
  </action>
  <verify>grep -E "json_validator|validate|set_root_schema" src/mcpp/server/tool_registry.cpp</verify>
  <done>Tool registration compiles JSON Schema validator; call_tool validates arguments before dispatch; validation errors return JSON-RPC INVALID_PARAMS</done>
</task>

</tasks>

<verification>
- tool_registry.h compiles with forward-declared RequestContext
- ToolRegistry::register_tool compiles schema and stores validator
- ToolRegistry::list_tools returns array of tool metadata with name, description, inputSchema
- ToolRegistry::call_tool validates args against schema before invoking handler
- Validation failures return proper error response
- Tool handlers receive RequestContext for future progress reporting
</verification>

<success_criteria>
Tool registry supports registration, discovery, and execution with JSON Schema validation.
Tools can be listed with full metadata (name, description, inputSchema).
Tool calls are validated against registered schema before handler invocation.
Handlers receive RequestContext for progress reporting (to be wired in 02-04).
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-server/02-01-SUMMARY.md`
</output>

---
phase: 08-bug-fix-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/core/json_rpc.h
  - src/mcpp/util/logger.h
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All JSON-RPC types provide to_string_delimited() for stdio output"
    - "to_string_delimited() returns JSON string with trailing newline"
    - "Debug output macro writes to stderr only (no stdout pollution)"
    - "Library has zero std::cout writes in code paths (verified)"
  artifacts:
    - path: "src/mcpp/core/json_rpc.h"
      provides: "to_string_delimited() methods for Request, Response, Notification"
      contains: "std::string to_string_delimited()"
      min_lines: 110
    - path: "src/mcpp/util/logger.h"
      provides: "MCPP_DEBUG_LOG macro for stderr-only debug output"
      contains: "#define MCPP_DEBUG_LOG"
      min_lines: 290
  key_links:
    - from: "JsonRpcRequest::to_string_delimited()"
      to: "JsonRpcRequest::to_json()"
      via: "calls to_json().dump() + newline"
      pattern: "return to_json\\(\\)\\.dump\\(\\)"
    - from: "MCPP_DEBUG_LOG"
      to: "stderr"
      via: "std::fprintf(stderr, ...)"
      pattern: "std::fprintf\\(stderr"
---

<objective>
Add newline-delimited output helpers and stderr-only debug logging macro

Purpose: MCP stdio transport requires newline-delimited JSON messages. Current to_string() methods don't include trailing newline, requiring manual concatenation at call sites. Debug output must go to stderr only to avoid polluting stdio protocol stream.

Output: to_string_delimited() methods on all JSON-RPC types, and MCPP_DEBUG_LOG macro for stderr-only debug output.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-bug-fix-foundation/08-CONTEXT.md
@.planning/phases/08-bug-fix-foundation/08-RESEARCH.md
@src/mcpp/core/json_rpc.h
@src/mcpp/util/logger.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add to_string_delimited() to JsonRpcRequest</name>
  <files>src/mcpp/core/json_rpc.h</files>
  <action>
    Add to_string_delimited() method to JsonRpcRequest struct (after to_string() at line 88, before closing brace):

    ```cpp
    /**
     * Serialize this request to a JSON string with trailing newline
     *
     * Use this for stdio transport output where newline delimiter is required.
     * The newline ensures proper message framing per MCP transport spec.
     *
     * @return JSON string with trailing '\n' character
     */
    std::string to_string_delimited() const {
        return to_json().dump() + "\n";
    }
    ```

    Keep existing to_string() for non-stdio use cases (HTTP, testing).
    Do NOT flush in helper - let caller control flushing.
  </action>
  <verify>grep -q "std::string to_string_delimited()" src/mcpp/core/json_rpc.h && grep -A2 "to_string_delimited()" src/mcpp/core/json_rpc.h | grep -q 'dump()'</verify>
  <done>JsonRpcRequest has to_string_delimited() returning .dump() + "\n"</done>
</task>

<task type="auto">
  <name>Task 2: Add to_string_delimited() to JsonRpcResponse and JsonRpcNotification</name>
  <files>src/mcpp/core/json_rpc.h</files>
  <action>
    Add to_string_delimited() method to JsonRpcResponse (after to_string() at line 127):

    ```cpp
    /**
     * Serialize this response to a JSON string with trailing newline
     *
     * Use this for stdio transport output where newline delimiter is required.
     * The newline ensures proper message framing per MCP transport spec.
     *
     * @return JSON string with trailing '\n' character
     */
    std::string to_string_delimited() const {
        return to_json().dump() + "\n";
    }
    ```

    Add to_string_delimited() method to JsonRpcNotification (after to_string() at line 175, before closing brace):

    ```cpp
    /**
     * Serialize this notification to a JSON string with trailing newline
     *
     * Use this for stdio transport output where newline delimiter is required.
     * The newline ensures proper message framing per MCP transport spec.
     *
     * @return JSON string with trailing '\n' character
     */
    std::string to_string_delimited() const {
        return to_json().dump() + "\n";
    }
    ```

    Use consistent formatting across all three types.
  </action>
  <verify>grep -c "to_string_delimited()" src/mcpp/core/json_rpc.h | grep -q "3"</verify>
  <done>JsonRpcResponse and JsonRpcNotification have to_string_delimited() methods</done>
</task>

<task type="auto">
  <name>Task 3: Add MCPP_DEBUG_LOG macro to logger.h</name>
  <files>src/mcpp/util/logger.h</files>
  <action>
    Add MCPP_DEBUG_LOG macro at the END of logger.h (after the inline logger() function, before final #endif):

    ```cpp
    /**
     * @brief Debug logging macro for stderr-only output
     *
     * MCPP_DEBUG_LOG writes debug messages directly to stderr, avoiding
     * any stdout pollution that could corrupt the JSON-RPC stdio protocol.
     *
     * Use this for temporary debug output or diagnostics in library code paths.
     * For structured logging, use the Logger class instead.
     *
     * Usage:
     *   MCPP_DEBUG_LOG("Request validation failed: code=%d", error_code);
     *   MCPP_DEBUG_LOG("Processing request with method=%s", method.c_str());
     *
     * Format uses printf-style formatting with std::fprintf.
     *
     * @note This macro is always active (no debug build gating) to ensure
     *       debug output is always routed to stderr, never stdout.
     */
    #ifndef MCPP_DEBUG_LOG
    #define MCPP_DEBUG_LOG(fmt, ...) std::fprintf(stderr, "[MCPP_DEBUG] " fmt "\n", ##__VA_ARGS__)
    #endif

    #endif // MCPP_UTIL_LOGGER_H
    ```

    Key design decisions:
    - Uses std::fprintf(stderr, ...) - guarantees stderr-only output
    - Prefixes with "[MCPP_DEBUG]" for easy filtering
    - No conditional compilation - macro always active (no debug-only builds)
    - Uses ##__VA_ARGS__ for graceful handling of empty args (GCC extension)
    - Place at end of header to avoid interfering with existing includes

    Verify no existing std::cout usage in library code (should only be in comments):
    ```bash
    grep -r "std::cout" src/ --include="*.cpp" --include="*.h" | grep -v "^\s*//" | grep -v "\*.*std::cout"
    ```
    Expected: No results (only std::cout in documentation comments)
  </action>
  <verify>grep -q "#define MCPP_DEBUG_LOG" src/mcpp/util/logger.h && grep -q "std::fprintf(stderr" src/mcpp/util/logger.h</verify>
  <done>MCPP_DEBUG_LOG macro defined, writing to stderr with [MCPP_DEBUG] prefix</done>
</task>

</tasks>

<verification>
1. Build passes: cmake --build build
2. Unit tests pass: ctest --test-dir build
3. All three JSON-RPC types have to_string_delimited() method
4. to_string_delimited() output ends with '\n' (verified via string inspection)
5. MCPP_DEBUG_LOG macro expands to std::fprintf(stderr, ...)
6. No std::cout usage in library source code (only in comments)
</verification>

<success_criteria>
1. to_string_delimited() available on JsonRpcRequest, JsonRpcResponse, JsonRpcNotification
2. All delimited outputs include trailing newline character
3. MCPP_DEBUG_LOG writes to stderr only (verified via macro expansion)
4. Zero stdout pollution risk in library code paths
</success_criteria>

<output>
After completion, create `.planning/phases/08-bug-fix-foundation/08-02-SUMMARY.md`
</output>

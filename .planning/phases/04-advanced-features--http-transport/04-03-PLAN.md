---
phase: 04-advanced-features--http-transport
plan: 03
type: execute
wave: 2
depends_on: [02-05]
files_modified: [src/mcpp/server/tool_registry.h, src/mcpp/server/tool_registry.cpp]
autonomous: true

must_haves:
  truths:
    - "Tools can be registered with annotations (audience, priority, destructive, read-only)"
    - "Tools can declare optional outputSchema for result validation"
    - "Tool results are validated against outputSchema before returning"
    - "Tool list includes annotations and outputSchema in discovery"
  artifacts:
    - path: "src/mcpp/server/tool_registry.h"
      provides: "Tool annotations and structured output support"
      min_lines: 80
      exports: ["ToolAnnotations", "register_tool (overloaded)", "list_tools"]
    - path: "src/mcpp/server/tool_registry.cpp"
      provides: "Output schema validation implementation"
      min_lines: 200
      contains: "output_schema validation, JSON Schema validator"
  key_links:
    - from: "tool_registry.h"
      to: "tool_registry.h (existing ToolRegistration)"
      via: "extending ToolRegistration struct"
      pattern: "ToolRegistration.*annotations|output_schema"
    - from: "tool_registry.cpp"
      to: "nlohmann/json_schema_validator"
      via: "compile validator for output_schema"
      pattern: "json_schema::json_validator"
    - from: "McpServer (02-05)"
      to: "tool_registry.h"
      via: "register_tool method"
      pattern: "register_tool.*annotations"
---

<objective>
Tool metadata and output validation: annotations (audience, priority, destructive/read-only indicators) and structured output (outputSchema with JSON Schema validation).

Purpose: Tool annotations enable rich tool discovery for UI/UX (audience filtering, priority sorting, destructive operation warnings). Structured output guarantees tool results match declared schema via JSON Schema validation using existing nlohmann/json-schema-validator dependency.

Output: Enhanced ToolRegistry with annotation support, output schema declaration, and automatic result validation.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features--http-transport/04-RESEARCH.md

# Existing tool registry to extend
@src/mcpp/server/tool_registry.h

# Existing server integration
@src/mcpp/server/mcp_server.h

# JSON Schema validator (already in build deps)
# nlohmann/json_schema::json_validator
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool annotations and output schema to ToolRegistration</name>
  <files>src/mcpp/server/tool_registry.h</files>
  <action>
Extend ToolRegistration with annotations and output schema:

1. Add ToolAnnotations struct before ToolRegistration:
   ```cpp
   struct ToolAnnotations {
       bool destructive = false;           // Indicates destructive operation
       bool read_only = true;              // Indicates read-only operation
       std::string audience = "user";      // "user" | "assistant" | "system"
       int priority = 0;                   // Lower = higher priority

       // Constructor with defaults
       ToolAnnotations() = default;
       ToolAnnotations(bool destr, bool ro, const std::string& aud, int prio)
           : destructive(destr), read_only(ro), audience(aud), priority(prio) {}
   };
   ```

2. Extend ToolRegistration struct:
   - Add: std::optional<nlohmann::json> output_schema;
   - Add: std::unique_ptr<nlohmann::json_schema::json_validator> output_validator;
   - Add: ToolAnnotations annotations;

3. Add overloaded register_tool method with annotations and output_schema:
   ```cpp
   bool register_tool(
       const std::string& name,
       const std::string& description,
       const nlohmann::json& input_schema,
       const std::optional<nlohmann::json>& output_schema,
       const ToolAnnotations& annotations,
       ToolHandler handler
   );
   ```

4. Keep existing register_tool for backward compatibility (uses defaults).

5. Update list_tools() to include annotations and outputSchema in returned JSON:
   - Add "annotations" field to tool objects
   - Add "outputSchema" field if present

Note: json_validator is already in use for input_schema validation. Reuse same pattern for output_schema.
  </action>
  <verify>
grep -q "ToolAnnotations" src/mcpp/server/tool_registry.h && grep -q "output_schema" src/mcpp/server/tool_registry.h
  </verify>
  <done>
ToolRegistration has annotations struct and output_schema field. Overloaded register_tool accepts annotations and output_schema. list_tools includes new fields in discovery.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement output schema validation in tool execution</name>
  <files>src/mcpp/server/tool_registry.cpp</files>
  <action>
Implement output schema validation:

1. Implement overloaded register_tool:
   - Compile output_validator if output_schema provided:
     ```cpp
     if (output_schema) {
         reg.output_schema = output_schema;
         reg.output_validator = std::make_unique<nlohmann::json_schema::json_validator>(*output_schema);
     }
     ```
   - Store annotations in registration
   - Use existing validator compilation pattern for input_schema

2. Update call_tool to validate output:
   - After handler returns result, check if output_validator exists
   - If output_validator exists, validate result:
     ```cpp
     if (reg.output_validator) {
         try {
             reg.output_validator->validate(result);
         } catch (const std::exception& e) {
             // Return error response
             return json{
                 {"content", {{{"type", "text"}, {"text", std::string("Output validation failed: ") + e.what()}}}},
                 {"isError", true}
             };
         }
     }
     ```
   - Return validated result

3. Update list_tools to include new fields:
   - For each tool, add annotations object:
     ```cpp
     tool["annotations"] = {
         {"destructive", reg.annotations.destructive},
         {"readOnly", reg.annotations.read_only},
         {"audience", reg.annotations.audience},
         {"priority", reg.annotations.priority}
     };
     ```
   - Add outputSchema if present:
     ```cpp
     if (reg.output_schema) {
         tool["outputSchema"] = *reg.output_schema;
     }
     ```

4. Handle validation errors gracefully:
   - Log error via error callback if available
   - Return CallToolResult with isError=true
   - Include validation error message in content

Note: nlohmann::json_schema::json_validator validates JSON against Draft 7 schema. Already in build deps from gopher-mcp.
  </action>
  <verify>
grep -q "output_validator->validate\|output_validator.validate" src/mcpp/server/tool_registry.cpp && grep -q "annotations" src/mcpp/server/tool_registry.cpp
  </verify>
  <done>
Tool results are validated against output_schema before returning. Validation failures return error response with message. Discovery includes annotations and outputSchema.
  </done>
</task>

</tasks>

<verification>
After completion:
1. Tools can be registered with annotations and output schema
2. Tool results are validated against output schema if declared
3. Validation errors produce isError response with descriptive message
4. tools/list includes annotations and outputSchema in discovery
5. Backward compatibility maintained (existing tools work without changes)
</verification>

<success_criteria>
1. ToolAnnotations struct with destructive, read_only, audience, priority
2. Output schema validation using nlohmann/json-schema-validator
3. Discovery includes new fields in tools/list response
4. Backward compatible with existing register_tool calls
5. Validation errors return proper error response format
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features--http-transport/04-03-SUMMARY.md`
</output>

---
phase: 04-advanced-features--http-transport
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/mcpp/transport/http_transport.h, src/mcpp/transport/http_transport.cpp, examples/http_server_integration.cpp]
autonomous: true

must_haves:
  truths:
    - "HttpTransport implements Transport interface for Streamable HTTP (POST/SSE)"
    - "Session management generates cryptographically secure session IDs"
    - "Transport integrates with user-provided HTTP server via handle_post/handle_get methods"
    - "SSE events use SseFormatter for proper message formatting"
    - "Example code demonstrates user HTTP server integration pattern"
    - "Non-blocking I/O used for all transport operations to avoid event loop blocking"
  artifacts:
    - path: "src/mcpp/transport/http_transport.h"
      provides: "Streamable HTTP transport implementation"
      min_lines: 120
      exports: ["HttpTransport", "handle_post_request", "handle_get_request", "send_notification"]
    - path: "src/mcpp/transport/http_transport.cpp"
      provides: "HTTP transport implementation"
      min_lines: 150
      contains: "session generation, message buffering, SSE formatting"
    - path: "examples/http_server_integration.cpp"
      provides: "User HTTP server integration example"
      min_lines: 80
      contains: "HttpResponse adapter, HttpSseWriter adapter, POST/GET handler examples"
  key_links:
    - from: "http_transport.h"
      to: "transport.h"
      via: "inheritance from Transport base class"
      pattern: "class HttpTransport.*:.*public Transport"
    - from: "http_transport.cpp"
      to: "sse_formatter.h"
      via: "static method call for SSE formatting"
      pattern: "SseFormatter::format_event"
    - from: "examples/http_server_integration.cpp"
      to: "http_transport.h"
      via: "user HTTP server calls handle_post/handle_get"
      pattern: "http_transport.*handle_post|handle_get"
---

<objective>
Streamable HTTP transport implementation following MCP 2025-11-25 spec with single endpoint (POST for client->server, GET/SSE for server->client), session management, and resumability support.

Purpose: HTTP/SSE transport enables web-based MCP server deployments. Uses user-provided HTTP server integration pattern (library does not own HTTP server lifecycle). Session management via Mcp-Session-Id header enables resumable connections.

Output: HttpTransport class implementing Transport interface with handle_post/handle_get methods for user HTTP server integration.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features--http-transport/04-RESEARCH.md
@.planning/phases/04-advanced-features--http-transport/04-01-PLAN.md

# Transport base interface
@src/mcpp/transport/transport.h

# SSE formatter from plan 04-01
@src/mcpp/util/sse_formatter.h

# Reference existing stdio transport pattern
@src/mcpp/transport/stdio_transport.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HttpTransport header with session management</name>
  <files>src/mcpp/transport/http_transport.h</files>
  <action>
Create HttpTransport class header extending Transport interface:

1. Include: transport.h, string, optional, vector, unordered_map, functional, nlohmann/json.hpp
   Also include util/sse_formatter.h (from plan 04-01)

2. Define mcpp::transport::HttpTransport class:
   - Inherits from Transport (public)
   - Non-copyable, non-movable (follow Transport pattern)

3. Public methods:
   - connect(): override - returns true (HTTP is stateless, connection managed by user)
   - disconnect(): override - clears session, sends any pending SSE events
   - is_connected(): override - returns true if session exists
   - send(std::string_view message): override - buffers message for SSE delivery
   - set_message_callback(MessageCallback cb): override - store for incoming POST requests
   - set_error_callback(ErrorCallback cb): override - store for error reporting

4. User HTTP server integration methods:
   - handle_post_request(const std::string& body, HttpResponse& response):
     * Parse JSON-RPC from body
     * Invoke message_callback
     * Return response via HttpResponse (user-defined type)
     * Store Mcp-Session-Id header if present

   - handle_get_request(HttpSseWriter& writer):
     * Send buffered messages via SSE
     * Use SseFormatter::format_event for each message
     * Support Last-Event-ID header for resumability

   - send_notification(const nlohmann::json& notification):
     * Format as SSE event
     * Buffer for next GET request

5. Session management:
   - create_session(): generates UUID v4 for session ID
   - validate_session(const std::string& session_id): checks if session exists
   - terminate_session(const std::string& session_id): removes session

6. Private members:
   - std::string current_session_id_
   - std::vector<std::string> message_buffer_  // messages pending SSE delivery
   - std::unordered_map<std::string, SessionData> sessions_  // active sessions
   - MessageCallback message_callback_
   - ErrorCallback error_callback_
   - uint64_t last_event_id_  // for SSE resumability

7. Define SessionData struct (private):
   - std::string session_id
   - std::vector<std::string> pending_messages
   - std::chrono::steady_clock::time_point last_activity

8. HttpResponse and HttpSseWriter are user-defined types - use forward declarations or templates. Document this pattern in comments.

Include MIT license header.
  </action>
  <verify>
grep -q "class HttpTransport.*:.*public Transport" src/mcpp/transport/http_transport.h && grep -q "handle_post_request\|handle_get_request" src/mcpp/transport/http_transport.h
  </verify>
  <done>
HttpTransport header defines Transport subclass with POST/GET handler methods, session management, and SSE buffering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement HttpTransport with SSE formatting</name>
  <files>src/mcpp/transport/http_transport.cpp</files>
  <action>
Create HttpTransport implementation:

1. Include MIT license header

2. Includes: http_transport.h, random (for UUID generation), sstream, chrono,iomanip

3. Session ID generation:
   - Use random_device + mt19937 for cryptographically secure random
   - Generate 32 hex digits (UUID v4 format)
   - Only ASCII 0x21-0x7E per MCP spec

4. Implement connect():
   - Generate new session via create_session()
   - Store in current_session_id_
   - Return true

5. Implement disconnect():
   - Clear current_session_id_
   - Clear message_buffer_

6. Implement send():
   - Serialize message (already JSON string)
   - Add to message_buffer_
   - Increment last_event_id_

7. Implement handle_get_request():
   - Set SSE headers via writer.set_header("Content-Type", SseFormatter::content_type())
   - For each message in buffer:
     * Format via SseFormatter::format_event(message, std::to_string(last_event_id_))
     * Write via writer.write_sse()
   - Clear buffer after sending

8. Implement set_message_callback/set_error_callback:
   - Store callbacks in member variables

9. Implement session management:
   - create_session(): generate UUID, store in sessions_
   - validate_session(): lookup in sessions_, check timeout (30 min)
   - terminate_session(): remove from sessions_

10. Session timeout:
    - Check last_activity in validate_session
    - Remove sessions inactive > 30 minutes
    - Update last_activity on each access

Note: HttpResponse and HttpSseWriter are user-provided. Document that users must define these types or use template pattern. For now, assume basic interface with set_header(), write(), get_body() methods.
  </action>
  <verify>
grep -q "SseFormatter::format_event" src/mcpp/transport/http_transport.cpp && grep -q "session" src/mcpp/transport/http_transport.cpp
  </verify>
  <done>
HttpTransport generates secure session IDs, buffers messages for SSE delivery, formats events via SseFormatter. Session timeout cleanup implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create user HTTP server integration example and ensure non-blocking I/O</name>
  <files>examples/http_server_integration.cpp</files>
  <action>
Create example showing user HTTP server integration and ensure non-blocking I/O:

1. Create examples/ directory if needed

2. Create http_server_integration.cpp demonstrating:
   - User-defined HttpResponse adapter with set_header(), write(), get_body() methods
   - User-defined HttpSseWriter adapter with set_header(), write_sse() methods
   - Example HTTP server loop (pseudo-code or using a simple library like cpp-httplib)
   - Integration with HttpTransport:
     ```cpp
     // POST handler
     server.Post("/mcp", [&](const Request& req, Response& res) {
         std::string body = req.body;
         HttpResponse response(res);  // user adapter
         http_transport.handle_post_request(body, response);
     });

     // GET handler for SSE
     server.Get("/mcp", [&](const Request& req, Response& res) {
         HttpSseWriter writer(res);  // user adapter
         http_transport.handle_get_request(writer);
     });
     ```

3. Document the adapter pattern:
   - HttpResponse/HttpSseWriter are user-provided adapters
   - Library defines interface via methods used in handle_post/handle_get
   - Users wrap their HTTP server's response object
   - No library dependency on specific HTTP server

4. Ensure non-blocking I/O:
   - Document that send() must not block - should buffer internally
   - handle_post_request should return immediately (async processing)
   - handle_get_request should use async I/O for SSE streaming
   - Add comments noting that transport I/O operations use non-blocking patterns:
     * send() buffers without blocking on socket writes
     * message_buffer_ stores pending messages for GET request retrieval
     * Session operations use lock-free or mutex-protected data structures

5. Include MIT license header

This example serves as integration documentation. Users adapt the pattern to their HTTP server of choice (drogon, oat++, nginx module, etc.).
  </action>
  <verify>
grep -q "HttpResponse\|HttpSseWriter" examples/http_server_integration.cpp && grep -q "handle_post_request\|handle_get_request" examples/http_server_integration.cpp
  </verify>
  <done>
Integration example shows user HTTP server calling HttpTransport methods. HttpResponse/HttpSseWriter adapters demonstrated. Non-blocking I/O documented for transport operations.
  </done>
</task>

</tasks>

<verification>
After completion:
1. HttpTransport compiles and implements all Transport methods
2. Session IDs are cryptographically secure (random-generated, 32 hex digits)
3. SSE formatting uses SseFormatter from plan 04-01
4. Session cleanup removes stale sessions after 30 minutes
5. Integration example compiles and demonstrates user HTTP server pattern
6. Transport operations document non-blocking behavior (send buffers, handle_post returns immediately)
</verification>

<success_criteria>
1. HttpTransport implements Transport interface fully
2. Session management with secure IDs and timeout cleanup
3. SSE events formatted correctly via SseFormatter
4. User HTTP server integration pattern documented with example code
5. No built-in HTTP server - user provides their own
6. Non-blocking I/O patterns used for all transport operations
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features--http-transport/04-02-SUMMARY.md`
</output>

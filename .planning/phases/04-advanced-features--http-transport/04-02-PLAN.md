---
phase: 04-advanced-features--http-transport
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/mcpp/transport/http_transport.h, src/mcpp/transport/http_transport.cpp]
autonomous: true

must_haves:
  truths:
    - "HttpTransport implements Transport interface for Streamable HTTP (POST/SSE)"
    - "Session management generates cryptographically secure session IDs"
    - "Transport integrates with user-provided HTTP server via handle_post/handle_get methods"
    - "SSE events use SseFormatter for proper message formatting"
  artifacts:
    - path: "src/mcpp/transport/http_transport.h"
      provides: "Streamable HTTP transport implementation"
      min_lines: 120
      exports: ["HttpTransport", "handle_post_request", "handle_get_request", "send_notification"]
    - path: "src/mcpp/transport/http_transport.cpp"
      provides: "HTTP transport implementation"
      min_lines: 150
      contains: "session generation, message buffering, SSE formatting"
  key_links:
    - from: "http_transport.h"
      to: "transport.h"
      via: "inheritance from Transport base class"
      pattern: "class HttpTransport.*:.*public Transport"
    - from: "http_transport.cpp"
      to: "sse_formatter.h"
      via: "static method call for SSE formatting"
      pattern: "SseFormatter::format_event"
---

<objective>
Streamable HTTP transport implementation following MCP 2025-11-25 spec with single endpoint (POST for client->server, GET/SSE for server->client), session management, and resumability support.

Purpose: HTTP/SSE transport enables web-based MCP server deployments. Uses user-provided HTTP server integration pattern (library does not own HTTP server lifecycle). Session management via Mcp-Session-Id header enables resumable connections.

Output: HttpTransport class implementing Transport interface with handle_post/handle_get methods for user HTTP server integration.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features--http-transport/04-RESEARCH.md
@.planning/phases/04-advanced-features--http-transport/04-01-PLAN.md

# Transport base interface
@src/mcpp/transport/transport.h

# SSE formatter from plan 04-01
@src/mcpp/util/sse_formatter.h

# Reference existing stdio transport pattern
@src/mcpp/transport/stdio_transport.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HttpTransport header with session management</name>
  <files>src/mcpp/transport/http_transport.h</files>
  <action>
Create HttpTransport class header extending Transport interface:

1. Include: transport.h, string, optional, vector, unordered_map, functional, nlohmann/json.hpp
   Also include util/sse_formatter.h (from plan 04-01)

2. Define mcpp::transport::HttpTransport class:
   - Inherits from Transport (public)
   - Non-copyable, non-movable (follow Transport pattern)

3. Public methods:
   - connect(): override - returns true (HTTP is stateless, connection managed by user)
   - disconnect(): override - clears session, sends any pending SSE events
   - is_connected(): override - returns true if session exists
   - send(std::string_view message): override - buffers message for SSE delivery
   - set_message_callback(MessageCallback cb): override - store for incoming POST requests
   - set_error_callback(ErrorCallback cb): override - store for error reporting

4. User HTTP server integration methods:
   - handle_post_request(const std::string& body, HttpResponse& response):
     * Parse JSON-RPC from body
     * Invoke message_callback
     * Return response via HttpResponse (user-defined type)
     * Store Mcp-Session-Id header if present

   - handle_get_request(HttpSseWriter& writer):
     * Send buffered messages via SSE
     * Use SseFormatter::format_event for each message
     * Support Last-Event-ID header for resumability

   - send_notification(const nlohmann::json& notification):
     * Format as SSE event
     * Buffer for next GET request

5. Session management:
   - create_session(): generates UUID v4 for session ID
   - validate_session(const std::string& session_id): checks if session exists
   - terminate_session(const std::string& session_id): removes session

6. Private members:
   - std::string current_session_id_
   - std::vector<std::string> message_buffer_  // messages pending SSE delivery
   - std::unordered_map<std::string, SessionData> sessions_  // active sessions
   - MessageCallback message_callback_
   - ErrorCallback error_callback_
   - uint64_t last_event_id_  // for SSE resumability

7. Define SessionData struct (private):
   - std::string session_id
   - std::vector<std::string> pending_messages
   - std::chrono::steady_clock::time_point last_activity

8. HttpResponse and HttpSseWriter are user-defined types - use forward declarations or templates. Document this pattern in comments.

Include MIT license header.
  </action>
  <verify>
grep -q "class HttpTransport.*:.*public Transport" src/mcpp/transport/http_transport.h && grep -q "handle_post_request\|handle_get_request" src/mcpp/transport/http_transport.h
  </verify>
  <done>
HttpTransport header defines Transport subclass with POST/GET handler methods, session management, and SSE buffering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement HttpTransport with SSE formatting</name>
  <files>src/mcpp/transport/http_transport.cpp</files>
  <action>
Create HttpTransport implementation:

1. Include MIT license header

2. Includes: http_transport.h, random (for UUID generation), sstream, chrono,iomanip

3. Session ID generation:
   - Use random_device + mt19937 for cryptographically secure random
   - Generate 32 hex digits (UUID v4 format)
   - Only ASCII 0x21-0x7E per MCP spec

4. Implement connect():
   - Generate new session via create_session()
   - Store in current_session_id_
   - Return true

5. Implement disconnect():
   - Clear current_session_id_
   - Clear message_buffer_

6. Implement send():
   - Serialize message (already JSON string)
   - Add to message_buffer_
   - Increment last_event_id_

7. Implement handle_get_request():
   - Set SSE headers via writer.set_header("Content-Type", SseFormatter::content_type())
   - For each message in buffer:
     * Format via SseFormatter::format_event(message, std::to_string(last_event_id_))
     * Write via writer.write_sse()
   - Clear buffer after sending

8. Implement set_message_callback/set_error_callback:
   - Store callbacks in member variables

9. Implement session management:
   - create_session(): generate UUID, store in sessions_
   - validate_session(): lookup in sessions_, check timeout (30 min)
   - terminate_session(): remove from sessions_

10. Session timeout:
    - Check last_activity in validate_session
    - Remove sessions inactive > 30 minutes
    - Update last_activity on each access

Note: HttpResponse and HttpSseWriter are user-provided. Document that users must define these types or use template pattern. For now, assume basic interface with set_header(), write(), get_body() methods.
  </action>
  <verify>
grep -q "SseFormatter::format_event" src/mcpp/transport/http_transport.cpp && grep -q "session" src/mcpp/transport/http_transport.cpp
  </verify>
  <done>
HttpTransport generates secure session IDs, buffers messages for SSE delivery, formats events via SseFormatter. Session timeout cleanup implemented.
  </done>
</task>

</tasks>

<verification>
After completion:
1. HttpTransport compiles and implements all Transport methods
2. Session IDs are cryptographically secure (random-generated, 32 hex digits)
3. SSE formatting uses SseFormatter from plan 04-01
4. Session cleanup removes stale sessions after 30 minutes
</verification>

<success_criteria>
1. HttpTransport implements Transport interface fully
2. Session management with secure IDs and timeout cleanup
3. SSE events formatted correctly via SseFormatter
4. User HTTP server integration pattern documented in code comments
5. No built-in HTTP server - user provides their own
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features--http-transport/04-02-SUMMARY.md`
</output>

---
phase: 04-advanced-features--http-transport
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/mcpp/util/sse_formatter.h, src/mcpp/util/uri_template.h]
autonomous: true

must_haves:
  truths:
    - "SSE formatter generates valid text/event-stream format messages"
    - "URI template expander supports RFC 6570 Level 1-2 simple variables and query params"
    - "Both utilities provide static methods for easy integration"
  artifacts:
    - path: "src/mcpp/util/sse_formatter.h"
      provides: "SSE event formatting for HTTP transport"
      min_lines: 40
      exports: ["format_event", "content_type", "cache_control", "connection"]
    - path: "src/mcpp/util/uri_template.h"
      provides: "RFC 6570 Level 1-2 URI template expansion"
      min_lines: 50
      exports: ["expand"]
  key_links:
    - from: "HTTP Transport (plan 04-02)"
      to: "sse_formatter.h"
      via: "static method call"
      pattern: "SseFormatter::format_event"
    - from: "Resource templates (plan 04-04)"
      to: "uri_template.h"
      via: "static method call"
      pattern: "UriTemplate::expand"
---

<objective>
Foundation utilities for HTTP transport and resource templates: SSE event formatter and RFC 6570 URI template expansion.

Purpose: These utilities are foundational building blocks. SSE formatter enables HTTP/SSE transport to send properly formatted server-sent events. URI template expander enables resource template feature with parameterized URIs. Both are pure utility functions with no dependencies on server code, making them perfect for Wave 1 parallel execution.

Output: Two header-only utility classes with static methods for SSE formatting and URI template expansion.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features--http-transport/04-RESEARCH.md

# Reference existing transport pattern
@src/mcpp/transport/transport.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE formatter utility</name>
  <files>src/mcpp/util/sse_formatter.h</files>
  <action>
Create header-only SseFormatter class with static methods for Server-Sent Events formatting:

1. Create directory: src/mcpp/util/

2. Create sse_formatter.h with:
   - namespace mcpp::util
   - class SseFormatter with static methods only
   - format_event(const nlohmann::json& message, const std::string& event_id = ""):
     * Returns std::string formatted as SSE event
     * Format: "data: {json}\n" + optional "id: {id}\n" + "\n"
     * JSON serialized using message.dump()
   - content_type(): returns "text/event-stream" (const char*)
   - cache_control(): returns "no-cache" (const char*)
   - connection(): returns "keep-alive" (const char*)

3. Include MIT license header (copy from existing files)

4. Include nlohmann/json.hpp for JSON serialization

Follow MCP SSE spec: data line required, double newline terminates event. Do NOT add external SSE library dependency - the format is simple enough to inline.
  </action>
  <verify>
grep -q "format_event" src/mcpp/util/sse_formatter.h && grep -q "text/event-stream" src/mcpp/util/sse_formatter.h
  </verify>
  <done>
SseFormatter::format_event produces "data: {...}\n\n" format with optional id field. HTTP response headers available via static methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create URI template expander utility</name>
  <files>src/mcpp/util/uri_template.h</files>
  <action>
Create header-only UriTemplate class with RFC 6570 Level 1-2 template expansion:

1. Create uri_template.h in src/mcpp/util/

2. Implement RFC 6570 Level 1-2 expansion:
   - namespace mcpp::util
   - class UriTemplate with static expand() method
   - expand(const std::string& template_str, const nlohmann::json& params):
     * Returns expanded std::string
     * Supports {var} simple variable substitution
     * Supports {?var*} query parameter expansion (JSON object -> key=value pairs)
     * Percent-encodes reserved characters in path/query components

3. Implementation approach:
   - Find and replace {var} patterns with params[var].get<std::string>()
   - For {?var*} with object: build "?key1=value1&key2=value2" query string
   - Use simple string find/replace - no need for full RFC 6570 parser
   - Percent-encode: space -> %20, # -> %23, etc. (RFC 3986 reserved)

4. Include MIT license header

5. Include nlohmann/json.hpp and <string>, <sstream>, <iomanip>

DO NOT add external URI template library dependency. Level 1-2 is sufficient for MCP resource templates (simple path variables, query params).
  </action>
  <verify>
grep -q "class UriTemplate" src/mcpp/util/uri_template.h && grep -q "expand" src/mcpp/util/uri_template.h
  </verify>
  <done>
UriTemplate::expand("file://{path}", {{"path": "/etc/config"}}) returns "file:///etc/config". Query expansion works for objects.
  </done>
</task>

</tasks>

<verification>
After completion:
1. Both utility headers compile without errors
2. SseFormatter::format_event produces valid SSE format with data prefix and double newline terminator
3. UriTemplate::expand handles simple variables and query parameters with proper encoding
</verification>

<success_criteria>
1. SSE formatter generates valid text/event-stream messages
2. URI template expander supports Level 1-2 templates (simple variables, query params)
3. Both utilities are header-only with no additional source files
4. No external library dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features--http-transport/04-01-SUMMARY.md`
</output>

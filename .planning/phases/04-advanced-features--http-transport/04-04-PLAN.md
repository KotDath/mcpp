---
phase: 04-advanced-features--http-transport
plan: 04
type: execute
wave: 2
depends_on: [02-05]
files_modified: [src/mcpp/server/resource_registry.h, src/mcpp/server/resource_registry.cpp]
autonomous: true

must_haves:
  truths:
    - "Resources can be registered with URI templates (e.g., 'file://{path}')"
    - "Template handlers receive expanded URI and extracted parameters"
    - "Clients can subscribe to resources and receive update notifications"
    - "Resource list includes templates with URI template pattern"
  artifacts:
    - path: "src/mcpp/server/resource_registry.h"
      provides: "Resource templates and subscription support"
      min_lines: 120
      exports: ["TemplateResourceHandler", "subscribe", "unsubscribe", "notify_updated"]
    - path: "src/mcpp/server/resource_registry.cpp"
      provides: "Template expansion and subscription implementation"
      min_lines: 200
      contains: "UriTemplate::expand, subscription tracking, notification dispatch"
  key_links:
    - from: "resource_registry.h"
      to: "uri_template.h (04-01)"
      via: "static method call for template expansion"
      pattern: "UriTemplate::expand"
    - from: "resource_registry.cpp"
      to: "mcp_server.h (02-05)"
      via: "transport for sending notifications"
      pattern: "transport.*send.*resources/updated"
    - from: "McpServer (02-05)"
      to: "resource_registry.h"
      via: "resources/subscribe and resources/unsubscribe handlers"
      pattern: "handle_resources_subscribe|handle_resources_unsubscribe"
---

<objective>
Resource templates with URI parameter expansion and resource subscriptions with change notifications.

Purpose: Resource templates enable parameterized resources (e.g., file://{path}, config://{section}). Subscriptions allow clients to receive notifications when monitored resources change, enabling real-time updates without polling.

Output: Enhanced ResourceRegistry with template registration, subscription management, and notification dispatch.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-features--http-transport/04-RESEARCH.md
@.planning/phases/04-advanced-features--http-transport/04-01-PLAN.md

# Existing resource registry to extend
@src/mcpp/server/resource_registry.h

# URI template expander from plan 04-01
@src/mcpp/util/uri_template.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resource template support to ResourceRegistry</name>
  <files>src/mcpp/server/resource_registry.h</files>
  <action>
Extend ResourceRegistry with template resources:

1. Include util/uri_template.h for template expansion

2. Add TemplateResourceHandler type:
   ```cpp
   using TemplateResourceHandler = std::function<ResourceContent(
       const std::string& expanded_uri,
       const nlohmann::json& parameters
   )>;
   ```

3. Add TemplateResourceRegistration struct:
   ```cpp
   struct TemplateResourceRegistration {
       std::string uri_template;     // e.g., "file://{path}"
       std::string name;
       std::optional<std::string> description;
       std::string mime_type;
       std::vector<std::string> parameter_names;  // extracted from template
       TemplateResourceHandler handler;
   };
   ```

4. Add template storage member:
   ```cpp
   std::unordered_map<std::string, TemplateResourceRegistration> template_resources_;
   ```

5. Add register_template method:
   ```cpp
   bool register_template(
       const std::string& uri_template,    // e.g., "file://{path}"
       const std::string& name,
       const std::optional<std::string>& description,
       const std::string& mime_type,
       TemplateResourceHandler handler
   );
   ```

6. Modify list_resources() to include templates:
   - Add "uri" field with template pattern
   - Add optional "template" field to indicate this is a template

7. Modify read_resource() to handle templates:
   - Check if URI matches any template
   - If so, expand template and call template handler
   - Extract parameters from URI during expansion

Include util/uri_template.h at top of file.
  </action>
  <verify>
grep -q "TemplateResourceHandler\|register_template" src/mcpp/server/resource_registry.h && grep -q "uri_template.h" src/mcpp/server/resource_registry.h
  </verify>
  <done>
ResourceRegistry has register_template method and TemplateResourceHandler type. Template handlers receive expanded URI and parameters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement subscriptions and notification dispatch</name>
  <files>src/mcpp/server/resource_registry.cpp</files>
  <action>
Implement resource subscriptions and template expansion:

1. Implement register_template:
   - Parse template to extract parameter names (simple: find {var} patterns)
   - Store in template_resources_
   - Return true on success

2. Implement template matching in read_resource:
   - For each template, check if URI matches pattern
   - Extract parameter values from URI
   - Build parameters JSON object
   - Call template handler with expanded URI and parameters

3. Add subscription tracking members:
   ```cpp
   struct Subscription {
       std::string uri;
       std::string subscriber_id;  // session ID or client ID
       std::chrono::steady_clock::time_point subscribed_at;
   };
   std::unordered_map<std::string, std::vector<Subscription>> subscriptions_;  // uri -> subscribers
   ```

4. Add subscribe method:
   ```cpp
   bool subscribe(const std::string& uri, const std::string& subscriber_id);
   ```
   - Add subscription to tracking
   - Return true if subscribed successfully

5. Add unsubscribe method:
   ```cpp
   bool unsubscribe(const std::string& uri, const std::string& subscriber_id);
   ```
   - Remove subscription from tracking
   - Return true if was subscribed

6. Add notify_updated method:
   ```cpp
   void notify_updated(const std::string& uri);
   ```
   - Find all subscribers for this URI
   - Send notifications/resources/updated to each subscriber via transport
   - Requires transport reference (store non-owning pointer)

7. Add transport pointer member and setter:
   ```cpp
   std::optional<Transport*> transport_;
   void set_transport(Transport& transport);
   ```

8. Use UriTemplate::expand for template expansion:
   ```cpp
   std::string expanded = UriTemplate::expand(template_str, params);
   ```

Note: Transport is non-owning pointer set by McpServer, following same pattern as RequestContext.
  </action>
  <verify>
grep -q "subscribe\|unsubscribe\|notify_updated" src/mcpp/server/resource_registry.cpp && grep -q "UriTemplate::expand" src/mcpp/server/resource_registry.cpp
  </verify>
  <done>
Resources can be subscribed/unsubscribed by client. notify_updated sends notifications/resources/updated to all subscribers. Templates use UriTemplate::expand.
  </done>
</task>

</tasks>

<verification>
After completion:
1. Template resources can be registered with URI patterns like "file://{path}"
2. Template handlers receive expanded URI and extracted parameters
3. Clients can subscribe to specific resources
4. Subscribers receive notifications/resources/updated when notify_updated is called
5. Resource list includes templates with proper template field
</verification>

<success_criteria>
1. Resource templates support RFC 6570 Level 1-2 syntax
2. Template handlers receive both expanded URI and parameter values
3. Subscription tracking per URI with subscriber_id
4. Notification dispatch to all subscribers via transport
5. Non-owning transport pointer for notification sending
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features--http-transport/04-04-SUMMARY.md`
</output>

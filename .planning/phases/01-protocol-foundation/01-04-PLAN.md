---
phase: 01-protocol-foundation
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - src/mcpp/core/request_tracker.h
  - src/mcpp/core/request_tracker.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Library generates request IDs internally using atomic counter"
    - "Pending requests are stored with their response callbacks"
    - "Request ID type supports both numeric and string IDs"
    - "Pending requests are removed when response arrives or timeout occurs"
    - "Request tracker is thread-safe (mutex protects pending map)"
  artifacts:
    - path: "src/mcpp/core/request_tracker.h"
      provides: "Request ID generation and pending request tracking"
      min_lines: 60
      contains: "class RequestTracker", "std::atomic", "std::unordered_map", "register_pending", "complete"
  key_links:
    - from: "Core API client (future plan)"
      to: "src/mcpp/core/request_tracker.h"
      via: "Calls next_id() for outgoing requests"
      pattern: "next_id|register_pending"
    - from: "Core API response handler (future plan)"
      to: "src/mcpp/core/request_tracker.h"
      via: "Calls complete() to find and invoke callback"
      pattern: "complete|RequestId"
---

<objective>
Implement library-managed request ID generation (atomic counter) and pending request tracking with thread-safe storage.

Purpose: The library must generate unique request IDs and correlate incoming responses with their waiting callbacks without user involvement.
Output: RequestTracker class with atomic ID generation, pending request map, and thread-safe operations.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-protocol-foundation/01-CONTEXT.md
@.planning/phases/01-protocol-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define RequestTracker header</name>
  <files>src/mcpp/core/request_tracker.h</files>
  <action>
Create src/mcpp/core/request_tracker.h with:

1. Include guards, <atomic>, <mutex>, <unordered_map>, <functional>, <optional>, "json_rpc.h"
2. namespace mcpp::core
3. Forward declare ResponseCallback (will be defined in async/callbacks.h)
   Using std::function<void(const JsonValue&)> for now
4. struct PendingRequest:
   - ResponseCallback on_success
   - std::function<void(const JsonRpcError&)> on_error
   - std::chrono::steady_clock::time_point timestamp
5. class RequestTracker:
   Public methods:
   - RequestId next_id() // Atomic increment, returns new ID
   - void register_pending(RequestId id, ResponseCallback on_success, std::function<void(const JsonRpcError&)> on_error)
   - std::optional<PendingRequest> complete(RequestId id) // Removes and returns pending request
   - void cancel(RequestId id) // Remove pending request without calling back
   - size_t pending_count() const
   Private members:
   - std::atomic<uint64_t> counter_{0}
   - std::unordered_map<RequestId, PendingRequest> pending_
   - std::mutex mutex_

Follow RESEARCH.md Pattern 4 "Library-Managed Request Tracking".
Use std::atomic for lock-free ID generation.
Use mutex-protected unordered_map for pending requests (per RESEARCH.md recommendation).
  </action>
  <verify>grep -E "class RequestTracker|std::atomic|register_pending|complete" src/mcpp/core/request_tracker.h</verify>
  <done>request_tracker.h defines RequestTracker with atomic ID generation and pending request storage</done>
</task>

<task type="auto">
  <name>Task 2: Implement RequestTracker</name>
  <files>src/mcpp/core/request_tracker.cpp</files>
  <action>
Create src/mcpp/core/request_tracker.cpp with:

1. Include request_tracker.h
2. Implement next_id():
   - counter_.fetch_add(1, std::memory_order_seq_cst)
   - Return as RequestId (wrapped in variant)
3. Implement register_pending():
   - Lock mutex
   - Store PendingRequest with current timestamp
   - Unlock
4. Implement complete():
   - Lock mutex
   - Find pending request by id
   - If found, move it out and erase from map
   - Unlock
   - Return moved PendingRequest or std::nullopt
5. Implement cancel():
   - Lock mutex
   - Erase pending request by id
   - Unlock
6. Implement pending_count():
   - Lock mutex
   - Return pending_.size()
   - Unlock

Use std::lock_guard for all mutex operations.
Use std::move for PendingRequest extraction to avoid copies.
  </action>
  <verify>grep -E "fetch_add|lock_guard|pending_\\." src/mcpp/core/request_tracker.cpp</verify>
  <done>request_tracker.cpp implements thread-safe ID generation and pending request tracking</done>
</task>

</tasks>

<verification>
- RequestTracker generates unique IDs via atomic counter
- register_pending stores callbacks with timestamp
- complete removes and returns the pending request
- Mutex protects all map access
- pending_count returns current pending count
</verification>

<success_criteria>
RequestTracker is thread-safe and can track pending requests.
IDs are guaranteed unique within a session.
Pending requests can be retrieved and removed by ID.
</success_criteria>

<output>
After completion, create `.planning/phases/01-protocol-foundation/01-04-SUMMARY.md`
</output>

---
phase: 01-protocol-foundation
plan: 06
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03", "01-04", "01-05"]
files_modified:
  - src/mcpp/client.h
  - src/mcpp/client.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Library consumer can create a client with a transport implementation"
    - "Library consumer can send requests and register callbacks for responses"
    - "Library consumer can send notifications (fire-and-forget)"
    - "Library consumer can register handlers for incoming requests and notifications"
    - "Library consumer can perform MCP initialize/initialized handshake"
    - "Client generates request IDs automatically"
    - "Client tracks pending requests and invokes matching callbacks"
    - "Client handles timeouts for pending requests"
  artifacts:
    - path: "src/mcpp/client.h"
      provides: "Low-level callback-based MCP client API"
      min_lines: 100
      contains: "class McpClient", "send_request", "send_notification", "set_request_handler", "initialize"
    - path: "src/mcpp/client.cpp"
      provides: "Client implementation with request/response correlation"
      min_lines: 200
      contains: "RequestTracker", "TimeoutManager", "on_message"
  key_links:
    - from: "src/mcpp/client.h"
      to: "src/mcpp/transport/transport.h"
      via: "Client holds Transport* and calls send()"
      pattern: "Transport.*transport_|send\\(.*message"
    - from: "src/mcpp/client.h"
      to: "src/mcpp/core/request_tracker.h"
      via: "Client uses RequestTracker for ID generation and pending requests"
      pattern: "RequestTracker"
    - from: "src/mcpp/client.h"
      to: "src/mcpp/async/timeout.h"
      via: "Client uses TimeoutManager for request timeouts"
      pattern: "TimeoutManager"
    - from: "src/mcpp/client.cpp"
      to: "src/mcpp/protocol/initialize.h"
      via: "initialize() method performs MCP handshake"
      pattern: "initialize|initialized"
    - from: "src/mcpp/client.cpp"
      to: "src/mcpp/core/json_rpc.h"
      via: "on_message parses JsonRpcResponse and correlates with pending requests"
      pattern: "JsonRpcResponse|from_json"
---

<objective>
Implement the low-level callback-based MCP client API that integrates all protocol foundation components.

Purpose: This is the main entry point for library users - a client that can send requests, receive responses, handle timeouts, and perform the MCP initialization handshake.
Output: McpClient class with send_request, send_notification, handler registration, and initialize handshake.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-protocol-foundation/01-CONTEXT.md
@.planning/phases/01-protocol-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define McpClient header</name>
  <files>src/mcpp/client.h</files>
  <action>
Create src/mcpp/client.h with:

1. Include guards, <memory>, <string>, <functional>, <unordered_map>
2. Include all protocol foundation headers:
   - transport/transport.h
   - core/json_rpc.h, core/request_tracker.h
   - protocol/initialize.h
   - async/callbacks.h, async/timeout.h
3. namespace mcpp
4. class McpClient:
   Public:
   - explicit McpClient(std::unique_ptr<Transport> transport, std::chrono::milliseconds default_timeout = std::chrono::milliseconds(30000))
   - ~McpClient()
   - bool connect() // Calls transport->connect()
   - void disconnect() // Calls transport->disconnect()
   - bool is_connected() const

   Request sending (generates ID automatically):
   - void send_request(std::string_view method, const JsonValue& params, ResponseCallback on_success, ErrorCallback on_error, std::optional<std::chrono::milliseconds> timeout = {})
   - void send_notification(std::string_view method, const JsonValue& params)

   Handler registration for incoming server requests:
   - using RequestHandler = std::function<JsonValue(std::string_view method, const JsonValue& params)>
   - void set_request_handler(std::string_view method, RequestHandler handler)
   - using NotificationHandler = std::function<void(std::string_view method, const JsonValue& params)>
   - void set_notification_handler(std::string_view method, NotificationHandler handler)

   MCP initialization:
   - void initialize(const InitializeRequestParams& params, std::function<void(const InitializeResult&)> on_complete, ErrorCallback on_error)
   - void send_initialized_notification()

   Private:
   - std::unique_ptr<Transport> transport_
   - RequestTracker request_tracker_
   - TimeoutManager timeout_manager_
   - std::unordered_map<std::string, RequestHandler> request_handlers_
   - std::unordered_map<std::string, NotificationHandler> notification_handlers_
   - void on_message(std::string_view message) // Transport callback
   - void on_error(std::string_view error) // Transport error callback
   - void handle_response(const JsonRpcResponse& response)
   - void handle_server_request(const JsonRpcRequest& request)
   - void handle_notification(const JsonRpcNotification& notification)

The client owns the transport (unique_ptr) and manages its lifecycle.
Follow CONTEXT.md decisions: library-managed IDs, explicit lifecycle, std::function callbacks.
  </action>
  <verify>grep -E "class McpClient|send_request|send_notification|set_request_handler|initialize" src/mcpp/client.h</verify>
  <done>client.h defines McpClient with request sending, handler registration, and initialize methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement McpClient</name>
  <files>src/mcpp/client.cpp</files>
  <action>
Create src/mcpp/client.cpp with:

1. Include client.h
2. Implement constructor:
   - Store transport
   - Set transport callbacks: set_message_callback([this](auto msg) { on_message(msg); })
   - Set error callback: set_error_callback([this](auto err) { on_error(err); })
   - Store default timeout in TimeoutManager

3. Implement connect/disconnect/is_connected: delegate to transport_

4. Implement send_request:
   - Generate ID via request_tracker_.next_id()
   - Create JsonRpcRequest with generated ID, method, params
   - Serialize to JSON (to_json() + dump())
   - Register pending request with callbacks
   - Set timeout via timeout_manager_
   - Send via transport_->send()
   - On timeout: invoke error callback with timeout error

5. Implement send_notification:
   - Create JsonRpcNotification with method, params
   - Serialize and send (no response expected, no ID tracking)

6. Implement set_request_handler/set_notification_handler:
   - Store in respective handler maps

7. Implement initialize:
   - Create InitializeRequestParams
   - Call send_request with "initialize" method, params as JSON
   - On success: parse InitializeResult from result, invoke on_complete
   - Then automatically send "initialized" notification

8. Implement send_initialized_notification:
   - Send notification with "initialized" method

9. Implement on_message (transport callback):
   - Parse JSON string
   - Try parse as JsonRpcResponse: if has id field, call handle_response
   - Try parse as JsonRpcRequest: if has method and id, call handle_server_request
   - Try parse as JsonRpcNotification: if has method and no id, call handle_notification

10. Implement handle_response:
   - Extract id from response
   - Call request_tracker_.complete(id)
   - If has result: invoke success callback
   - If has error: invoke error callback
   - Cancel timeout

11. Implement handle_server_request:
   - Look up handler by method name
   - If found: invoke handler, send response with result
   - If not found: send error response with METHOD_NOT_FOUND

12. Implement handle_notification:
   - Look up handler by method name
   - If found: invoke handler

Critical: Handle JSON parse errors gracefully (return error response).
Use std::function::operator() to invoke stored callbacks.
Ensure callbacks are moved not copied where possible.
  </action>
  <verify>grep -E "on_message|handle_response|request_tracker_|timeout_manager_|send_request|initialize" src/mcpp/client.cpp</verify>
  <done>client.cpp implements full request/response flow with ID correlation, timeout handling, and handler dispatch</done>
</task>

</tasks>

<verification>
- Client generates IDs via RequestTracker
- send_request registers pending request and timeout
- on_message parses incoming messages and routes to appropriate handler
- handle_response correlates response with pending request via ID
- Timeout triggers error callback
- initialize performs full handshake (request + initialized notification)
- Server requests invoke registered handlers
- All paths handle errors gracefully
</verification>

<success_criteria>
McpClient is fully functional as a low-level MCP client.
Users can send requests with callbacks, send notifications, register handlers, and perform initialization.
Request/response correlation works with generated IDs.
Timeouts trigger error callbacks.
</success_criteria>

<output>
After completion, create `.planning/phases/01-protocol-foundation/01-06-SUMMARY.md`
</output>

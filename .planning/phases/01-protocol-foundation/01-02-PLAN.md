---
phase: 01-protocol-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcpp/transport/transport.h
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Library consumer can derive a custom transport class from the Transport interface"
    - "Transport interface has connect(), disconnect(), is_connected() lifecycle methods"
    - "Transport interface has send() method for sending complete messages"
    - "Transport interface has set_message_callback() for receiving messages"
    - "Transport interface has set_error_callback() for async error reporting"
    - "Transport interface uses std::function for callbacks (library owns them)"
  artifacts:
    - path: "src/mcpp/transport/transport.h"
      provides: "Abstract transport interface for pluggable transports"
      min_lines: 50
      contains: "class Transport", "virtual bool connect()", "virtual bool send", "MessageCallback"
  key_links:
    - from: "Future stdio transport implementation"
      to: "src/mcpp/transport/transport.h"
      via: "inherit from Transport base class"
      pattern: "class.*:.*public.*Transport"
    - from: "Future SSE transport implementation"
      to: "src/mcpp/transport/transport.h"
      via: "inherit from Transport base class"
      pattern: "class.*:.*public.*Transport"
---

<objective>
Define the transport abstraction interface that enables pluggable transport implementations (stdio, SSE, WebSocket).

Purpose: All higher-level code communicates through this interface, allowing any transport to be swapped without changing protocol handling.
Output: Abstract Transport class with explicit lifecycle, send/receive methods, and std::function callbacks.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-protocol-foundation/01-CONTEXT.md
@.planning/phases/01-protocol-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Transport abstraction interface</name>
  <files>src/mcpp/transport/transport.h</files>
  <action>
Create src/mcpp/transport/transport.h with:

1. Include guards, <functional>, <string>, <string_view>
2. namespace mcpp::transport
3. class Transport with virtual destructor and pure virtual methods:

Lifecycle methods (explicit, NOT RAII per CONTEXT.md):
  - virtual bool connect() = 0
  - virtual void disconnect() = 0
  - virtual bool is_connected() const = 0

Message sending:
  - virtual bool send(std::string_view message) = 0
  // Note: message is already serialized JSON; transport handles framing

Message receiving (callback-based per CONTEXT.md):
  - using MessageCallback = std::function<void(std::string_view)>
  - virtual void set_message_callback(MessageCallback cb) = 0

Error reporting:
  - using ErrorCallback = std::function<void(std::string_view)>
  - virtual void set_error_callback(ErrorCallback cb) = 0

Follow RESEARCH.md Pattern 3 exactly.
Add comment: "Transport implementations handle their own message framing (e.g., newlines for stdio, SSE protocol for HTTP)."
  </action>
  <verify>grep -E "class Transport|virtual bool connect|virtual bool send|MessageCallback|ErrorCallback" src/mcpp/transport/transport.h</verify>
  <done>transport.h defines abstract Transport class with connect/disconnect/send and callback setters</done>
</task>

</tasks>

<verification>
- Transport class is abstract (pure virtual methods)
- Has virtual destructor
- Lifecycle methods are explicit (connect, disconnect, is_connected)
- Uses std::function for callbacks (library stores copies)
- Callbacks take std::string_view (no allocation for message passing)
</verification>

<success_criteria>
Transport interface is defined and can be inherited from.
Any transport implementation (stdio, SSE, WebSocket) can plug into the JSON-RPC layer.
</success_criteria>

<output>
After completion, create `.planning/phases/01-protocol-foundation/01-02-SUMMARY.md`
</output>

---
phase: 01-protocol-foundation
plan: 05
type: execute
wave: 2
depends_on: []
files_modified:
  - src/mcpp/async/callbacks.h
  - src/mcpp/async/timeout.h
  - src/mcpp/async/timeout.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Library consumer can register std::function callbacks for async responses"
    - "Library stores std::function copies (user's originals can be discarded)"
    - "Timeout manager checks for expired requests and triggers timeout callbacks"
    - "Timeout is configurable with global default and per-request override"
    - "Timeout callbacks are invoked when requests exceed their time limit"
  artifacts:
    - path: "src/mcpp/async/callbacks.h"
      provides: "Callback type definitions for async operations"
      min_lines: 30
      contains: "using ResponseCallback", "using ErrorCallback", "using NotificationCallback"
    - path: "src/mcpp/async/timeout.h"
      provides: "Timeout management for pending requests"
      min_lines: 60
      contains: "class TimeoutManager", "set_timeout", "cancel", "check_timeouts"
    - path: "src/mcpp/async/timeout.cpp"
      provides: "Timeout manager implementation"
      min_lines: 60
      contains: "check_timeouts", "deadline"
  key_links:
    - from: "RequestTracker"
      to: "src/mcpp/async/callbacks.h"
      via: "PendingRequest stores ResponseCallback and ErrorCallback"
      pattern: "ResponseCallback|ErrorCallback"
    - from: "Core API (future plan)"
      to: "src/mcpp/async/timeout.h"
      via: "Registers timeouts for outgoing requests"
      pattern: "set_timeout"
    - from: "Background timeout thread (future plan)"
      to: "src/mcpp/async/timeout.h"
      via: "Calls check_timeouts periodically"
      pattern: "check_timeouts"
---

<objective>
Define callback types and timeout manager for async request handling.

Purpose: Async operations require std::function-based callbacks and automatic timeout detection to prevent hanging requests.
Output: Callback type definitions and TimeoutManager class with deadline tracking.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-protocol-foundation/01-CONTEXT.md
@.planning/phases/01-protocol-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define callback types</name>
  <files>src/mcpp/async/callbacks.h</files>
  <action>
Create src/mcpp/async/callbacks.h with:

1. Include guards, <functional>, <string_view>
2. Forward include core/json_rpc.h for JsonValue, JsonRpcError, RequestId
3. namespace mcpp::async
4. Define callback type aliases using std::function:
   - using ResponseCallback = std::function<void(const JsonValue& result)>
   - using ErrorCallback = std::function<void(const JsonRpcError& error)>
   - using NotificationCallback = std::function<void(std::string_view method, const JsonValue& params)>
   - using TimeoutCallback = std::function<void(RequestId id)>

These are the standard callback signatures for async MCP operations.
Follow RESEARCH.md "Callback Registration Pattern".
Add comment: "Callbacks are stored as std::function copies; user's original can be discarded after registration."
  </action>
  <verify>grep -E "using.*Callback|ResponseCallback|ErrorCallback|NotificationCallback|TimeoutCallback" src/mcpp/async/callbacks.h</verify>
  <done>callbacks.h defines all callback type aliases for async operations</done>
</task>

<task type="auto">
  <name>Task 2: Define TimeoutManager header</name>
  <files>src/mcpp/async/timeout.h</files>
  <action>
Create src/mcpp/async/timeout.h with:

1. Include guards, <chrono>, <functional>, <mutex>, <unordered_map>, <vector>
2. Include async/callbacks.h for TimeoutCallback, RequestId
3. namespace mcpp::async
4. class TimeoutManager:
   Public:
   - explicit TimeoutManager(std::chrono::milliseconds default_timeout)
   - void set_timeout(RequestId id, std::chrono::milliseconds timeout, TimeoutCallback on_timeout)
   - void cancel(RequestId id) // Remove timeout entry
   - std::vector<RequestId> check_timeouts() // Returns expired request IDs, invokes their callbacks
   - std::chrono::milliseconds default_timeout() const
   Private:
   - using Clock = std::chrono::steady_clock
   - struct TimeoutEntry { Clock::time_point deadline; TimeoutCallback callback; }
   - std::chrono::milliseconds default_timeout_
   - std::unordered_map<RequestId, TimeoutEntry> deadlines_
   - std::mutex mutex_

Follow RESEARCH.md "Timeout Manager Pattern".
Use steady_clock for timeout calculations (not affected by system time changes).
check_timeouts returns expired IDs so caller can also clean up RequestTracker.
  </action>
  <verify>grep -E "class TimeoutManager|set_timeout|cancel|check_timeouts" src/mcpp/async/timeout.h</verify>
  <done>timeout.h defines TimeoutManager with timeout registration and expiration checking</done>
</task>

<task type="auto">
  <name>Task 3: Implement TimeoutManager</name>
  <files>src/mcpp/async/timeout.cpp</files>
  <action>
Create src/mcpp/async/timeout.cpp with:

1. Include timeout.h
2. Implement constructor: store default_timeout_
3. Implement set_timeout():
   - Lock mutex
   - Calculate deadline = Clock::now() + timeout
   - Store TimeoutEntry in deadlines_ map
   - Unlock
4. Implement cancel():
   - Lock mutex
   - Erase from deadlines_ map
   - Unlock
5. Implement check_timeouts():
   - Get current time
   - Lock mutex
   - Build vector of expired IDs (deadline <= now)
   - For each expired: move callback out, erase from map
   - Unlock
   - Invoke callbacks outside lock (prevents deadlock if callback calls back into TimeoutManager)
   - Return vector of expired IDs

Critical: Invoke callbacks AFTER releasing mutex to prevent deadlock if callback calls cancel() or set_timeout().
Use std::move when extracting callbacks to avoid copies.
  </action>
  <verify>grep -E "Clock::now|deadline|std::move|check_timeouts" src/mcpp/async/timeout.cpp</verify>
  <done>timeout.cpp implements timeout checking with callback invocation after mutex release</done>
</task>

</tasks>

<verification>
- Callback types use std::function for type erasure
- TimeoutManager uses steady_clock for timeout calculations
- check_timeouts invokes callbacks AFTER releasing mutex
- Expired requests are removed from deadlines map
- Default timeout is 5 minutes (300 seconds) per CONTEXT.md
</verification>

<success_criteria>
Callback types are defined for all async operations.
TimeoutManager tracks request deadlines and invokes timeout callbacks.
Thread-safe with mutex-protected deadline map.
</success_criteria>

<output>
After completion, create `.planning/phases/01-protocol-foundation/01-05-SUMMARY.md`
</output>

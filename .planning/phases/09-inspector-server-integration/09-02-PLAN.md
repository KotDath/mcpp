---
phase: 09-inspector-server-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/inspector_server.cpp
  - examples/http_server_integration.cpp
autonomous: true

must_haves:
  truths:
    - "inspector_server.cpp uses JsonRpcRequest::from_json() for request validation"
    - "Parse error responses use extract_request_id() to include proper request ID"
    - "All JSON output uses to_string_delimited() or explicit newline + flush"
    - "http_server_integration.cpp follows same validation pattern for consistency"
    - "Manual ID extraction code (lines 367-401) is removed from inspector_server.cpp"
  artifacts:
    - path: "examples/inspector_server.cpp"
      provides: "Updated stdio server with proper request validation"
      contains: "JsonRpcRequest::from_json"
    - path: "examples/http_server_integration.cpp"
      provides: "Updated HTTP example with consistent error handling"
      min_lines: 300
  key_links:
    - from: "examples/inspector_server.cpp"
      to: "src/mcpp/core/json_rpc.h"
      via: "#include mcpp/core/json_rpc.h"
      pattern: "#include.*json_rpc"
    - from: "examples/inspector_server.cpp"
      to: "JsonRpcRequest::from_json()"
      via: "Request validation in main loop"
      pattern: "from_json"
    - from: "examples/inspector_server.cpp"
      to: "JsonRpcRequest::extract_request_id()"
      via: "Error handling in catch block"
      pattern: "extract_request_id"
---

<objective>
Update inspector_server.cpp to use JsonRpcRequest::from_json() validation layer and extract_request_id() for proper parse error responses.

Purpose: Replace fragile manual JSON parsing and ID extraction with robust library helpers. This demonstrates correct usage of Phase 8 validation layer and ensures compatibility with MCP Inspector.

Output: Example server using from_json() for validation and extract_request_id() for error responses.
</objective>

<execution_context>
@/home/kotdath/.claude/get-shit-done/workflows/execute-plan.md
@/home/kotdath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/09-inspector-server-integration/09-CONTEXT.md
@.planning/phases/09-inspector-server-integration/09-RESEARCH.md
@.planning/phases/08-bug-fix-foundation/08-01-SUMMARY.md
@.planning/phases/08-bug-fix-foundation/08-02-SUMMARY.md

@src/mcpp/core/json_rpc.h
@examples/inspector_server.cpp
@examples/http_server_integration.cpp

# Key: Current fragile pattern (lines 353-413 of inspector_server.cpp)
# Uses raw json::parse() without validation
# Has manual string search for ID extraction (lines 367-401)
# Uses std::endl instead of "\n" + std::flush for protocol output
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add #include for json_rpc.h to inspector_server.cpp</name>
  <files>examples/inspector_server.cpp</files>
  <action>
    Add the missing header include at the top of the file with other includes:

    ```
    #include "mcpp/core/json_rpc.h"
    ```

    Place it after the existing mcpp includes. This is needed for JsonRpcRequest::from_json() and extract_request_id().
  </action>
  <verify>grep -q '#include "mcpp/core/json_rpc.h"' examples/inspector_server.cpp</verify>
  <done>json_rpc.h header included for JsonRpcRequest access</done>
</task>

<task type="auto">
  <name>Task 2: Replace main event loop with from_json() validation</name>
  <files>examples/inspector_server.cpp</files>
  <action>
    Rewrite the main event loop (lines 352-414) to use JsonRpcRequest::from_json():

    OLD PATTERN (replace entirely):
    ```cpp
    while (std::getline(std::cin, line)) {
        try {
            json request = json::parse(line);
            std::optional<json> response = server.handle_request(request);
            if (response.has_value()) {
                std::cout << response->dump() << std::endl;
            }
        } catch (const json::exception& e) {
            // 30+ lines of manual ID extraction...
        }
    }
    ```

    NEW PATTERN:
    ```cpp
    while (std::getline(std::cin, line)) {
        if (line.empty()) {
            continue;
        }

        try {
            json raw = json::parse(line);

            // Use Phase 8 validation layer
            if (auto parsed = JsonRpcRequest::from_json(raw)) {
                // Valid JSON-RPC request - process with server
                std::optional<json> response = server.handle_request(raw);
                if (response.has_value()) {
                    // Use newline delimiter for stdio transport
                    std::cout << response->dump() << "\\n" << std::flush;
                }
            } else {
                // Validation failed - extract ID for error response
                RequestId id = JsonRpcRequest::extract_request_id(line);
                json error_response = {
                    {"jsonrpc", "2.0"},
                    {"error", {
                        {"code", -32700},
                        {"message", "Parse error"}
                    }},
                    {"id", std::visit([](auto&& v) -> json {
                        using T = std::decay_t<decltype(v)>;
                        if constexpr (std::is_same_v<T, int64_t>) {
                            return v;
                        } else if constexpr (std::is_same_v<T, std::string>) {
                            return v;
                        }
                        return nullptr;
                    }, id)}
                };
                std::cout << error_response.dump() << "\\n" << std::flush;
            }
        } catch (const json::exception& e) {
            // Completely malformed JSON - still try to extract ID
            RequestId id = JsonRpcRequest::extract_request_id(line);
            json error_response = {
                {"jsonrpc", "2.0"},
                {"error", {
                    {"code", -32700},
                    {"message", "Parse error"}
                }},
                {"id", std::visit([](auto&& v) -> json {
                    using T = std::decay_t<decltype(v)>;
                    if constexpr (std::is_same_v<T, int64_t>) {
                        return v;
                    } else if constexpr (std::is_same_v<T, std::string>) {
                        return v;
                    }
                    return nullptr;
                }, id)}
            };
            std::cout << error_response.dump() << "\\n" << std::flush;
        }
    }
    ```

    Delete the manual ID extraction code (lines 367-401 in the current file).
    Use std::flush after each output to ensure immediate delivery.
  </action>
  <verify>grep -q "JsonRpcRequest::from_json" examples/inspector_server.cpp && ! grep -q 'size_t id_pos = line.find' examples/inspector_server.cpp</verify>
  <done>Main loop uses from_json() for validation; manual ID extraction code removed</done>
</task>

<task type="auto">
  <name>Task 3: Update http_server_integration.cpp for consistency</name>
  <files>examples/http_server_integration.cpp</files>
  <action>
    Update the HTTP example to demonstrate the same validation pattern:
    1. Add #include "mcpp/core/json_rpc.h" if not present
    2. Add a comment in the POST handler showing how to use from_json() for request validation
    3. The HTTP example is pseudo-code, so just add comments showing the pattern - no functional changes needed

    Add a comment block before the POST handler (around line 197):
    ```
    // NOTE: For proper JSON-RPC validation, wrap request parsing:
    // auto parsed = JsonRpcRequest::from_json(json::parse(req.body));
    // if (!parsed) {
    //     // Send parse error with extracted ID
    //     RequestId id = JsonRpcRequest::extract_request_id(req.body);
    //     // Return error response...
    // }
    ```
  </action>
  <verify>grep -q "JsonRpcRequest" examples/http_server_integration.cpp</verify>
  <done>HTTP example includes validation pattern in comments for consistency</done>
</task>

<task type="auto">
  <name>Task 4: Build inspector_server and verify no errors</name>
  <files></files>
  <action>
    Build the example server to verify changes compile correctly:
    1. cd /home/kotdath/omp/personal/cpp/mcpp
    2. cmake --build build --target inspector_server
    3. Verify build succeeds
    4. Check that the executable exists at build/examples/inspector_server

    If there are compilation errors about missing symbols, ensure json_rpc.cpp is being linked (should be via libmcpp).
  </action>
  <verify>ls -la build/examples/inspector_server && test -x build/examples/inspector_server</verify>
  <done>inspector_server builds successfully with new validation code</done>
</task>

</tasks>

<verification>
- [ ] #include "mcpp/core/json_rpc.h" added to inspector_server.cpp
- [ ] Main loop uses JsonRpcRequest::from_json() for validation
- [ ] Manual ID extraction code (lines 367-401) removed
- [ ] Parse error responses include extracted ID
- [ ] All stdout output uses "\n" + std::flush for proper framing
- [ ] http_server_integration.cpp has validation pattern in comments
- [ ] inspector_server builds and links successfully
</verification>

<success_criteria>
inspector_server.cpp demonstrates proper request validation using JsonRpcRequest::from_json() and proper error handling using extract_request_id().
</success_criteria>

<output>
After completion, create `.planning/phases/09-inspector-server-integration/09-02-SUMMARY.md`
</output>

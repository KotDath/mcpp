# Milestone v1.0: Initial Release

**Status:** ✅ SHIPPED 2026-02-01
**Phases:** 1-7
**Total Plans:** 46

## Overview

A modern C++17 library for the Model Context Protocol (MCP) starts with core JSON-RPC protocol handling and builds through transports, server primitives, client capabilities, advanced features, and finally a polished high-level API with full testing coverage. Each phase delivers a coherent, verifiable capability that unblocks the next phase, culminating in a production-ready library supporting the complete MCP 2025-11-25 specification.

## Phases

### Phase 1: Protocol Foundation

**Goal**: A working JSON-RPC 2.0 core with MCP initialization handshake, transport abstraction interface, and callback-based async API foundation that all other layers build upon.

**Depends on**: Nothing (first phase)

**Requirements**: PROTO-01, PROTO-02, PROTO-03, PROTO-04, PROTO-05, TRAN-03, ASYNC-03, ASYNC-05, API-01

**Plans**: 6 plans in 3 waves

Plans:
- [x] 01-01-PLAN.md — JSON-RPC 2.0 core types (Request, Response, Notification, Error)
- [x] 01-02-PLAN.md — Transport abstraction interface
- [x] 01-03-PLAN.md — MCP protocol types (capabilities, initialize/initialized)
- [x] 01-04-PLAN.md — Request tracking (atomic ID generation, pending requests)
- [x] 01-05-PLAN.md — Async callbacks and timeout manager
- [x] 01-06-PLAN.md — Low-level callback-based MCP client API

**Details:**
Implemented core JSON-RPC 2.0 types with Request ID as std::variant<int64_t, std::string> for full spec compliance. Transport abstraction with non-copyable, non-movable base class prevents accidental slicing. RequestTracker uses std::atomic for ID generation and mutex-protected unordered_map for pending requests. TimeoutManager uses steady_clock for timeout tracking immune to system time changes. Callbacks invoked after mutex release to prevent re-entrancy deadlock. McpClient owns transport via unique_ptr for clear lifecycle management.

### Phase 2: Core Server

**Goal**: A working MCP server that can list and call tools, list and read resources, and list and get prompts, communicating via stdio transport with progress token support.

**Depends on**: Phase 1 (Protocol Foundation)

**Requirements**: SRVR-01, SRVR-02, SRVR-03, SRVR-04, SRVR-05, SRVR-06, TRAN-01, ASYNC-01

**Plans**: 6 plans in 3 waves

Plans:
- [x] 02-01-PLAN.md — Tool registration and execution with JSON Schema validation
- [x] 02-02-PLAN.md — Resource registration and serving (text/blob content)
- [x] 02-03-PLAN.md — Prompt registration and retrieval with argument substitution
- [x] 02-04-PLAN.md — RequestContext for progress reporting
- [x] 02-05-PLAN.md — McpServer main class integrating all registries
- [x] 02-06-PLAN.md — StdioTransport with subprocess spawning

**Details:**
Tool registry with handler-based pattern for dynamic execution. std::function<ToolResult(const JsonValue&)> for tool callbacks. URI-agnostic storage, user decides naming scheme. Resource content with is_text flag for text vs blob field selection. MIME type at registration with optional per-read override. PromptRegistry returns MCP GetPromptResult format directly from get_prompt(). Handler receives raw arguments JSON for flexible template substitution. RequestContext with progress values as 0-100 percentage. Non-owning transport pointer following established pattern. StdioTransport uses popen() for subprocess spawning with newline delimiter per MCP spec.

### Phase 3: Client Capabilities

**Goal**: A working MCP client that can advertise and use roots, sampling, and elicitation capabilities with full cancellation support and ergonomic future-based APIs.

**Depends on**: Phase 1 (Protocol Foundation)

**Requirements**: CLNT-01, CLNT-02, CLNT-03, CLNT-04, CLNT-05, ASYNC-02, ASYNC-04

**Plans**: 8 plans (6 original + 2 gap closure)

Plans:
- [x] 03-01-PLAN.md — C++20 upgrade and cancellation support (std::stop_token, CancellationManager)
- [x] 03-02-PLAN.md — Roots management (file:// URIs, roots/list, list_changed notification)
- [x] 03-03-PLAN.md — Sampling support (sampling/createMessage for LLM completions)
- [x] 03-04-PLAN.md — Sampling with tool use (agentic loops with tool execution)
- [x] 03-05-PLAN.md — Elicitation support (form mode with JSON Schema, URL mode for out-of-band)
- [x] 03-06-PLAN.md — std::future wrapper API (ergonomic blocking API on async core)
- [x] 03-07-PLAN.md — Fix CMakeLists.txt build configuration (gap closure)
- [x] 03-08-PLAN.md — Add ClientCapabilities builder helper (gap closure)

**Details:**
Cancellation support using std::stop_token over atomic<bool> for better composability with std::jthread. Separate CancellationManager from RequestTracker for cleaner separation of concerns. Idempotent unregister operations handle race conditions. RootsManager with callback pattern for list_changed notifications. file:// URI validation using uri.rfind("file://", 0) == 0 per MCP spec. Sampling support with ContentBlock as std::variant for extensibility. Tool types added for agentic sampling loops with maximum of 10 tool iterations to prevent infinite loops. Elicitation support with PrimitiveSchema restricted to top-level properties only per MCP spec. Form mode synchronous vs URL mode asynchronous. std::future wrapper API using shared_ptr<promise> pattern ensures promise lifetime until lambda callback invoked.

### Phase 4: Advanced Features & HTTP Transport

**Goal**: Streamable HTTP (SSE) transport with non-blocking I/O, tool result streaming, resource templates, subscriptions, completions, tool annotations, and structured output.

**Depends on**: Phase 2 (Core Server - for server primitives to enhance)

**Requirements**: TRAN-02, TRAN-04, ADV-01, ADV-02, ADV-03, ADV-04, ADV-05, ADV-06

**Plans**: 6 plans in 3 waves

Plans:
- [x] 04-01-PLAN.md — SSE formatter and URI template expander utilities
- [x] 04-02-PLAN.md — Streamable HTTP transport with session management
- [x] 04-03-PLAN.md — Tool annotations and structured output
- [x] 04-04-PLAN.md — Resource templates and subscriptions
- [x] 04-05-PLAN.md — Argument completion for prompts and resources
- [x] 04-06-PLAN.md — Tool result streaming

**Details:**
Header-only SseFormatter class with static methods for text/event-stream formatting. Header-only UriTemplate class with RFC 6570 Level 1-2 template expansion using reserve-style path expansion. HttpTransport class implementing Transport interface for POST/SSE pattern. Single endpoint design with session management via Mcp-Session-Id header using UUID v4. User-provided HTTP server integration via HttpResponseAdapter and HttpSseWriterAdapter template pattern. Non-blocking I/O with 30-minute session timeout. Tool annotations with destructive, read_only, audience, priority fields. Output schema validation using nlohmann/json_schema_validator with conditional compilation. Resource templates using regex-based template matching for URI-to-template resolution. Subscription tracking via unordered_map. Completion handlers stored in unordered_map keyed by prompt/resource name.

### Phase 5: Content & Tasks

**Goal**: Rich content type handling with annotations, pagination support, list changed notifications, and experimental task lifecycle management.

**Depends on**: Phase 2 (Core Server - for content integration)

**Requirements**: CONT-01, CONT-02, CONT-03, CONT-04, ADV-07

**Plans**: 4 plans in 1 wave

Plans:
- [x] 05-01-PLAN.md — Rich content types (ImageContent, AudioContent, ResourceLink, EmbeddedResource, Annotations)
- [x] 05-02-PLAN.md — Cursor-based pagination for all list operations
- [x] 05-03-PLAN.md — List changed notifications (tools, resources, prompts)
- [x] 05-04-PLAN.md — Experimental task lifecycle management (TaskManager)

**Details:**
ContentBlock variant extended with 7 content types. Annotations struct with audience (vector<string>), priority (double 0-1), last_modified (ISO 8601 string). Base64 encoding is caller's responsibility. Content conversion implemented in sampling.cpp to avoid nlohmann::to_json naming conflicts. PaginatedResult<T> template with items, nextCursor, total, and has_more() method. Offset-based cursor encoding with PAGE_SIZE = 50. Header-only template implementation. List changed notifications using NotifyCallback pattern following RootsManager implementation. Registry callbacks check experimental capabilities for listChanged before sending.

### Phase 6: High-Level API

**Goal**: Type-safe, RAII-based high-level API wrappers with full thread safety, logging support, and utility features for production use.

**Depends on**: Phase 3 (Client Capabilities), Phase 4 (Advanced Features), Phase 5 (Content & Tasks)

**Requirements**: API-02, API-03, UTIL-01, UTIL-02, UTIL-03

**Plans**: 7 plans (5 original + 2 gap closure)

Plans:
- [x] 06-01-PLAN.md — Role-based types, Service trait with experimental capabilities, Peer, AtomicRequestIdProvider
- [x] 06-02-PLAN.md — RunningService RAII wrapper, message passing, progress timeout reset
- [x] 06-03-PLAN.md — Structured logging with spdlog and request-scoped contexts
- [x] 06-04-PLAN.md — Utility features: pagination helpers, error hierarchy
- [x] 06-05-PLAN.md — Retry strategies and CMakeLists.txt updates
- [x] 06-06-PLAN.md — Export api/context.h in CMakeLists.txt (gap closure)
- [x] 06-07-PLAN.md — Add MIT license header to util/retry.h (gap closure)

**Details:**
Role marker types (RoleClient, RoleServer) with IS_CLIENT constexpr bool for compile-time role distinction. ServiceRole concept using std::same_as for simple role validation. Atomic ID generation using memory_order_relaxed. std::shared_mutex for peer_info access with concurrent reads and exclusive writes. Service trait as pure virtual interface for polymorphic handlers. Message passing channel with std::variant<NotificationMessage, RequestMessage> for type-safe dispatch. RunningService using std::condition_variable_any for blocking wait with std::stop_token support. 5-minute default timeout with progress notifications resetting the clock. Logger class with structured logging and level filtering. Thread-safe singleton with std::call_once initialization. RequestContext template with thread-safe property access via std::shared_mutex. list_all<T> template function for automatic cursor pagination. ServiceError base class inheriting std::runtime_error. RetryPolicy template with configurable backoff strategies.

### Phase 7: Build & Validation

**Goal**: Production-ready CMake build system with static and shared libraries, MIT licensing, comprehensive test suite, and MCP Inspector integration validation.

**Depends on**: Phase 6 (High-Level API - complete API to test and package)

**Requirements**: BUILD-01, BUILD-02, BUILD-03, BUILD-04, TEST-01, TEST-02, TEST-03, TEST-04, TEST-05

**Plans**: 6 plans in 3 waves

Plans:
- [x] 07-01-PLAN.md — CMake build system with static/shared libraries and package config
- [x] 07-02a-PLAN.md — Test infrastructure setup (GoogleTest, fixtures, stubs)
- [x] 07-02b-PLAN.md — Unit test implementation (JSON-RPC, registries, pagination)
- [x] 07-03-PLAN.md — JSON-RPC compliance tests
- [x] 07-04-PLAN.md — MCP Inspector integration and integration tests
- [x] 07-05-PLAN.md — MIT license headers and README documentation

**Details:**
Dual library targets (mcpp_static, mcpp_shared) for flexible linking. CMake package config (mcppConfig.cmake.in) for find_package(mcpp) support. Version file generation with SameMajorVersion compatibility. Proper install rules for libraries, headers, and CMake config files. Conditional compilation for optional nlohmann/json-schema-validator dependency. Google Test integration with 121 unit tests covering JSON-RPC, request tracker, timeout manager, registries, and pagination. JSON-RPC compliance tests with data-driven testing using JSON fixtures. MCP Inspector integration with inspector_server example. MIT license headers added to all source files. Comprehensive README.md with features, requirements, build options, usage examples, testing guide, and installation instructions.

---

## Milestone Summary

**Decimal Phases:**
None - all planned work completed in integer phases

**Key Decisions:**
- Layered API (low-level core + high-level wrappers) for both power users and ergonomics
- Async model: callback core with future wrappers for streaming support and simple RPC
- Pragmatic dependencies (nlohmann/json, openssl, networking libs) for reliability
- Traditional library structure (separate headers/sources) to scale better than header-only
- MCP 2025-11-25 spec targeting latest standard with streaming and enhanced capabilities
- std::stop_token for cancellation (C++20 feature, compiler support available)
- Non-owning transport pointers following RequestContext pattern
- Base64 encoding as caller responsibility for binary content
- User-provided HTTP server integration via template adapter pattern
- Optional json-schema dependency with conditional compilation (MCPP_HAS_JSON_SCHEMA)
- Alternative RAII-based API pattern alongside callback-based core

**Issues Resolved:**
- Full context overflow at 100+ phases - addressed via milestone archival workflow
- Phase insertion confusion - addressed via decimal phase numbering
- PROTO-04 gap (tool execution isError flag) - closed by Phase 2 implementation
- CMakeLists.txt build configuration for header organization - closed by 03-07 gap closure
- ClientCapabilities builder - closed by 03-08 gap closure
- api/context.h export - closed by 06-06 gap closure
- Missing MIT license headers - closed by 07-05 license compliance
- http_server_integration build errors - fixed in 07-05

**Issues Deferred:**
None critical. All deferred items are intentional design decisions or documented as user responsibility.

**Technical Debt Incurred:**
- Phase 6 high-level API exists as parallel architecture but not integrated as wrapper around existing callback-based components (intentional design - provides alternative RAII-based pattern)
- HTTP transport infrastructure exists but examples use mock pattern - production HTTP server implementation left to user (intentional - library provides MCP over transports, users bring their HTTP server)

---

_For current project status, see .planning/ROADMAP.md_
